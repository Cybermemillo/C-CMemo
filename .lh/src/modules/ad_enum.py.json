{
    "sourceFile": "src/modules/ad_enum.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1740264316553,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740264360909,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -124,9 +124,9 @@\n                 user = {\r\n                     \"username\": entry.sAMAccountName.value,\r\n                     \"email\": entry.mail.value if entry.mail else None,\r\n                     \"enabled\": not bool(entry.userAccountControl.value & 2),\r\n-        Enumera grupos del dominio.\r\n+                    \"groups\": [str(g).split(',')[0].split('=')[1] for g in entry.memberOf],\r\n         \r\n         Returns:\r\n             Dict con lista de grupos o error\r\n         \"\"\"\r\n"
                },
                {
                    "date": 1740264452493,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,329 @@\n+\"\"\"\r\n+Módulo de enumeración de Active Directory.\r\n+Permite obtener información sobre usuarios, grupos y equipos en un dominio.\r\n+\"\"\"\r\n+\r\n+import socket\r\n+import logging\r\n+from typing import Dict, List, Union, Optional\r\n+import json\r\n+from datetime import datetime\r\n+\r\n+try:\r\n+    import ldap3\r\n+    LDAP_SUPPORT = True\r\n+except ImportError:\r\n+    LDAP_SUPPORT = False\r\n+    logging.warning(\"Módulo ldap3 no encontrado. La enumeración de AD estará deshabilitada.\")\r\n+\r\n+try:\r\n+    import dns.resolver\r\n+    DNS_SUPPORT = True\r\n+except ImportError:\r\n+    DNS_SUPPORT = False\r\n+    logging.warning(\"Módulo dns.resolver no encontrado. La resolución DNS estará limitada.\")\r\n+\r\n+class ADEnumerator:\r\n+    def __init__(self):\r\n+        \"\"\"Inicializa el enumerador de Active Directory.\"\"\"\r\n+        if not LDAP_SUPPORT:\r\n+            raise ImportError(\"El módulo ldap3 es requerido para usar ADEnumerator\")\r\n+        if not DNS_SUPPORT:\r\n+            raise ImportError(\"El módulo dns.resolver es requerido para usar ADEnumerator\")\r\n+            \r\n+        self.server = None\r\n+        self.connection = None\r\n+        self.domain = None\r\n+        self.base_dn = None\r\n+\r\n+    def connect(self, domain: str, username: str = None, password: str = None) -> Dict[str, Union[bool, str]]:\r\n+        \"\"\"\r\n+        Conecta al dominio de Active Directory.\r\n+        \r\n+        Args:\r\n+            domain: Nombre del dominio\r\n+            username: Usuario con acceso al dominio (opcional)\r\n+            password: Contraseña del usuario (opcional)\r\n+            \r\n+        Returns:\r\n+            Dict indicando éxito o error\r\n+        \"\"\"\r\n+        try:\r\n+            # Resolver controlador de dominio\r\n+            resolver = dns.resolver.Resolver()\r\n+            records = resolver.resolve(f\"_ldap._tcp.{domain}\", 'SRV')\r\n+            if not records:\r\n+                return {\"success\": False, \"error\": \"No se encontraron DCs\"}\r\n+                \r\n+            # Obtener DC con mayor prioridad\r\n+            dc_host = str(records[0].target).rstrip('.')\r\n+            self.domain = domain\r\n+            self.base_dn = ','.join([f\"DC={x}\" for x in domain.split('.')])\r\n+            \r\n+            # Conectar al DC\r\n+            self.server = ldap3.Server(\r\n+                dc_host,\r\n+                get_info=ldap3.ALL,\r\n+                use_ssl=True\r\n+            )\r\n+            \r\n+            if username and password:\r\n+                # Autenticación con credenciales\r\n+                self.connection = ldap3.Connection(\r\n+                    self.server,\r\n+                    user=f\"{username}@{domain}\",\r\n+                    password=password,\r\n+                    authentication=ldap3.NTLM\r\n+                )\r\n+            else:\r\n+                # Conexión anónima\r\n+                self.connection = ldap3.Connection(self.server)\r\n+            \r\n+            if not self.connection.bind():\r\n+                return {\r\n+                    \"success\": False,\r\n+                    \"error\": f\"Error de autenticación: {self.connection.result}\"\r\n+                }\r\n+                \r\n+            return {\"success\": True}\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error conectando a AD: {e}\")\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def enum_users(self, limit: int = 100) -> Dict[str, Union[bool, List[Dict[str, str]], str]]:\r\n+        \"\"\"\r\n+        Enumera usuarios del dominio.\r\n+        \r\n+        Args:\r\n+            limit: Límite de usuarios a retornar\r\n+            \r\n+        Returns:\r\n+            Dict con lista de usuarios o error\r\n+        \"\"\"\r\n+        try:\r\n+            if not self.connection:\r\n+                return {\"success\": False, \"error\": \"No hay conexión al dominio\"}\r\n+                \r\n+            self.connection.search(\r\n+                self.base_dn,\r\n+                '(&(objectClass=user)(objectCategory=person))',\r\n+                attributes=[\r\n+                    'sAMAccountName',\r\n+                    'mail',\r\n+                    'userAccountControl',\r\n+                    'memberOf',\r\n+                    'whenCreated',\r\n+                    'lastLogon'\r\n+                ],\r\n+                size_limit=limit\r\n+            )\r\n+            \r\n+            users = []\r\n+            for entry in self.connection.entries:\r\n+                user = {\r\n+                    \"username\": entry.sAMAccountName.value,\r\n+                    \"email\": entry.mail.value if entry.mail else None,\r\n+                    \"enabled\": not bool(entry.userAccountControl.value & 2),\r\n+                    \"groups\": [str(g).split(',')[0].split('=')[1] for g in entry.memberOf],\r\n+                    \"created\": str(entry.whenCreated.value) if entry.whenCreated else None,\r\n+                    \"last_logon\": datetime.fromtimestamp(entry.lastLogon.value / 10000000 - 11644473600).strftime('%Y-%m-%d %H:%M:%S') if entry.lastLogon.value else None\r\n+                }\r\n+                users.append(user)\r\n+                \r\n+            return {\r\n+                \"success\": True,\r\n+                \"users\": users\r\n+            }\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error enumerando usuarios: {e}\")\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def enum_groups(self) -> Dict[str, Union[bool, List[Dict[str, str]], str]]:\r\n+        \"\"\"\r\n+        Enumera grupos del dominio.\r\n+        \r\n+        Returns:\r\n+            Dict con lista de grupos o error\r\n+        \"\"\"\r\n+        try:\r\n+            if not self.connection:\r\n+                return {\"success\": False, \"error\": \"No hay conexión al dominio\"}\r\n+                \r\n+            self.connection.search(\r\n+                self.base_dn,\r\n+                '(objectClass=group)',\r\n+                attributes=[\r\n+                    'cn',\r\n+                    'description',\r\n+                    'member',\r\n+                    'groupType'\r\n+                ]\r\n+            )\r\n+            \r\n+            groups = []\r\n+            for entry in self.connection.entries:\r\n+                group = {\r\n+                    \"name\": entry.cn.value,\r\n+                    \"description\": entry.description.value if entry.description else None,\r\n+                    \"members\": len(entry.member) if entry.member else 0,\r\n+                    \"type\": \"Security\" if entry.groupType.value & 0x80000000 else \"Distribution\"\r\n+                }\r\n+                groups.append(group)\r\n+                \r\n+            return {\r\n+                \"success\": True,\r\n+                \"groups\": groups\r\n+            }\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error enumerando grupos: {e}\")\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def enum_computers(self) -> Dict[str, Union[bool, List[Dict[str, str]], str]]:\r\n+        \"\"\"\r\n+        Enumera equipos del dominio.\r\n+        \r\n+        Returns:\r\n+            Dict con lista de equipos o error\r\n+        \"\"\"\r\n+        try:\r\n+            if not self.connection:\r\n+                return {\"success\": False, \"error\": \"No hay conexión al dominio\"}\r\n+                \r\n+            self.connection.search(\r\n+                self.base_dn,\r\n+                '(objectClass=computer)',\r\n+                attributes=[\r\n+                    'dNSHostName',\r\n+                    'operatingSystem',\r\n+                    'operatingSystemVersion',\r\n+                    'lastLogon',\r\n+                    'logonCount'\r\n+                ]\r\n+            )\r\n+            \r\n+            computers = []\r\n+            for entry in self.connection.entries:\r\n+                computer = {\r\n+                    \"hostname\": entry.dNSHostName.value if entry.dNSHostName else None,\r\n+                    \"os\": entry.operatingSystem.value if entry.operatingSystem else None,\r\n+                    \"version\": entry.operatingSystemVersion.value if entry.operatingSystemVersion else None,\r\n+                    \"last_logon\": datetime.fromtimestamp(entry.lastLogon.value / 10000000 - 11644473600).strftime('%Y-%m-%d %H:%M:%S') if entry.lastLogon.value else None,\r\n+                    \"logon_count\": entry.logonCount.value if entry.logonCount else 0\r\n+                }\r\n+                computers.append(computer)\r\n+                \r\n+            return {\r\n+                \"success\": True,\r\n+                \"computers\": computers\r\n+            }\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error enumerando equipos: {e}\")\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def get_domain_admins(self) -> Dict[str, Union[bool, List[str], str]]:\r\n+        \"\"\"\r\n+        Obtiene lista de administradores del dominio.\r\n+        \r\n+        Returns:\r\n+            Dict con lista de administradores o error\r\n+        \"\"\"\r\n+        try:\r\n+            if not self.connection:\r\n+                return {\"success\": False, \"error\": \"No hay conexión al dominio\"}\r\n+                \r\n+            self.connection.search(\r\n+                self.base_dn,\r\n+                '(&(objectClass=group)(cn=Domain Admins))',\r\n+                attributes=['member']\r\n+            )\r\n+            \r\n+            if not self.connection.entries:\r\n+                return {\"success\": False, \"error\": \"Grupo Domain Admins no encontrado\"}\r\n+                \r\n+            admins = []\r\n+            for member_dn in self.connection.entries[0].member:\r\n+                self.connection.search(\r\n+                    member_dn,\r\n+                    '(objectClass=*)',\r\n+                    attributes=['sAMAccountName']\r\n+                )\r\n+                if self.connection.entries:\r\n+                    admins.append(self.connection.entries[0].sAMAccountName.value)\r\n+                    \r\n+            return {\r\n+                \"success\": True,\r\n+                \"admins\": admins\r\n+            }\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error obteniendo administradores: {e}\")\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def get_user_info(self, username: str) -> Dict[str, Union[bool, Dict[str, str], str]]:\r\n+        \"\"\"\r\n+        Obtiene información detallada de un usuario.\r\n+        \r\n+        Args:\r\n+            username: Nombre del usuario\r\n+            \r\n+        Returns:\r\n+            Dict con información del usuario o error\r\n+        \"\"\"\r\n+        try:\r\n+            if not self.connection:\r\n+                return {\"success\": False, \"error\": \"No hay conexión al dominio\"}\r\n+                \r\n+            self.connection.search(\r\n+                self.base_dn,\r\n+                f'(&(objectClass=user)(sAMAccountName={username}))',\r\n+                attributes=[\r\n+                    'displayName',\r\n+                    'mail',\r\n+                    'userAccountControl',\r\n+                    'memberOf',\r\n+                    'whenCreated',\r\n+                    'lastLogon',\r\n+                    'pwdLastSet',\r\n+                    'logonCount',\r\n+                    'badPwdCount'\r\n+                ]\r\n+            )\r\n+            \r\n+            if not self.connection.entries:\r\n+                return {\"success\": False, \"error\": \"Usuario no encontrado\"}\r\n+                \r\n+            entry = self.connection.entries[0]\r\n+            info = {\r\n+                \"display_name\": entry.displayName.value if entry.displayName else None,\r\n+                \"email\": entry.mail.value if entry.mail else None,\r\n+                \"enabled\": not bool(entry.userAccountControl.value & 2),\r\n+                \"groups\": [str(g).split(',')[0].split('=')[1] for g in entry.memberOf],\r\n+                \"created\": str(entry.whenCreated.value) if entry.whenCreated else None,\r\n+                \"last_logon\": datetime.fromtimestamp(entry.lastLogon.value / 10000000 - 11644473600).strftime('%Y-%m-%d %H:%M:%S') if entry.lastLogon.value else None,\r\n+                \"password_last_set\": datetime.fromtimestamp(entry.pwdLastSet.value / 10000000 - 11644473600).strftime('%Y-%m-%d %H:%M:%S') if entry.pwdLastSet.value else None,\r\n+                \"logon_count\": entry.logonCount.value if entry.logonCount else 0,\r\n+                \"bad_password_count\": entry.badPwdCount.value if entry.badPwdCount else 0\r\n+            }\r\n+            \r\n+            return {\r\n+                \"success\": True,\r\n+                \"info\": info\r\n+            }\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error obteniendo información de usuario: {e}\")\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def disconnect(self):\r\n+        \"\"\"Cierra la conexión con el dominio.\"\"\"\r\n+        try:\r\n+            if self.connection:\r\n+                self.connection.unbind()\r\n+            self.connection = None\r\n+            self.server = None\r\n+        except Exception as e:\r\n+            logging.error(f\"Error desconectando de AD: {e}\")\r\n"
                }
            ],
            "date": 1740264316553,
            "name": "Commit-0",
            "content": "\"\"\"\r\nMódulo de enumeración de Active Directory.\r\nPermite obtener información sobre usuarios, grupos y equipos en un dominio.\r\n\"\"\"\r\n\r\nimport ldap3\r\nimport socket\r\nimport dns.resolver\r\nimport logging\r\nfrom typing import Dict, List, Union, Optional\r\nimport json\r\nfrom datetime import datetime\r\n\r\nclass ADEnumerator:\r\n    def __init__(self):\r\n        \"\"\"Inicializa el enumerador de Active Directory.\"\"\"\r\n        self.server = None\r\n        self.connection = None\r\n        self.domain = None\r\n        self.base_dn = None\r\n\r\n    def connect(self, domain: str, username: str = None, password: str = None) -> Dict[str, Union[bool, str]]:\r\n        \"\"\"\r\n        Conecta al dominio de Active Directory.\r\n        \r\n        Args:\r\n            domain: Nombre del dominio\r\n            username: Usuario con acceso al dominio (opcional)\r\n            password: Contraseña del usuario (opcional)\r\n            \r\n        Returns:\r\n            Dict indicando éxito o error\r\n        \"\"\"\r\n        try:\r\n            # Resolver controlador de dominio\r\n            resolver = dns.resolver.Resolver()\r\n            records = resolver.resolve(f\"_ldap._tcp.{domain}\", 'SRV')\r\n            if not records:\r\n                return {\"success\": False, \"error\": \"No se encontraron DCs\"}\r\n                \r\n            # Obtener DC con mayor prioridad\r\n            dc_host = str(records[0].target).rstrip('.')\r\n            self.domain = domain\r\n            self.base_dn = ','.join([f\"DC={x}\" for x in domain.split('.')])\r\n            \r\n            # Conectar al DC\r\n            self.server = ldap3.Server(\r\n                dc_host,\r\n                get_info=ldap3.ALL,\r\n                use_ssl=True\r\n            )\r\n            \r\n            if username and password:\r\n                # Autenticación con credenciales\r\n                self.connection = ldap3.Connection(\r\n                    self.server,\r\n                    user=f\"{username}@{domain}\",\r\n                    password=password,\r\n                    authentication=ldap3.NTLM\r\n                )\r\n            else:\r\n                # Conexión anónima\r\n                self.connection = ldap3.Connection(self.server)\r\n            \r\n            if not self.connection.bind():\r\n                return {\r\n                    \"success\": False,\r\n                    \"error\": f\"Error de autenticación: {self.connection.result}\"\r\n                }\r\n                \r\n            return {\"success\": True}\r\n            \r\n        except Exception as e:\r\n            logging.error(f\"Error conectando a AD: {e}\")\r\n            return {\"success\": False, \"error\": str(e)}\r\n\r\n    def enum_users(self, limit: int = 100) -> Dict[str, Union[bool, List[Dict[str, str]], str]]:\r\n        \"\"\"\r\n        Enumera usuarios del dominio.\r\n        \r\n        Args:\r\n            limit: Límite de usuarios a retornar\r\n            \r\n        Returns:\r\n            Dict con lista de usuarios o error\r\n        \"\"\"\r\n        try:\r\n            if not self.connection:\r\n                return {\"success\": False, \"error\": \"No hay conexión al dominio\"}\r\n                \r\n            self.connection.search(\r\n                self.base_dn,\r\n                '(&(objectClass=user)(objectCategory=person))',\r\n                attributes=[\r\n                    'sAMAccountName',\r\n                    'mail',\r\n                    'userAccountControl',\r\n                    'memberOf',\r\n                    'whenCreated',\r\n                    'lastLogon'\r\n                ],\r\n                size_limit=limit\r\n            )\r\n            \r\n            users = []\r\n            for entry in self.connection.entries:\r\n                user = {\r\n                    \"username\": entry.sAMAccountName.value,\r\n                    \"email\": entry.mail.value if entry.mail else None,\r\n                    \"enabled\": not bool(entry.userAccountControl.value & 2),\r\n                    \"groups\": [str(g).split(',')[0].split('=')[1] for g in entry.memberOf],\r\n                    \"created\": str(entry.whenCreated.value) if entry.whenCreated else None,\r\n                    \"last_logon\": datetime.fromtimestamp(entry.lastLogon.value / 10000000 - 11644473600).strftime('%Y-%m-%d %H:%M:%S') if entry.lastLogon.value else None\r\n                }\r\n                users.append(user)\r\n                \r\n            return {\r\n                \"success\": True,\r\n                \"users\": users\r\n            }\r\n            \r\n        except Exception as e:\r\n            logging.error(f\"Error enumerando usuarios: {e}\")\r\n            return {\"success\": False, \"error\": str(e)}\r\n\r\n    def enum_groups(self) -> Dict[str, Union[bool, List[Dict[str, str]], str]]:\r\n        \"\"\"\r\n        Enumera grupos del dominio.\r\n        \r\n        Returns:\r\n            Dict con lista de grupos o error\r\n        \"\"\"\r\n        try:\r\n            if not self.connection:\r\n                return {\"success\": False, \"error\": \"No hay conexión al dominio\"}\r\n                \r\n            self.connection.search(\r\n                self.base_dn,\r\n                '(objectClass=group)',\r\n                attributes=[\r\n                    'cn',\r\n                    'description',\r\n                    'member',\r\n                    'groupType'\r\n                ]\r\n            )\r\n            \r\n            groups = []\r\n            for entry in self.connection.entries:\r\n                group = {\r\n                    \"name\": entry.cn.value,\r\n                    \"description\": entry.description.value if entry.description else None,\r\n                    \"members\": len(entry.member) if entry.member else 0,\r\n                    \"type\": \"Security\" if entry.groupType.value & 0x80000000 else \"Distribution\"\r\n                }\r\n                groups.append(group)\r\n                \r\n            return {\r\n                \"success\": True,\r\n                \"groups\": groups\r\n            }\r\n            \r\n        except Exception as e:\r\n            logging.error(f\"Error enumerando grupos: {e}\")\r\n            return {\"success\": False, \"error\": str(e)}\r\n\r\n    def enum_computers(self) -> Dict[str, Union[bool, List[Dict[str, str]], str]]:\r\n        \"\"\"\r\n        Enumera equipos del dominio.\r\n        \r\n        Returns:\r\n            Dict con lista de equipos o error\r\n        \"\"\"\r\n        try:\r\n            if not self.connection:\r\n                return {\"success\": False, \"error\": \"No hay conexión al dominio\"}\r\n                \r\n            self.connection.search(\r\n                self.base_dn,\r\n                '(objectClass=computer)',\r\n                attributes=[\r\n                    'dNSHostName',\r\n                    'operatingSystem',\r\n                    'operatingSystemVersion',\r\n                    'lastLogon',\r\n                    'logonCount'\r\n                ]\r\n            )\r\n            \r\n            computers = []\r\n            for entry in self.connection.entries:\r\n                computer = {\r\n                    \"hostname\": entry.dNSHostName.value if entry.dNSHostName else None,\r\n                    \"os\": entry.operatingSystem.value if entry.operatingSystem else None,\r\n                    \"version\": entry.operatingSystemVersion.value if entry.operatingSystemVersion else None,\r\n                    \"last_logon\": datetime.fromtimestamp(entry.lastLogon.value / 10000000 - 11644473600).strftime('%Y-%m-%d %H:%M:%S') if entry.lastLogon.value else None,\r\n                    \"logon_count\": entry.logonCount.value if entry.logonCount else 0\r\n                }\r\n                computers.append(computer)\r\n                \r\n            return {\r\n                \"success\": True,\r\n                \"computers\": computers\r\n            }\r\n            \r\n        except Exception as e:\r\n            logging.error(f\"Error enumerando equipos: {e}\")\r\n            return {\"success\": False, \"error\": str(e)}\r\n\r\n    def get_domain_admins(self) -> Dict[str, Union[bool, List[str], str]]:\r\n        \"\"\"\r\n        Obtiene lista de administradores del dominio.\r\n        \r\n        Returns:\r\n            Dict con lista de administradores o error\r\n        \"\"\"\r\n        try:\r\n            if not self.connection:\r\n                return {\"success\": False, \"error\": \"No hay conexión al dominio\"}\r\n                \r\n            self.connection.search(\r\n                self.base_dn,\r\n                '(&(objectClass=group)(cn=Domain Admins))',\r\n                attributes=['member']\r\n            )\r\n            \r\n            if not self.connection.entries:\r\n                return {\"success\": False, \"error\": \"Grupo Domain Admins no encontrado\"}\r\n                \r\n            admins = []\r\n            for member_dn in self.connection.entries[0].member:\r\n                self.connection.search(\r\n                    member_dn,\r\n                    '(objectClass=*)',\r\n                    attributes=['sAMAccountName']\r\n                )\r\n                if self.connection.entries:\r\n                    admins.append(self.connection.entries[0].sAMAccountName.value)\r\n                    \r\n            return {\r\n                \"success\": True,\r\n                \"admins\": admins\r\n            }\r\n            \r\n        except Exception as e:\r\n            logging.error(f\"Error obteniendo administradores: {e}\")\r\n            return {\"success\": False, \"error\": str(e)}\r\n\r\n    def get_user_info(self, username: str) -> Dict[str, Union[bool, Dict[str, str], str]]:\r\n        \"\"\"\r\n        Obtiene información detallada de un usuario.\r\n        \r\n        Args:\r\n            username: Nombre del usuario\r\n            \r\n        Returns:\r\n            Dict con información del usuario o error\r\n        \"\"\"\r\n        try:\r\n            if not self.connection:\r\n                return {\"success\": False, \"error\": \"No hay conexión al dominio\"}\r\n                \r\n            self.connection.search(\r\n                self.base_dn,\r\n                f'(&(objectClass=user)(sAMAccountName={username}))',\r\n                attributes=[\r\n                    'displayName',\r\n                    'mail',\r\n                    'userAccountControl',\r\n                    'memberOf',\r\n                    'whenCreated',\r\n                    'lastLogon',\r\n                    'pwdLastSet',\r\n                    'logonCount',\r\n                    'badPwdCount'\r\n                ]\r\n            )\r\n            \r\n            if not self.connection.entries:\r\n                return {\"success\": False, \"error\": \"Usuario no encontrado\"}\r\n                \r\n            entry = self.connection.entries[0]\r\n            info = {\r\n                \"display_name\": entry.displayName.value if entry.displayName else None,\r\n                \"email\": entry.mail.value if entry.mail else None,\r\n                \"enabled\": not bool(entry.userAccountControl.value & 2),\r\n                \"groups\": [str(g).split(',')[0].split('=')[1] for g in entry.memberOf],\r\n                \"created\": str(entry.whenCreated.value) if entry.whenCreated else None,\r\n                \"last_logon\": datetime.fromtimestamp(entry.lastLogon.value / 10000000 - 11644473600).strftime('%Y-%m-%d %H:%M:%S') if entry.lastLogon.value else None,\r\n                \"password_last_set\": datetime.fromtimestamp(entry.pwdLastSet.value / 10000000 - 11644473600).strftime('%Y-%m-%d %H:%M:%S') if entry.pwdLastSet.value else None,\r\n                \"logon_count\": entry.logonCount.value if entry.logonCount else 0,\r\n                \"bad_password_count\": entry.badPwdCount.value if entry.badPwdCount else 0\r\n            }\r\n            \r\n            return {\r\n                \"success\": True,\r\n                \"info\": info\r\n            }\r\n            \r\n        except Exception as e:\r\n            logging.error(f\"Error obteniendo información de usuario: {e}\")\r\n            return {\"success\": False, \"error\": str(e)}\r\n\r\n    def disconnect(self):\r\n        \"\"\"Cierra la conexión con el dominio.\"\"\"\r\n        try:\r\n            if self.connection:\r\n                self.connection.unbind()\r\n            self.connection = None\r\n            self.server = None\r\n        except Exception as e:\r\n            logging.error(f\"Error desconectando de AD: {e}\")\r\n"
        }
    ]
}