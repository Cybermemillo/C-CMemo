{
    "sourceFile": "src/modules/screen_capture.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1740262283189,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1740262283189,
            "name": "Commit-0",
            "content": "\"\"\"\r\nMódulo de captura de pantalla en tiempo real.\r\nProporciona capacidades para capturar, comprimir y transmitir\r\nel escritorio del sistema de forma eficiente.\r\n\"\"\"\r\n\r\nimport time\r\nimport threading\r\nimport logging\r\nimport mss\r\nimport mss.tools\r\nimport cv2\r\nimport numpy as np\r\nimport base64\r\nimport io\r\nfrom PIL import Image\r\nimport zlib\r\nfrom queue import Queue\r\nimport socket\r\n\r\nclass ScreenCapture:\r\n    def __init__(self, quality=60, fps=10, compression_level=6):\r\n        \"\"\"\r\n        Inicializa el capturador de pantalla.\r\n        \r\n        Args:\r\n            quality (int): Calidad de compresión JPEG (1-100)\r\n            fps (int): Frames por segundo objetivo\r\n            compression_level (int): Nivel de compresión zlib (1-9)\r\n        \"\"\"\r\n        self.quality = quality\r\n        self.fps = fps\r\n        self.compression_level = compression_level\r\n        self.running = False\r\n        self.frame_queue = Queue(maxsize=30)  # Buffer para 30 frames\r\n        self.sct = mss.mss()\r\n        self.latest_frame = None\r\n        self.capture_thread = None\r\n        self.process_thread = None\r\n        self.stream_sockets = set()\r\n        self.lock = threading.Lock()\r\n\r\n    def start(self):\r\n        \"\"\"Inicia la captura de pantalla.\"\"\"\r\n        try:\r\n            self.running = True\r\n            self.capture_thread = threading.Thread(target=self._capture_loop)\r\n            self.process_thread = threading.Thread(target=self._process_loop)\r\n            self.capture_thread.daemon = True\r\n            self.process_thread.daemon = True\r\n            self.capture_thread.start()\r\n            self.process_thread.start()\r\n            return {\"success\": True}\r\n        except Exception as e:\r\n            return {\"success\": False, \"error\": str(e)}\r\n\r\n    def stop(self):\r\n        \"\"\"Detiene la captura de pantalla.\"\"\"\r\n        try:\r\n            self.running = False\r\n            if self.capture_thread:\r\n                self.capture_thread.join()\r\n            if self.process_thread:\r\n                self.process_thread.join()\r\n            return {\"success\": True}\r\n        except Exception as e:\r\n            return {\"success\": False, \"error\": str(e)}\r\n\r\n    def _capture_loop(self):\r\n        \"\"\"Loop principal de captura.\"\"\"\r\n        frame_time = 1.0 / self.fps\r\n        while self.running:\r\n            try:\r\n                start_time = time.time()\r\n                \r\n                # Capturar pantalla\r\n                screenshot = self.sct.grab(self.sct.monitors[0])\r\n                \r\n                # Convertir a formato PIL\r\n                img = Image.frombytes(\"RGB\", screenshot.size, screenshot.rgb)\r\n                \r\n                # Redimensionar si es necesario\r\n                if img.size[0] > 1920 or img.size[1] > 1080:\r\n                    img.thumbnail((1920, 1080), Image.Resampling.LANCZOS)\r\n                \r\n                # Poner en cola para procesamiento\r\n                if not self.frame_queue.full():\r\n                    self.frame_queue.put(img)\r\n                \r\n                # Mantener FPS constante\r\n                elapsed = time.time() - start_time\r\n                if elapsed < frame_time:\r\n                    time.sleep(frame_time - elapsed)\r\n                    \r\n            except Exception as e:\r\n                logging.error(f\"Error en captura: {e}\")\r\n                time.sleep(0.1)\r\n\r\n    def _process_loop(self):\r\n        \"\"\"Loop de procesamiento de frames.\"\"\"\r\n        while self.running:\r\n            try:\r\n                if not self.frame_queue.empty():\r\n                    img = self.frame_queue.get()\r\n                    \r\n                    # Convertir a JPEG\r\n                    buffer = io.BytesIO()\r\n                    img.save(buffer, format=\"JPEG\", quality=self.quality)\r\n                    jpeg_data = buffer.getvalue()\r\n                    \r\n                    # Comprimir con zlib\r\n                    compressed_data = zlib.compress(jpeg_data, self.compression_level)\r\n                    \r\n                    # Guardar el frame más reciente\r\n                    with self.lock:\r\n                        self.latest_frame = compressed_data\r\n                    \r\n                    # Enviar a clientes conectados\r\n                    self._broadcast_frame(compressed_data)\r\n            except Exception as e:\r\n                logging.error(f\"Error en procesamiento: {e}\")\r\n                time.sleep(0.1)\r\n\r\n    def get_latest_frame(self, format=\"jpeg\"):\r\n        \"\"\"\r\n        Obtiene el último frame capturado.\r\n        \r\n        Args:\r\n            format (str): Formato de salida ('jpeg', 'base64', 'compressed')\r\n        \r\n        Returns:\r\n            dict: Frame en el formato especificado\r\n        \"\"\"\r\n        try:\r\n            with self.lock:\r\n                if not self.latest_frame:\r\n                    return {\"success\": False, \"error\": \"No hay frames disponibles\"}\r\n                \r\n                if format == \"compressed\":\r\n                    return {\r\n                        \"success\": True,\r\n                        \"data\": self.latest_frame,\r\n                        \"compression\": \"zlib\"\r\n                    }\r\n                \r\n                # Descomprimir\r\n                jpeg_data = zlib.decompress(self.latest_frame)\r\n                \r\n                if format == \"base64\":\r\n                    return {\r\n                        \"success\": True,\r\n                        \"data\": base64.b64encode(jpeg_data).decode()\r\n                    }\r\n                else:  # jpeg\r\n                    return {\r\n                        \"success\": True,\r\n                        \"data\": jpeg_data\r\n                    }\r\n        except Exception as e:\r\n            return {\"success\": False, \"error\": str(e)}\r\n\r\n    def add_stream_socket(self, socket):\r\n        \"\"\"Añade un socket para streaming.\"\"\"\r\n        self.stream_sockets.add(socket)\r\n\r\n    def remove_stream_socket(self, socket):\r\n        \"\"\"Elimina un socket de streaming.\"\"\"\r\n        self.stream_sockets.discard(socket)\r\n\r\n    def _broadcast_frame(self, frame_data):\r\n        \"\"\"Envía el frame a todos los sockets conectados.\"\"\"\r\n        dead_sockets = set()\r\n        \r\n        for sock in self.stream_sockets:\r\n            try:\r\n                # Enviar tamaño del frame\r\n                size = len(frame_data)\r\n                sock.send(size.to_bytes(4, byteorder='big'))\r\n                \r\n                # Enviar frame\r\n                sock.sendall(frame_data)\r\n            except:\r\n                dead_sockets.add(sock)\r\n        \r\n        # Limpiar sockets muertos\r\n        for sock in dead_sockets:\r\n            self.remove_stream_socket(sock)\r\n\r\n    def get_stats(self):\r\n        \"\"\"Obtiene estadísticas de la captura.\"\"\"\r\n        try:\r\n            return {\r\n                \"success\": True,\r\n                \"stats\": {\r\n                    \"fps\": self.fps,\r\n                    \"quality\": self.quality,\r\n                    \"compression\": self.compression_level,\r\n                    \"queue_size\": self.frame_queue.qsize(),\r\n                    \"clients\": len(self.stream_sockets),\r\n                    \"resolution\": self.sct.monitors[0][\"width\"] + \"x\" + self.sct.monitors[0][\"height\"]\r\n                }\r\n            }\r\n        except Exception as e:\r\n            return {\"success\": False, \"error\": str(e)}\r\n\r\n    def cambiar_configuracion(self, **kwargs):\r\n        \"\"\"\r\n        Actualiza la configuración en tiempo real.\r\n        \r\n        Args:\r\n            **kwargs: Parámetros a actualizar (quality, fps, compression_level)\r\n        \"\"\"\r\n        try:\r\n            if \"quality\" in kwargs:\r\n                self.quality = max(1, min(100, kwargs[\"quality\"]))\r\n            if \"fps\" in kwargs:\r\n                self.fps = max(1, min(60, kwargs[\"fps\"]))\r\n            if \"compression_level\" in kwargs:\r\n                self.compression_level = max(1, min(9, kwargs[\"compression_level\"]))\r\n            return {\"success\": True}\r\n        except Exception as e:\r\n            return {\"success\": False, \"error\": str(e)}\r\n"
        }
    ]
}