{
    "sourceFile": "src/modules/interactive_shell.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1740263439036,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1740263439036,
            "name": "Commit-0",
            "content": "\"\"\"\r\nMódulo de shell interactiva.\r\nProporciona una shell persistente con capacidades avanzadas.\r\n\"\"\"\r\n\r\nimport os\r\nimport pty\r\nimport select\r\nimport socket\r\nimport subprocess\r\nimport threading\r\nimport time\r\nimport logging\r\nimport platform\r\nimport queue\r\nfrom typing import Optional, Tuple, Any\r\n\r\nclass InteractiveShell:\r\n    def __init__(self):\r\n        \"\"\"Inicializa la shell interactiva.\"\"\"\r\n        self.shell_proc = None\r\n        self.is_windows = platform.system().lower() == \"windows\"\r\n        self.running = False\r\n        self.command_queue = queue.Queue()\r\n        self.output_queue = queue.Queue()\r\n        self.last_activity = time.time()\r\n        self.timeout = 300  # 5 minutos de timeout por defecto\r\n\r\n    def start(self) -> bool:\r\n        \"\"\"\r\n        Inicia la shell interactiva.\r\n        \r\n        Returns:\r\n            bool: True si se inició correctamente\r\n        \"\"\"\r\n        try:\r\n            if self.is_windows:\r\n                self.shell_proc = subprocess.Popen(\r\n                    [\"cmd.exe\"],\r\n                    stdin=subprocess.PIPE,\r\n                    stdout=subprocess.PIPE,\r\n                    stderr=subprocess.PIPE,\r\n                    shell=True,\r\n                    text=True,\r\n                    creationflags=subprocess.CREATE_NO_WINDOW\r\n                )\r\n            else:\r\n                # Usar pty para shells en Unix\r\n                master, slave = pty.openpty()\r\n                self.shell_proc = subprocess.Popen(\r\n                    [\"/bin/bash\", \"-i\"],\r\n                    stdin=slave,\r\n                    stdout=slave,\r\n                    stderr=slave,\r\n                    text=True\r\n                )\r\n                os.close(slave)\r\n                self.master = master\r\n\r\n            self.running = True\r\n            \r\n            # Iniciar threads de lectura/escritura\r\n            threading.Thread(target=self._read_output, daemon=True).start()\r\n            threading.Thread(target=self._process_commands, daemon=True).start()\r\n            threading.Thread(target=self._check_timeout, daemon=True).start()\r\n            \r\n            return True\r\n            \r\n        except Exception as e:\r\n            logging.error(f\"Error iniciando shell interactiva: {e}\")\r\n            return False\r\n\r\n    def stop(self):\r\n        \"\"\"Detiene la shell interactiva.\"\"\"\r\n        self.running = False\r\n        if self.shell_proc:\r\n            self.shell_proc.terminate()\r\n            self.shell_proc = None\r\n\r\n    def execute(self, command: str) -> None:\r\n        \"\"\"\r\n        Encola un comando para ejecución.\r\n        \r\n        Args:\r\n            command: Comando a ejecutar\r\n        \"\"\"\r\n        self.last_activity = time.time()\r\n        self.command_queue.put(command)\r\n\r\n    def get_output(self, timeout: float = 0.1) -> Optional[str]:\r\n        \"\"\"\r\n        Obtiene la salida pendiente de la shell.\r\n        \r\n        Args:\r\n            timeout: Tiempo máximo de espera\r\n            \r\n        Returns:\r\n            str: Salida de la shell o None si no hay datos\r\n        \"\"\"\r\n        try:\r\n            return self.output_queue.get(timeout=timeout)\r\n        except queue.Empty:\r\n            return None\r\n\r\n    def _read_output(self):\r\n        \"\"\"Lee continuamente la salida de la shell.\"\"\"\r\n        while self.running:\r\n            try:\r\n                if self.is_windows:\r\n                    output = self.shell_proc.stdout.readline()\r\n                    if output:\r\n                        self.output_queue.put(output)\r\n                else:\r\n                    # Lectura no bloqueante para Unix\r\n                    r, _, _ = select.select([self.master], [], [], 0.1)\r\n                    if r:\r\n                        output = os.read(self.master, 1024).decode()\r\n                        if output:\r\n                            self.output_queue.put(output)\r\n            except Exception as e:\r\n                logging.error(f\"Error leyendo salida de shell: {e}\")\r\n                time.sleep(0.1)\r\n\r\n    def _process_commands(self):\r\n        \"\"\"Procesa comandos pendientes.\"\"\"\r\n        while self.running:\r\n            try:\r\n                cmd = self.command_queue.get(timeout=0.1)\r\n                if not cmd:\r\n                    continue\r\n\r\n                if self.is_windows:\r\n                    self.shell_proc.stdin.write(f\"{cmd}\\n\")\r\n                    self.shell_proc.stdin.flush()\r\n                else:\r\n                    os.write(self.master, f\"{cmd}\\n\".encode())\r\n                    \r\n            except queue.Empty:\r\n                continue\r\n            except Exception as e:\r\n                logging.error(f\"Error procesando comando: {e}\")\r\n\r\n    def _check_timeout(self):\r\n        \"\"\"Verifica timeouts de inactividad.\"\"\"\r\n        while self.running:\r\n            if time.time() - self.last_activity > self.timeout:\r\n                logging.info(\"Shell terminada por inactividad\")\r\n                self.stop()\r\n                break\r\n            time.sleep(1)\r\n\r\n    def is_alive(self) -> bool:\r\n        \"\"\"\r\n        Verifica si la shell sigue activa.\r\n        \r\n        Returns:\r\n            bool: True si la shell está activa\r\n        \"\"\"\r\n        return self.running and self.shell_proc and self.shell_proc.poll() is None\r\n\r\n    def set_timeout(self, seconds: int):\r\n        \"\"\"\r\n        Establece el timeout de inactividad.\r\n        \r\n        Args:\r\n            seconds: Segundos de inactividad permitidos\r\n        \"\"\"\r\n        self.timeout = seconds\r\n\r\n    def reset(self) -> bool:\r\n        \"\"\"\r\n        Reinicia la shell.\r\n        \r\n        Returns:\r\n            bool: True si se reinició correctamente\r\n        \"\"\"\r\n        self.stop()\r\n        return self.start()\r\n"
        }
    ]
}