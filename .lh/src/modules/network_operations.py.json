{
    "sourceFile": "src/modules/network_operations.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1740263144001,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740263263152,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,9 +8,8 @@\n import socket\r\n import subprocess\r\n import platform\r\n import logging\r\n-import netifaces\r\n import struct\r\n import requests\r\n from typing import Dict, List, Optional, Union, Tuple\r\n from ipaddress import IPv4Network, IPv4Address\r\n@@ -21,30 +20,44 @@\n         self.os_type = platform.system().lower()\r\n \r\n     def get_network_interfaces(self) -> List[Dict[str, Union[str, List[str]]]]:\r\n         \"\"\"\r\n-        Obtiene información detallada de todas las interfaces de red.\r\n+        Obtiene información detallada de todas las interfaces de red usando psutil.\r\n         \r\n         Returns:\r\n             Lista de diccionarios con información de cada interfaz\r\n         \"\"\"\r\n         try:\r\n             interfaces = []\r\n-            for iface in netifaces.interfaces():\r\n+            net_if_addrs = psutil.net_if_addrs()\r\n+            net_if_stats = psutil.net_if_stats()\r\n+            \r\n+            for iface, addrs in net_if_addrs.items():\r\n                 try:\r\n-                    addrs = netifaces.ifaddresses(iface)\r\n-                    ipv4_info = addrs.get(netifaces.AF_INET, [])\r\n-                    ipv6_info = addrs.get(netifaces.AF_INET6, [])\r\n-                    mac_info = addrs.get(netifaces.AF_LINK, [])\r\n+                    ipv4_addresses = []\r\n+                    ipv4_netmasks = []\r\n+                    ipv6_addresses = []\r\n+                    mac = 'Unknown'\r\n                     \r\n+                    for addr in addrs:\r\n+                        if addr.family == socket.AF_INET:  # IPv4\r\n+                            ipv4_addresses.append(addr.address)\r\n+                            if hasattr(addr, 'netmask'):\r\n+                                ipv4_netmasks.append(addr.netmask)\r\n+                        elif addr.family == socket.AF_INET6:  # IPv6\r\n+                            ipv6_addresses.append(addr.address)\r\n+                        elif addr.family == psutil.AF_LINK:  # MAC\r\n+                            mac = addr.address\r\n+                    \r\n+                    stats = net_if_stats.get(iface, None)\r\n                     interface_info = {\r\n                         'name': iface,\r\n-                        'mac': mac_info[0]['addr'] if mac_info else 'Unknown',\r\n-                        'ipv4_addresses': [addr['addr'] for addr in ipv4_info],\r\n-                        'ipv4_netmasks': [addr['netmask'] for addr in ipv4_info],\r\n-                        'ipv6_addresses': [addr['addr'] for addr in ipv6_info],\r\n-                        'status': 'up' if self._is_interface_up(iface) else 'down',\r\n-                        'mtu': self._get_interface_mtu(iface)\r\n+                        'mac': mac,\r\n+                        'ipv4_addresses': ipv4_addresses,\r\n+                        'ipv4_netmasks': ipv4_netmasks,\r\n+                        'ipv6_addresses': ipv6_addresses,\r\n+                        'status': 'up' if stats and stats.isup else 'down',\r\n+                        'mtu': stats.mtu if stats else None\r\n                     }\r\n                     interfaces.append(interface_info)\r\n                 except Exception as e:\r\n                     logging.error(f\"Error obteniendo información de interfaz {iface}: {e}\")\r\n@@ -201,62 +214,42 @@\n         except Exception as e:\r\n             logging.error(f\"Error analizando DNS para {domain}: {e}\")\r\n             return {'error': str(e)}\r\n \r\n-    def _is_interface_up(self, iface: str) -> bool:\r\n-        \"\"\"Comprueba si una interfaz está activa.\"\"\"\r\n+    def _get_default_interface(self) -> Optional[str]:\r\n+        \"\"\"Obtiene la interfaz de red predeterminada usando psutil.\"\"\"\r\n         try:\r\n-            if self.os_type == \"linux\":\r\n-                with open(f\"/sys/class/net/{iface}/operstate\") as f:\r\n-                    return f.read().strip() == \"up\"\r\n-            else:\r\n-                # En Windows usamos ipconfig\r\n-                output = subprocess.check_output(f\"ipconfig /all\", shell=True).decode()\r\n-                return iface in output and \"Media disconnected\" not in output\r\n+            # Obtener la interfaz con conexión activa\r\n+            stats = psutil.net_if_stats()\r\n+            for iface, stat in stats.items():\r\n+                if stat.isup and self._has_internet_connection(iface):\r\n+                    return iface\r\n         except:\r\n-            return False\r\n+            pass\r\n+        return None\r\n \r\n-    def _get_interface_mtu(self, iface: str) -> Optional[int]:\r\n-        \"\"\"Obtiene el MTU de una interfaz.\"\"\"\r\n+    def _has_internet_connection(self, iface: str) -> bool:\r\n+        \"\"\"Verifica si una interfaz tiene conexión a Internet.\"\"\"\r\n         try:\r\n-            if self.os_type == \"linux\":\r\n-                with open(f\"/sys/class/net/{iface}/mtu\") as f:\r\n-                    return int(f.read().strip())\r\n-            else:\r\n-                # En Windows es más complejo, requiere WMI\r\n-                return 1500  # valor por defecto\r\n+            addrs = psutil.net_if_addrs().get(iface, [])\r\n+            for addr in addrs:\r\n+                if addr.family == socket.AF_INET:\r\n+                    return True\r\n         except:\r\n-            return None\r\n-\r\n-    def _get_protocol_name(self, proto: int) -> str:\r\n-        \"\"\"Convierte número de protocolo a nombre.\"\"\"\r\n-        protocols = {\r\n-            socket.IPPROTO_TCP: 'TCP',\r\n-            socket.IPPROTO_UDP: 'UDP',\r\n-            socket.IPPROTO_ICMP: 'ICMP'\r\n-        }\r\n-        return protocols.get(proto, str(proto))\r\n-\r\n-    def _get_default_interface(self) -> Optional[str]:\r\n-        \"\"\"Obtiene la interfaz de red predeterminada.\"\"\"\r\n-        try:\r\n-            gateways = netifaces.gateways()\r\n-            default = gateways.get('default', {}).get(netifaces.AF_INET)\r\n-            if default:\r\n-                return default[1]\r\n-        except:\r\n             pass\r\n-        return None\r\n+        return False\r\n \r\n     def _get_network_range(self, interface: str) -> Optional[IPv4Network]:\r\n-        \"\"\"Obtiene el rango de red para una interfaz.\"\"\"\r\n+        \"\"\"Obtiene el rango de red para una interfaz usando psutil.\"\"\"\r\n         try:\r\n-            addrs = netifaces.ifaddresses(interface)\r\n-            ipv4_info = addrs.get(netifaces.AF_INET, [{}])[0]\r\n-            if 'addr' in ipv4_info and 'netmask' in ipv4_info:\r\n-                # Convertir IP y máscara a CIDR\r\n-                network = IPv4Network(f\"{ipv4_info['addr']}/{ipv4_info['netmask']}\", strict=False)\r\n-                return network\r\n+            addrs = psutil.net_if_addrs().get(interface, [])\r\n+            for addr in addrs:\r\n+                if addr.family == socket.AF_INET:\r\n+                    ip = addr.address\r\n+                    netmask = addr.netmask\r\n+                    if ip and netmask:\r\n+                        network = IPv4Network(f\"{ip}/{netmask}\", strict=False)\r\n+                        return network\r\n         except:\r\n             pass\r\n         return None\r\n \r\n@@ -294,8 +287,15 @@\n     def _get_vendor_from_mac(self, mac: str) -> str:\r\n         \"\"\"Obtiene el fabricante a partir de una dirección MAC.\"\"\"\r\n         try:\r\n             if mac and mac != \"Unknown\":\r\n+            pass\r\n+        return \"Unknown\"\r\n+\r\n+    def _get_vendor_from_mac(self, mac: str) -> str:\r\n+        \"\"\"Obtiene el fabricante a partir de una dirección MAC.\"\"\"\r\n+        try:\r\n+            if mac and mac != \"Unknown\":\r\n                 # Usar los primeros 6 caracteres (OUI)\r\n                 oui = mac.replace(\":\", \"\").replace(\"-\", \"\")[:6].upper()\r\n                 # Se podría implementar una base de datos local de OUIs\r\n                 # o hacer una consulta a una API de búsqueda de fabricantes\r\n"
                },
                {
                    "date": 1740263289170,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -287,15 +287,8 @@\n     def _get_vendor_from_mac(self, mac: str) -> str:\r\n         \"\"\"Obtiene el fabricante a partir de una dirección MAC.\"\"\"\r\n         try:\r\n             if mac and mac != \"Unknown\":\r\n-            pass\r\n-        return \"Unknown\"\r\n-\r\n-    def _get_vendor_from_mac(self, mac: str) -> str:\r\n-        \"\"\"Obtiene el fabricante a partir de una dirección MAC.\"\"\"\r\n-        try:\r\n-            if mac and mac != \"Unknown\":\r\n                 # Usar los primeros 6 caracteres (OUI)\r\n                 oui = mac.replace(\":\", \"\").replace(\"-\", \"\")[:6].upper()\r\n                 # Se podría implementar una base de datos local de OUIs\r\n                 # o hacer una consulta a una API de búsqueda de fabricantes\r\n"
                },
                {
                    "date": 1740266551858,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -295,4 +295,20 @@\n                 return \"Vendor lookup not implemented\"\r\n         except:\r\n             pass\r\n         return \"Unknown\"\r\n+\r\n+\"\"\"\r\n+Módulo para operaciones de red\r\n+\"\"\"\r\n+\r\n+class NetworkOperations:\r\n+    def __init__(self):\r\n+        self.connections = []\r\n+        \r\n+    def scan_ports(self, target):\r\n+        \"\"\"Escanea puertos en un objetivo\"\"\"\r\n+        pass\r\n+        \r\n+    def get_active_connections(self):\r\n+        \"\"\"Obtiene conexiones de red activas\"\"\"\r\n+        pass\r\n"
                }
            ],
            "date": 1740263144001,
            "name": "Commit-0",
            "content": "\"\"\"\r\nMódulo de operaciones de red.\r\nProporciona funciones para enumerar y analizar conexiones de red,\r\ninterfaces y realizar operaciones básicas de networking.\r\n\"\"\"\r\n\r\nimport psutil\r\nimport socket\r\nimport subprocess\r\nimport platform\r\nimport logging\r\nimport netifaces\r\nimport struct\r\nimport requests\r\nfrom typing import Dict, List, Optional, Union, Tuple\r\nfrom ipaddress import IPv4Network, IPv4Address\r\n\r\nclass NetworkAnalyzer:\r\n    def __init__(self):\r\n        \"\"\"Inicializa el analizador de red.\"\"\"\r\n        self.os_type = platform.system().lower()\r\n\r\n    def get_network_interfaces(self) -> List[Dict[str, Union[str, List[str]]]]:\r\n        \"\"\"\r\n        Obtiene información detallada de todas las interfaces de red.\r\n        \r\n        Returns:\r\n            Lista de diccionarios con información de cada interfaz\r\n        \"\"\"\r\n        try:\r\n            interfaces = []\r\n            for iface in netifaces.interfaces():\r\n                try:\r\n                    addrs = netifaces.ifaddresses(iface)\r\n                    ipv4_info = addrs.get(netifaces.AF_INET, [])\r\n                    ipv6_info = addrs.get(netifaces.AF_INET6, [])\r\n                    mac_info = addrs.get(netifaces.AF_LINK, [])\r\n                    \r\n                    interface_info = {\r\n                        'name': iface,\r\n                        'mac': mac_info[0]['addr'] if mac_info else 'Unknown',\r\n                        'ipv4_addresses': [addr['addr'] for addr in ipv4_info],\r\n                        'ipv4_netmasks': [addr['netmask'] for addr in ipv4_info],\r\n                        'ipv6_addresses': [addr['addr'] for addr in ipv6_info],\r\n                        'status': 'up' if self._is_interface_up(iface) else 'down',\r\n                        'mtu': self._get_interface_mtu(iface)\r\n                    }\r\n                    interfaces.append(interface_info)\r\n                except Exception as e:\r\n                    logging.error(f\"Error obteniendo información de interfaz {iface}: {e}\")\r\n                    continue\r\n                    \r\n            return interfaces\r\n        except Exception as e:\r\n            logging.error(f\"Error listando interfaces de red: {e}\")\r\n            return []\r\n\r\n    def get_active_connections(self) -> List[Dict[str, Union[str, int]]]:\r\n        \"\"\"\r\n        Lista todas las conexiones de red activas.\r\n        \r\n        Returns:\r\n            Lista de diccionarios con información de cada conexión\r\n        \"\"\"\r\n        try:\r\n            connections = []\r\n            for conn in psutil.net_connections(kind='all'):\r\n                try:\r\n                    process = psutil.Process(conn.pid) if conn.pid else None\r\n                    connection_info = {\r\n                        'protocol': self._get_protocol_name(conn.type),\r\n                        'local_address': f\"{conn.laddr.ip}:{conn.laddr.port}\" if conn.laddr else \"\",\r\n                        'remote_address': f\"{conn.raddr.ip}:{conn.raddr.port}\" if conn.raddr else \"\",\r\n                        'status': conn.status,\r\n                        'pid': conn.pid,\r\n                        'process_name': process.name() if process else \"Unknown\",\r\n                        'user': process.username() if process else \"Unknown\"\r\n                    }\r\n                    connections.append(connection_info)\r\n                except (psutil.NoSuchProcess, psutil.AccessDenied):\r\n                    continue\r\n            return connections\r\n        except Exception as e:\r\n            logging.error(f\"Error obteniendo conexiones activas: {e}\")\r\n            return []\r\n\r\n    def scan_local_network(self, interface: str = None) -> List[Dict[str, str]]:\r\n        \"\"\"\r\n        Realiza un escaneo básico de la red local.\r\n        \r\n        Args:\r\n            interface: Nombre de la interfaz a escanear (opcional)\r\n            \r\n        Returns:\r\n            Lista de dispositivos encontrados\r\n        \"\"\"\r\n        try:\r\n            if not interface:\r\n                interface = self._get_default_interface()\r\n\r\n            network = self._get_network_range(interface)\r\n            if not network:\r\n                return []\r\n\r\n            devices = []\r\n            for ip in network.hosts():\r\n                try:\r\n                    if self._ping_host(str(ip)):\r\n                        hostname = socket.getfqdn(str(ip))\r\n                        mac = self._get_mac_address(str(ip))\r\n                        devices.append({\r\n                            'ip': str(ip),\r\n                            'hostname': hostname,\r\n                            'mac': mac,\r\n                            'vendor': self._get_vendor_from_mac(mac)\r\n                        })\r\n                except Exception as e:\r\n                    logging.debug(f\"Error escaneando {ip}: {e}\")\r\n                    continue\r\n\r\n            return devices\r\n        except Exception as e:\r\n            logging.error(f\"Error escaneando red local: {e}\")\r\n            return []\r\n\r\n    def get_network_statistics(self) -> Dict[str, Dict[str, int]]:\r\n        \"\"\"\r\n        Obtiene estadísticas de uso de red por interfaz.\r\n        \r\n        Returns:\r\n            Diccionario con estadísticas por interfaz\r\n        \"\"\"\r\n        try:\r\n            stats = {}\r\n            net_io = psutil.net_io_counters(pernic=True)\r\n            \r\n            for iface, counters in net_io.items():\r\n                stats[iface] = {\r\n                    'bytes_sent': counters.bytes_sent,\r\n                    'bytes_recv': counters.bytes_recv,\r\n                    'packets_sent': counters.packets_sent,\r\n                    'packets_recv': counters.packets_recv,\r\n                    'errin': counters.errin,\r\n                    'errout': counters.errout,\r\n                    'dropin': counters.dropin,\r\n                    'dropout': counters.dropout\r\n                }\r\n            \r\n            return stats\r\n        except Exception as e:\r\n            logging.error(f\"Error obteniendo estadísticas de red: {e}\")\r\n            return {}\r\n\r\n    def analyze_dns(self, domain: str) -> Dict[str, Union[List[str], str]]:\r\n        \"\"\"\r\n        Realiza un análisis básico de DNS para un dominio.\r\n        \r\n        Args:\r\n            domain: Dominio a analizar\r\n            \r\n        Returns:\r\n            Diccionario con información DNS\r\n        \"\"\"\r\n        try:\r\n            result = {\r\n                'domain': domain,\r\n                'a_records': [],\r\n                'mx_records': [],\r\n                'ns_records': [],\r\n                'txt_records': []\r\n            }\r\n            \r\n            # Registros A\r\n            try:\r\n                ips = socket.gethostbyname_ex(domain)[2]\r\n                result['a_records'] = ips\r\n            except:\r\n                pass\r\n                \r\n            # Otros registros mediante dig/nslookup\r\n            if self.os_type == \"linux\":\r\n                cmd = f\"dig {domain} ANY +noall +answer\"\r\n            else:\r\n                cmd = f\"nslookup -type=any {domain}\"\r\n                \r\n            try:\r\n                output = subprocess.check_output(cmd, shell=True, text=True)\r\n                # Parsear salida según el formato del comando\r\n                # Este es un parsing básico, se puede mejorar según necesidades\r\n                for line in output.splitlines():\r\n                    if \"MX\" in line:\r\n                        result['mx_records'].append(line.strip())\r\n                    elif \"NS\" in line:\r\n                        result['ns_records'].append(line.strip())\r\n                    elif \"TXT\" in line:\r\n                        result['txt_records'].append(line.strip())\r\n            except:\r\n                pass\r\n                \r\n            return result\r\n        except Exception as e:\r\n            logging.error(f\"Error analizando DNS para {domain}: {e}\")\r\n            return {'error': str(e)}\r\n\r\n    def _is_interface_up(self, iface: str) -> bool:\r\n        \"\"\"Comprueba si una interfaz está activa.\"\"\"\r\n        try:\r\n            if self.os_type == \"linux\":\r\n                with open(f\"/sys/class/net/{iface}/operstate\") as f:\r\n                    return f.read().strip() == \"up\"\r\n            else:\r\n                # En Windows usamos ipconfig\r\n                output = subprocess.check_output(f\"ipconfig /all\", shell=True).decode()\r\n                return iface in output and \"Media disconnected\" not in output\r\n        except:\r\n            return False\r\n\r\n    def _get_interface_mtu(self, iface: str) -> Optional[int]:\r\n        \"\"\"Obtiene el MTU de una interfaz.\"\"\"\r\n        try:\r\n            if self.os_type == \"linux\":\r\n                with open(f\"/sys/class/net/{iface}/mtu\") as f:\r\n                    return int(f.read().strip())\r\n            else:\r\n                # En Windows es más complejo, requiere WMI\r\n                return 1500  # valor por defecto\r\n        except:\r\n            return None\r\n\r\n    def _get_protocol_name(self, proto: int) -> str:\r\n        \"\"\"Convierte número de protocolo a nombre.\"\"\"\r\n        protocols = {\r\n            socket.IPPROTO_TCP: 'TCP',\r\n            socket.IPPROTO_UDP: 'UDP',\r\n            socket.IPPROTO_ICMP: 'ICMP'\r\n        }\r\n        return protocols.get(proto, str(proto))\r\n\r\n    def _get_default_interface(self) -> Optional[str]:\r\n        \"\"\"Obtiene la interfaz de red predeterminada.\"\"\"\r\n        try:\r\n            gateways = netifaces.gateways()\r\n            default = gateways.get('default', {}).get(netifaces.AF_INET)\r\n            if default:\r\n                return default[1]\r\n        except:\r\n            pass\r\n        return None\r\n\r\n    def _get_network_range(self, interface: str) -> Optional[IPv4Network]:\r\n        \"\"\"Obtiene el rango de red para una interfaz.\"\"\"\r\n        try:\r\n            addrs = netifaces.ifaddresses(interface)\r\n            ipv4_info = addrs.get(netifaces.AF_INET, [{}])[0]\r\n            if 'addr' in ipv4_info and 'netmask' in ipv4_info:\r\n                # Convertir IP y máscara a CIDR\r\n                network = IPv4Network(f\"{ipv4_info['addr']}/{ipv4_info['netmask']}\", strict=False)\r\n                return network\r\n        except:\r\n            pass\r\n        return None\r\n\r\n    def _ping_host(self, ip: str) -> bool:\r\n        \"\"\"Realiza un ping a una IP.\"\"\"\r\n        try:\r\n            if self.os_type == \"windows\":\r\n                cmd = f\"ping -n 1 -w 100 {ip}\"\r\n            else:\r\n                cmd = f\"ping -c 1 -W 1 {ip}\"\r\n            return subprocess.call(cmd, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) == 0\r\n        except:\r\n            return False\r\n\r\n    def _get_mac_address(self, ip: str) -> str:\r\n        \"\"\"Obtiene la dirección MAC de una IP.\"\"\"\r\n        try:\r\n            if self.os_type == \"linux\":\r\n                cmd = f\"arp -n {ip}\"\r\n            else:\r\n                cmd = f\"arp -a {ip}\"\r\n            output = subprocess.check_output(cmd, shell=True).decode()\r\n            # Extraer MAC del output (el formato varía según el SO)\r\n            # Este es un parsing básico, se puede mejorar\r\n            for line in output.splitlines():\r\n                if ip in line:\r\n                    parts = line.split()\r\n                    for part in parts:\r\n                        if \":\" in part or \"-\" in part:\r\n                            return part\r\n        except:\r\n            pass\r\n        return \"Unknown\"\r\n\r\n    def _get_vendor_from_mac(self, mac: str) -> str:\r\n        \"\"\"Obtiene el fabricante a partir de una dirección MAC.\"\"\"\r\n        try:\r\n            if mac and mac != \"Unknown\":\r\n                # Usar los primeros 6 caracteres (OUI)\r\n                oui = mac.replace(\":\", \"\").replace(\"-\", \"\")[:6].upper()\r\n                # Se podría implementar una base de datos local de OUIs\r\n                # o hacer una consulta a una API de búsqueda de fabricantes\r\n                return \"Vendor lookup not implemented\"\r\n        except:\r\n            pass\r\n        return \"Unknown\"\r\n"
        }
    ]
}