{
    "sourceFile": "src/modules/command_history.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1740264844582,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1740264844582,
            "name": "Commit-0",
            "content": "\"\"\"\r\nMódulo de historial de comandos.\r\nMantiene un registro detallado de comandos y sus resultados.\r\n\"\"\"\r\n\r\nimport sqlite3\r\nimport json\r\nimport logging\r\nfrom datetime import datetime\r\nfrom typing import Dict, List, Optional, Union\r\nimport hashlib\r\n\r\nclass CommandHistory:\r\n    def __init__(self, db_path: str):\r\n        \"\"\"Inicializa el gestor de historial.\"\"\"\r\n        self.db_path = db_path\r\n        self._init_db()\r\n\r\n    def _init_db(self):\r\n        \"\"\"Inicializa la base de datos de historial.\"\"\"\r\n        try:\r\n            with sqlite3.connect(self.db_path) as conn:\r\n                cursor = conn.cursor()\r\n                \r\n                # Tabla de comandos\r\n                cursor.execute('''\r\n                CREATE TABLE IF NOT EXISTS command_history (\r\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n                    bot_id INTEGER,\r\n                    command TEXT,\r\n                    command_type TEXT,\r\n                    arguments JSON,\r\n                    timestamp TIMESTAMP,\r\n                    execution_time FLOAT,\r\n                    success BOOLEAN,\r\n                    result TEXT,\r\n                    error_message TEXT,\r\n                    hash TEXT\r\n                )''')\r\n\r\n                # Tabla de tags\r\n                cursor.execute('''\r\n                CREATE TABLE IF NOT EXISTS command_tags (\r\n                    command_id INTEGER,\r\n                    tag TEXT,\r\n                    FOREIGN KEY (command_id) REFERENCES command_history(id)\r\n                )''')\r\n\r\n                conn.commit()\r\n        except Exception as e:\r\n            logging.error(f\"Error inicializando base de datos de historial: {e}\")\r\n            raise\r\n\r\n    def add_command(self, bot_id: int, command: str, command_type: str,\r\n                   arguments: Dict = None, tags: List[str] = None) -> int:\r\n        \"\"\"\r\n        Añade un nuevo comando al historial.\r\n        \r\n        Returns:\r\n            ID del comando en el historial\r\n        \"\"\"\r\n        try:\r\n            timestamp = datetime.now()\r\n            command_hash = hashlib.sha256(\r\n                f\"{bot_id}{command}{timestamp.isoformat()}\".encode()\r\n            ).hexdigest()\r\n\r\n            with sqlite3.connect(self.db_path) as conn:\r\n                cursor = conn.cursor()\r\n                cursor.execute('''\r\n                INSERT INTO command_history \r\n                (bot_id, command, command_type, arguments, timestamp, hash)\r\n                VALUES (?, ?, ?, ?, ?, ?)\r\n                ''', (\r\n                    bot_id, command, command_type,\r\n                    json.dumps(arguments) if arguments else None,\r\n                    timestamp, command_hash\r\n                ))\r\n                \r\n                command_id = cursor.lastrowid\r\n\r\n                # Añadir tags si existen\r\n                if tags:\r\n                    cursor.executemany(\r\n                        'INSERT INTO command_tags (command_id, tag) VALUES (?, ?)',\r\n                        [(command_id, tag) for tag in tags]\r\n                    )\r\n\r\n                conn.commit()\r\n                return command_id\r\n\r\n        except Exception as e:\r\n            logging.error(f\"Error añadiendo comando al historial: {e}\")\r\n            raise\r\n\r\n    def update_result(self, command_id: int, success: bool, result: str = None,\r\n                     error_message: str = None, execution_time: float = None):\r\n        \"\"\"Actualiza el resultado de un comando.\"\"\"\r\n        try:\r\n            with sqlite3.connect(self.db_path) as conn:\r\n                cursor = conn.cursor()\r\n                cursor.execute('''\r\n                UPDATE command_history \r\n                SET success = ?, result = ?, error_message = ?, execution_time = ?\r\n                WHERE id = ?\r\n                ''', (success, result, error_message, execution_time, command_id))\r\n                conn.commit()\r\n        except Exception as e:\r\n            logging.error(f\"Error actualizando resultado: {e}\")\r\n            raise\r\n\r\n    def get_command_history(self, bot_id: Optional[int] = None,\r\n                          limit: int = 100, offset: int = 0,\r\n                          tags: List[str] = None) -> List[Dict]:\r\n        \"\"\"Obtiene el historial de comandos con filtros.\"\"\"\r\n        try:\r\n            with sqlite3.connect(self.db_path) as conn:\r\n                conn.row_factory = sqlite3.Row\r\n                cursor = conn.cursor()\r\n\r\n                query = '''\r\n                SELECT DISTINCT h.*, GROUP_CONCAT(t.tag) as tags\r\n                FROM command_history h\r\n                LEFT JOIN command_tags t ON h.id = t.command_id\r\n                '''\r\n                params = []\r\n\r\n                # Aplicar filtros\r\n                conditions = []\r\n                if bot_id is not None:\r\n                    conditions.append(\"h.bot_id = ?\")\r\n                    params.append(bot_id)\r\n\r\n                if tags:\r\n                    placeholders = ','.join(['?'] * len(tags))\r\n                    conditions.append(f'''\r\n                        h.id IN (\r\n                            SELECT command_id \r\n                            FROM command_tags \r\n                            WHERE tag IN ({placeholders})\r\n                            GROUP BY command_id \r\n                            HAVING COUNT(DISTINCT tag) = ?\r\n                        )\r\n                    ''')\r\n                    params.extend(tags)\r\n                    params.append(len(tags))\r\n\r\n                if conditions:\r\n                    query += \" WHERE \" + \" AND \".join(conditions)\r\n\r\n                query += '''\r\n                GROUP BY h.id\r\n                ORDER BY h.timestamp DESC\r\n                LIMIT ? OFFSET ?\r\n                '''\r\n                params.extend([limit, offset])\r\n\r\n                cursor.execute(query, params)\r\n                rows = cursor.fetchall()\r\n\r\n                return [{\r\n                    **dict(row),\r\n                    'arguments': json.loads(row['arguments']) if row['arguments'] else None,\r\n                    'tags': row['tags'].split(',') if row['tags'] else []\r\n                } for row in rows]\r\n\r\n        except Exception as e:\r\n            logging.error(f\"Error obteniendo historial: {e}\")\r\n            return []\r\n\r\n    def add_tags(self, command_id: int, tags: List[str]):\r\n        \"\"\"Añade tags a un comando existente.\"\"\"\r\n        try:\r\n            with sqlite3.connect(self.db_path) as conn:\r\n                cursor = conn.cursor()\r\n                cursor.executemany(\r\n                    'INSERT OR IGNORE INTO command_tags (command_id, tag) VALUES (?, ?)',\r\n                    [(command_id, tag) for tag in tags]\r\n                )\r\n                conn.commit()\r\n        except Exception as e:\r\n            logging.error(f\"Error añadiendo tags: {e}\")\r\n            raise\r\n\r\n    def search_commands(self, query: str) -> List[Dict]:\r\n        \"\"\"Busca comandos por texto.\"\"\"\r\n        try:\r\n            with sqlite3.connect(self.db_path) as conn:\r\n                conn.row_factory = sqlite3.Row\r\n                cursor = conn.cursor()\r\n                \r\n                cursor.execute('''\r\n                SELECT DISTINCT h.*, GROUP_CONCAT(t.tag) as tags\r\n                FROM command_history h\r\n                LEFT JOIN command_tags t ON h.id = t.command_id\r\n                WHERE h.command LIKE ? OR h.result LIKE ?\r\n                GROUP BY h.id\r\n                ORDER BY h.timestamp DESC\r\n                ''', (f'%{query}%', f'%{query}%'))\r\n                \r\n                rows = cursor.fetchall()\r\n                return [{\r\n                    **dict(row),\r\n                    'arguments': json.loads(row['arguments']) if row['arguments'] else None,\r\n                    'tags': row['tags'].split(',') if row['tags'] else []\r\n                } for row in rows]\r\n\r\n        except Exception as e:\r\n            logging.error(f\"Error buscando comandos: {e}\")\r\n            return []\r\n\r\n    def get_command_stats(self, bot_id: Optional[int] = None) -> Dict:\r\n        \"\"\"Obtiene estadísticas de comandos.\"\"\"\r\n        try:\r\n            with sqlite3.connect(self.db_path) as conn:\r\n                cursor = conn.cursor()\r\n                \r\n                where_clause = \"WHERE bot_id = ?\" if bot_id else \"\"\r\n                params = [bot_id] if bot_id else []\r\n\r\n                cursor.execute(f'''\r\n                SELECT \r\n                    COUNT(*) as total,\r\n                    SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successful,\r\n                    AVG(execution_time) as avg_time,\r\n                    command_type,\r\n                    COUNT(DISTINCT bot_id) as unique_bots\r\n                FROM command_history\r\n                {where_clause}\r\n                GROUP BY command_type\r\n                ''', params)\r\n\r\n                stats = {}\r\n                for row in cursor.fetchall():\r\n                    stats[row[3]] = {\r\n                        'total': row[0],\r\n                        'successful': row[1],\r\n                        'avg_execution_time': row[2],\r\n                        'unique_bots': row[4]\r\n                    }\r\n\r\n                return stats\r\n\r\n        except Exception as e:\r\n            logging.error(f\"Error obteniendo estadísticas: {e}\")\r\n            return {}\r\n"
        }
    ]
}