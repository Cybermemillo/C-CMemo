{
    "sourceFile": "src/modules/dynamic_loader.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1740263422427,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1740263422427,
            "name": "Commit-0",
            "content": "\"\"\"\r\nMódulo de carga dinámica.\r\nPermite cargar y gestionar plugins y módulos adicionales en tiempo de ejecución.\r\n\"\"\"\r\n\r\nimport sys\r\nimport os\r\nimport hashlib\r\nimport base64\r\nimport logging\r\nimport importlib.util\r\nimport inspect\r\nfrom typing import Dict, Any, List, Callable, Optional\r\nfrom dataclasses import dataclass\r\nimport json\r\n\r\n@dataclass\r\nclass PluginInfo:\r\n    \"\"\"Información sobre un plugin cargado.\"\"\"\r\n    name: str\r\n    version: str\r\n    description: str\r\n    author: str\r\n    dependencies: List[str]\r\n    hooks: List[str]\r\n    module: Any\r\n    hash: str\r\n\r\nclass DynamicLoader:\r\n    def __init__(self):\r\n        \"\"\"Inicializa el cargador dinámico.\"\"\"\r\n        self.plugins: Dict[str, PluginInfo] = {}\r\n        self.hooks: Dict[str, List[Callable]] = {}\r\n        self._setup_hooks()\r\n\r\n    def _setup_hooks(self):\r\n        \"\"\"Configura los hooks básicos del sistema.\"\"\"\r\n        self.hooks = {\r\n            'pre_command': [],    # Antes de ejecutar un comando\r\n            'post_command': [],   # Después de ejecutar un comando\r\n            'on_load': [],        # Al cargar un plugin\r\n            'on_unload': [],      # Al descargar un plugin\r\n            'on_network': [],     # Eventos de red\r\n            'on_file': [],        # Operaciones con archivos\r\n            'on_process': [],     # Eventos de procesos\r\n            'on_registry': []     # Modificaciones del registro\r\n        }\r\n\r\n    def load_plugin_from_memory(self, plugin_code: str, plugin_name: str) -> bool:\r\n        \"\"\"\r\n        Carga un plugin desde código en memoria.\r\n        \r\n        Args:\r\n            plugin_code: Código fuente del plugin en base64\r\n            plugin_name: Nombre para el plugin\r\n            \r\n        Returns:\r\n            bool: True si se cargó correctamente\r\n        \"\"\"\r\n        try:\r\n            # Decodificar código\r\n            code = base64.b64decode(plugin_code).decode('utf-8')\r\n            \r\n            # Crear módulo temporal\r\n            spec = importlib.util.spec_from_loader(plugin_name, loader=None)\r\n            module = importlib.util.module_from_spec(spec)\r\n            \r\n            # Ejecutar código\r\n            exec(code, module.__dict__)\r\n            \r\n            # Verificar interfaz requerida\r\n            if not hasattr(module, 'PLUGIN_INFO'):\r\n                raise ValueError(\"El plugin no proporciona información básica (PLUGIN_INFO)\")\r\n                \r\n            # Calcular hash del código\r\n            code_hash = hashlib.sha256(code.encode()).hexdigest()\r\n            \r\n            # Registrar plugin\r\n            info = PluginInfo(\r\n                name=module.PLUGIN_INFO['name'],\r\n                version=module.PLUGIN_INFO['version'],\r\n                description=module.PLUGIN_INFO['description'],\r\n                author=module.PLUGIN_INFO['author'],\r\n                dependencies=module.PLUGIN_INFO.get('dependencies', []),\r\n                hooks=module.PLUGIN_INFO.get('hooks', []),\r\n                module=module,\r\n                hash=code_hash\r\n            )\r\n            \r\n            # Verificar dependencias\r\n            self._check_dependencies(info.dependencies)\r\n            \r\n            # Registrar hooks\r\n            self._register_hooks(info)\r\n            \r\n            # Almacenar plugin\r\n            self.plugins[plugin_name] = info\r\n            \r\n            # Ejecutar hook de carga\r\n            for hook in self.hooks['on_load']:\r\n                hook(plugin_name)\r\n                \r\n            logging.info(f\"Plugin {plugin_name} cargado correctamente\")\r\n            return True\r\n            \r\n        except Exception as e:\r\n            logging.error(f\"Error cargando plugin {plugin_name}: {e}\")\r\n            return False\r\n\r\n    def unload_plugin(self, plugin_name: str) -> bool:\r\n        \"\"\"\r\n        Descarga un plugin.\r\n        \r\n        Args:\r\n            plugin_name: Nombre del plugin a descargar\r\n            \r\n        Returns:\r\n            bool: True si se descargó correctamente\r\n        \"\"\"\r\n        try:\r\n            if plugin_name not in self.plugins:\r\n                return False\r\n                \r\n            # Ejecutar hook de descarga\r\n            for hook in self.hooks['on_unload']:\r\n                hook(plugin_name)\r\n                \r\n            # Eliminar hooks del plugin\r\n            plugin = self.plugins[plugin_name]\r\n            for hook_name in plugin.hooks:\r\n                if hook_name in self.hooks:\r\n                    self.hooks[hook_name] = [h for h in self.hooks[hook_name] \r\n                                           if not hasattr(h, '__module__') or \r\n                                           h.__module__ != plugin.module.__name__]\r\n                    \r\n            # Eliminar referencias\r\n            del self.plugins[plugin_name]\r\n            del sys.modules[plugin_name]\r\n            \r\n            logging.info(f\"Plugin {plugin_name} descargado correctamente\")\r\n            return True\r\n            \r\n        except Exception as e:\r\n            logging.error(f\"Error descargando plugin {plugin_name}: {e}\")\r\n            return False\r\n\r\n    def _check_dependencies(self, dependencies: List[str]):\r\n        \"\"\"Verifica que las dependencias estén instaladas.\"\"\"\r\n        missing = []\r\n        for dep in dependencies:\r\n            try:\r\n                importlib.import_module(dep)\r\n            except ImportError:\r\n                missing.append(dep)\r\n        \r\n        if missing:\r\n            raise ImportError(f\"Dependencias faltantes: {', '.join(missing)}\")\r\n\r\n    def _register_hooks(self, plugin_info: PluginInfo):\r\n        \"\"\"Registra los hooks del plugin.\"\"\"\r\n        for hook_name in plugin_info.hooks:\r\n            if not hasattr(plugin_info.module, hook_name):\r\n                continue\r\n                \r\n            if hook_name not in self.hooks:\r\n                self.hooks[hook_name] = []\r\n                \r\n            hook_func = getattr(plugin_info.module, hook_name)\r\n            self.hooks[hook_name].append(hook_func)\r\n\r\n    def call_hook(self, hook_name: str, *args, **kwargs) -> List[Any]:\r\n        \"\"\"\r\n        Ejecuta todos los hooks registrados para un evento.\r\n        \r\n        Args:\r\n            hook_name: Nombre del hook a ejecutar\r\n            *args: Argumentos posicionales\r\n            **kwargs: Argumentos nombrados\r\n            \r\n        Returns:\r\n            Lista con los resultados de cada hook\r\n        \"\"\"\r\n        results = []\r\n        if hook_name in self.hooks:\r\n            for hook in self.hooks[hook_name]:\r\n                try:\r\n                    result = hook(*args, **kwargs)\r\n                    results.append(result)\r\n                except Exception as e:\r\n                    logging.error(f\"Error ejecutando hook {hook_name}: {e}\")\r\n        return results\r\n\r\n    def get_plugin_info(self, plugin_name: str = None) -> Dict[str, Any]:\r\n        \"\"\"\r\n        Obtiene información sobre los plugins cargados.\r\n        \r\n        Args:\r\n            plugin_name: Nombre del plugin específico o None para todos\r\n            \r\n        Returns:\r\n            Dict con información de los plugins\r\n        \"\"\"\r\n        if plugin_name:\r\n            if plugin_name not in self.plugins:\r\n                return {}\r\n            plugin = self.plugins[plugin_name]\r\n            return {\r\n                'name': plugin.name,\r\n                'version': plugin.version,\r\n                'description': plugin.description,\r\n                'author': plugin.author,\r\n                'dependencies': plugin.dependencies,\r\n                'hooks': plugin.hooks,\r\n                'hash': plugin.hash\r\n            }\r\n        \r\n        return {\r\n            name: {\r\n                'name': p.name,\r\n                'version': p.version,\r\n                'description': p.description,\r\n                'author': p.author,\r\n                'dependencies': p.dependencies,\r\n                'hooks': p.hooks,\r\n                'hash': p.hash\r\n            }\r\n            for name, p in self.plugins.items()\r\n        }\r\n\r\n    def validate_plugin(self, plugin_code: str, expected_hash: str = None) -> bool:\r\n        \"\"\"\r\n        Valida un plugin antes de cargarlo.\r\n        \r\n        Args:\r\n            plugin_code: Código del plugin en base64\r\n            expected_hash: Hash esperado para validación\r\n            \r\n        Returns:\r\n            bool: True si el plugin es válido\r\n        \"\"\"\r\n        try:\r\n            # Decodificar y validar sintaxis\r\n            code = base64.b64decode(plugin_code).decode('utf-8')\r\n            compile(code, '<string>', 'exec')\r\n            \r\n            # Verificar hash si se proporciona\r\n            if expected_hash:\r\n                actual_hash = hashlib.sha256(code.encode()).hexdigest()\r\n                if actual_hash != expected_hash:\r\n                    return False\r\n                    \r\n            return True\r\n        except Exception as e:\r\n            logging.error(f\"Error validando plugin: {e}\")\r\n            return False\r\n"
        }
    ]
}