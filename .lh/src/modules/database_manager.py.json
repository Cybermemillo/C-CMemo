{
    "sourceFile": "src/modules/database_manager.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1740264626486,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740264854108,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,249 @@\n+\"\"\"\r\n+Módulo de gestión de base de datos usando SQLite3.\r\n+\"\"\"\r\n+\r\n+import sqlite3\r\n+import logging\r\n+import os\r\n+import json\r\n+from datetime import datetime\r\n+from typing import Dict, List, Optional, Union, Any\r\n+\r\n+class DatabaseManager:\r\n+    def __init__(self, db_path: str):\r\n+        self.db_path = db_path\r\n+        self._ensure_db_directory()\r\n+        self._init_database()\r\n+\r\n+    def _ensure_db_directory(self):\r\n+            db_path: Ruta al archivo de base de datos\r\n+        \"\"\"\r\n+        self.db_path = db_path\r\n+        self._ensure_db_directory()\r\n+        self._init_database()\r\n+\r\n+    def _ensure_db_directory(self):\r\n+        \"\"\"Asegura que el directorio de la base de datos exista.\"\"\"\r\n+        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)\r\n+\r\n+    def _init_database(self):\r\n+        \"\"\"Inicializa las tablas de la base de datos.\"\"\"\r\n+        try:\r\n+            with sqlite3.connect(self.db_path) as conn:\r\n+                cursor = conn.cursor()\r\n+                \r\n+                # Tabla de bots\r\n+                cursor.execute('''\r\n+                CREATE TABLE IF NOT EXISTS bots (\r\n+                    id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n+                    unique_id TEXT UNIQUE,\r\n+                    ip_address TEXT,\r\n+                    system_os TEXT,\r\n+                    hostname TEXT,\r\n+                    first_seen TIMESTAMP,\r\n+                    last_seen TIMESTAMP,\r\n+                    is_active BOOLEAN DEFAULT 1,\r\n+                    additional_info TEXT\r\n+                )''')\r\n+\r\n+                # Tabla de respuestas\r\n+                cursor.execute('''\r\n+                CREATE TABLE IF NOT EXISTS responses (\r\n+                    id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n+                    bot_id INTEGER,\r\n+                    command TEXT,\r\n+                    response TEXT,\r\n+                    timestamp TIMESTAMP,\r\n+                    success BOOLEAN,\r\n+                    error_message TEXT,\r\n+                    FOREIGN KEY (bot_id) REFERENCES bots(id)\r\n+                )''')\r\n+\r\n+                # Tabla de comandos pendientes\r\n+                cursor.execute('''\r\n+                CREATE TABLE IF NOT EXISTS pending_commands (\r\n+                    id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n+                    bot_id INTEGER,\r\n+                    command TEXT,\r\n+                    timestamp TIMESTAMP,\r\n+                    executed BOOLEAN DEFAULT 0,\r\n+                    FOREIGN KEY (bot_id) REFERENCES bots(id)\r\n+                )''')\r\n+\r\n+                conn.commit()\r\n+        except Exception as e:\r\n+            logging.error(f\"Error inicializando base de datos: {e}\")\r\n+            raise\r\n+\r\n+    def register_bot(self, unique_id: str, ip_address: str, system_os: str, hostname: str, additional_info: Dict = None) -> int:\r\n+        \"\"\"\r\n+        Registra un nuevo bot o actualiza uno existente.\r\n+        \r\n+        Returns:\r\n+            ID del bot en la base de datos\r\n+        \"\"\"\r\n+        try:\r\n+            with sqlite3.connect(self.db_path) as conn:\r\n+                cursor = conn.cursor()\r\n+                now = datetime.now()\r\n+\r\n+                # Verificar si el bot ya existe\r\n+                cursor.execute(\"SELECT id FROM bots WHERE unique_id = ?\", (unique_id,))\r\n+                result = cursor.fetchone()\r\n+\r\n+                if result:\r\n+                    # Actualizar bot existente\r\n+                    bot_id = result[0]\r\n+                    cursor.execute('''\r\n+                    UPDATE bots \r\n+                    SET ip_address = ?, system_os = ?, hostname = ?, \r\n+                        last_seen = ?, is_active = 1, additional_info = ?\r\n+                    WHERE id = ?\r\n+                    ''', (ip_address, system_os, hostname, now, \r\n+                         json.dumps(additional_info) if additional_info else None, \r\n+                         bot_id))\r\n+                else:\r\n+                    # Insertar nuevo bot\r\n+                    cursor.execute('''\r\n+                    INSERT INTO bots (unique_id, ip_address, system_os, hostname, \r\n+                                    first_seen, last_seen, additional_info)\r\n+                    VALUES (?, ?, ?, ?, ?, ?, ?)\r\n+                    ''', (unique_id, ip_address, system_os, hostname, now, now,\r\n+                         json.dumps(additional_info) if additional_info else None))\r\n+                    bot_id = cursor.lastrowid\r\n+\r\n+                conn.commit()\r\n+                return bot_id\r\n+\r\n+        except Exception as e:\r\n+            logging.error(f\"Error registrando bot: {e}\")\r\n+            raise\r\n+\r\n+    def store_response(self, bot_id: int, command: str, response: str, success: bool = True, error_message: str = None):\r\n+        \"\"\"Almacena la respuesta de un bot a un comando.\"\"\"\r\n+        try:\r\n+            with sqlite3.connect(self.db_path) as conn:\r\n+                cursor = conn.cursor()\r\n+                cursor.execute('''\r\n+                INSERT INTO responses (bot_id, command, response, timestamp, success, error_message)\r\n+                VALUES (?, ?, ?, ?, ?, ?)\r\n+                ''', (bot_id, command, response, datetime.now(), success, error_message))\r\n+                conn.commit()\r\n+        except Exception as e:\r\n+            logging.error(f\"Error almacenando respuesta: {e}\")\r\n+            raise\r\n+\r\n+    def get_bot_info(self, bot_id: int) -> Optional[Dict[str, Any]]:\r\n+        \"\"\"Obtiene información detallada de un bot.\"\"\"\r\n+        try:\r\n+            with sqlite3.connect(self.db_path) as conn:\r\n+                conn.row_factory = sqlite3.Row\r\n+                cursor = conn.cursor()\r\n+                cursor.execute('''\r\n+                SELECT * FROM bots WHERE id = ?\r\n+                ''', (bot_id,))\r\n+                row = cursor.fetchone()\r\n+                \r\n+                if row:\r\n+                    bot_info = dict(row)\r\n+                    if bot_info['additional_info']:\r\n+                        bot_info['additional_info'] = json.loads(bot_info['additional_info'])\r\n+                    return bot_info\r\n+                return None\r\n+        except Exception as e:\r\n+            logging.error(f\"Error obteniendo información del bot: {e}\")\r\n+            return None\r\n+\r\n+    def get_bot_responses(self, bot_id: int, limit: int = 100) -> List[Dict[str, Any]]:\r\n+        \"\"\"Obtiene las últimas respuestas de un bot.\"\"\"\r\n+        try:\r\n+            with sqlite3.connect(self.db_path) as conn:\r\n+                conn.row_factory = sqlite3.Row\r\n+                cursor = conn.cursor()\r\n+                cursor.execute('''\r\n+                SELECT * FROM responses \r\n+                WHERE bot_id = ? \r\n+                ORDER BY timestamp DESC \r\n+                LIMIT ?\r\n+                ''', (bot_id, limit))\r\n+                return [dict(row) for row in cursor.fetchall()]\r\n+        except Exception as e:\r\n+            logging.error(f\"Error obteniendo respuestas del bot: {e}\")\r\n+            return []\r\n+\r\n+    def get_active_bots(self) -> List[Dict[str, Any]]:\r\n+        \"\"\"Obtiene lista de todos los bots activos.\"\"\"\r\n+        try:\r\n+            with sqlite3.connect(self.db_path) as conn:\r\n+                conn.row_factory = sqlite3.Row\r\n+                cursor = conn.cursor()\r\n+                cursor.execute('''\r\n+                SELECT * FROM bots \r\n+                WHERE is_active = 1\r\n+                ORDER BY last_seen DESC\r\n+                ''')\r\n+                return [dict(row) for row in cursor.fetchall()]\r\n+        except Exception as e:\r\n+            logging.error(f\"Error obteniendo bots activos: {e}\")\r\n+            return []\r\n+\r\n+    def mark_bot_inactive(self, bot_id: int):\r\n+        \"\"\"Marca un bot como inactivo.\"\"\"\r\n+        try:\r\n+            with sqlite3.connect(self.db_path) as conn:\r\n+                cursor = conn.cursor()\r\n+                cursor.execute('''\r\n+                UPDATE bots \r\n+                SET is_active = 0 \r\n+                WHERE id = ?\r\n+                ''', (bot_id,))\r\n+                conn.commit()\r\n+        except Exception as e:\r\n+            logging.error(f\"Error marcando bot como inactivo: {e}\")\r\n+            raise\r\n+\r\n+    def add_pending_command(self, bot_id: int, command: str) -> int:\r\n+        \"\"\"Añade un comando pendiente para un bot.\"\"\"\r\n+        try:\r\n+            with sqlite3.connect(self.db_path) as conn:\r\n+                cursor = conn.cursor()\r\n+                cursor.execute('''\r\n+                INSERT INTO pending_commands (bot_id, command, timestamp)\r\n+                VALUES (?, ?, ?)\r\n+                ''', (bot_id, command, datetime.now()))\r\n+                conn.commit()\r\n+                return cursor.lastrowid\r\n+        except Exception as e:\r\n+            logging.error(f\"Error añadiendo comando pendiente: {e}\")\r\n+            raise\r\n+\r\n+    def get_pending_commands(self, bot_id: int) -> List[Dict[str, Any]]:\r\n+        \"\"\"Obtiene los comandos pendientes para un bot.\"\"\"\r\n+        try:\r\n+            with sqlite3.connect(self.db_path) as conn:\r\n+                conn.row_factory = sqlite3.Row\r\n+                cursor = conn.cursor()\r\n+                cursor.execute('''\r\n+                SELECT * FROM pending_commands \r\n+                WHERE bot_id = ? AND executed = 0 \r\n+                ORDER BY timestamp\r\n+                ''', (bot_id,))\r\n+                return [dict(row) for row in cursor.fetchall()]\r\n+        except Exception as e:\r\n+            logging.error(f\"Error obteniendo comandos pendientes: {e}\")\r\n+            return []\r\n+\r\n+    def mark_command_executed(self, command_id: int):\r\n+        \"\"\"Marca un comando como ejecutado.\"\"\"\r\n+        try:\r\n+            with sqlite3.connect(self.db_path) as conn:\r\n+                cursor = conn.cursor()\r\n+                cursor.execute('''\r\n+                UPDATE pending_commands \r\n+                SET executed = 1 \r\n+                WHERE id = ?\r\n+                ''', (command_id,))\r\n+                conn.commit()\r\n+        except Exception as e:\r\n+            logging.error(f\"Error marcando comando como ejecutado: {e}\")\r\n+            raise\r\n"
                },
                {
                    "date": 1740264867116,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,249 @@\n+\"\"\"\r\n+Módulo de gestión de base de datos usando SQLite3.\r\n+\"\"\"\r\n+\r\n+import sqlite3\r\n+import logging\r\n+import os\r\n+import json\r\n+from datetime import datetime\r\n+from typing import Dict, List, Optional, Union, Any\r\n+\r\n+class DatabaseManager:\r\n+    def __init__(self, db_path: str):\r\n+        self.db_path = db_path\r\n+        self._ensure_db_directory()\r\n+        self._init_database()\r\n+\r\n+    def _ensure_db_directory(self):\r\n+        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)\r\n+\r\n+    def _init_database(self):\r\n+        try:\r\n+            with sqlite3.connect(self.db_path) as conn:\r\n+                cursor = conn.cursor()\r\n+\r\n+                # Tabla principal de bots\r\n+                cursor.execute('''\r\n+                CREATE TABLE IF NOT EXISTS bots (\r\n+                    id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n+                    unique_id TEXT UNIQUE,\r\n+                    ip_address TEXT,\r\n+                    system_info TEXT,\r\n+                    first_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n+                    last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n+                    is_active BOOLEAN DEFAULT 1,\r\n+                    metadata TEXT\r\n+                )''')\r\n+\r\n+                # Tabla de comandos y respuestas\r\n+                cursor.execute('''\r\n+                CREATE TABLE IF NOT EXISTS commands (\r\n+                    id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n+                    bot_id INTEGER,\r\n+                    command TEXT,\r\n+                    response TEXT,\r\n+                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n+                    success BOOLEAN,\r\n+                    FOREIGN KEY (bot_id) REFERENCES bots(id)\r\n+                )''')\r\n+                cursor.execute('''\r\n+                CREATE TABLE IF NOT EXISTS responses (\r\n+                    id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n+                    bot_id INTEGER,\r\n+                    command TEXT,\r\n+                    response TEXT,\r\n+                    timestamp TIMESTAMP,\r\n+                    success BOOLEAN,\r\n+                    error_message TEXT,\r\n+                    FOREIGN KEY (bot_id) REFERENCES bots(id)\r\n+                )''')\r\n+\r\n+                # Tabla de comandos pendientes\r\n+                cursor.execute('''\r\n+                CREATE TABLE IF NOT EXISTS pending_commands (\r\n+                    id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n+                    bot_id INTEGER,\r\n+                    command TEXT,\r\n+                    timestamp TIMESTAMP,\r\n+                    executed BOOLEAN DEFAULT 0,\r\n+                    FOREIGN KEY (bot_id) REFERENCES bots(id)\r\n+                )''')\r\n+\r\n+                conn.commit()\r\n+        except Exception as e:\r\n+            logging.error(f\"Error inicializando base de datos: {e}\")\r\n+            raise\r\n+\r\n+    def register_bot(self, unique_id: str, ip_address: str, system_os: str, hostname: str, additional_info: Dict = None) -> int:\r\n+        \"\"\"\r\n+        Registra un nuevo bot o actualiza uno existente.\r\n+        \r\n+        Returns:\r\n+            ID del bot en la base de datos\r\n+        \"\"\"\r\n+        try:\r\n+            with sqlite3.connect(self.db_path) as conn:\r\n+                cursor = conn.cursor()\r\n+                now = datetime.now()\r\n+\r\n+                # Verificar si el bot ya existe\r\n+                cursor.execute(\"SELECT id FROM bots WHERE unique_id = ?\", (unique_id,))\r\n+                result = cursor.fetchone()\r\n+\r\n+                if result:\r\n+                    # Actualizar bot existente\r\n+                    bot_id = result[0]\r\n+                    cursor.execute('''\r\n+                    UPDATE bots \r\n+                    SET ip_address = ?, system_os = ?, hostname = ?, \r\n+                        last_seen = ?, is_active = 1, additional_info = ?\r\n+                    WHERE id = ?\r\n+                    ''', (ip_address, system_os, hostname, now, \r\n+                         json.dumps(additional_info) if additional_info else None, \r\n+                         bot_id))\r\n+                else:\r\n+                    # Insertar nuevo bot\r\n+                    cursor.execute('''\r\n+                    INSERT INTO bots (unique_id, ip_address, system_os, hostname, \r\n+                                    first_seen, last_seen, additional_info)\r\n+                    VALUES (?, ?, ?, ?, ?, ?, ?)\r\n+                    ''', (unique_id, ip_address, system_os, hostname, now, now,\r\n+                         json.dumps(additional_info) if additional_info else None))\r\n+                    bot_id = cursor.lastrowid\r\n+\r\n+                conn.commit()\r\n+                return bot_id\r\n+\r\n+        except Exception as e:\r\n+            logging.error(f\"Error registrando bot: {e}\")\r\n+            raise\r\n+\r\n+    def store_response(self, bot_id: int, command: str, response: str, success: bool = True, error_message: str = None):\r\n+        \"\"\"Almacena la respuesta de un bot a un comando.\"\"\"\r\n+        try:\r\n+            with sqlite3.connect(self.db_path) as conn:\r\n+                cursor = conn.cursor()\r\n+                cursor.execute('''\r\n+                INSERT INTO responses (bot_id, command, response, timestamp, success, error_message)\r\n+                VALUES (?, ?, ?, ?, ?, ?)\r\n+                ''', (bot_id, command, response, datetime.now(), success, error_message))\r\n+                conn.commit()\r\n+        except Exception as e:\r\n+            logging.error(f\"Error almacenando respuesta: {e}\")\r\n+            raise\r\n+\r\n+    def get_bot_info(self, bot_id: int) -> Optional[Dict[str, Any]]:\r\n+        \"\"\"Obtiene información detallada de un bot.\"\"\"\r\n+        try:\r\n+            with sqlite3.connect(self.db_path) as conn:\r\n+                conn.row_factory = sqlite3.Row\r\n+                cursor = conn.cursor()\r\n+                cursor.execute('''\r\n+                SELECT * FROM bots WHERE id = ?\r\n+                ''', (bot_id,))\r\n+                row = cursor.fetchone()\r\n+                \r\n+                if row:\r\n+                    bot_info = dict(row)\r\n+                    if bot_info['additional_info']:\r\n+                        bot_info['additional_info'] = json.loads(bot_info['additional_info'])\r\n+                    return bot_info\r\n+                return None\r\n+        except Exception as e:\r\n+            logging.error(f\"Error obteniendo información del bot: {e}\")\r\n+            return None\r\n+\r\n+    def get_bot_responses(self, bot_id: int, limit: int = 100) -> List[Dict[str, Any]]:\r\n+        \"\"\"Obtiene las últimas respuestas de un bot.\"\"\"\r\n+        try:\r\n+            with sqlite3.connect(self.db_path) as conn:\r\n+                conn.row_factory = sqlite3.Row\r\n+                cursor = conn.cursor()\r\n+                cursor.execute('''\r\n+                SELECT * FROM responses \r\n+                WHERE bot_id = ? \r\n+                ORDER BY timestamp DESC \r\n+                LIMIT ?\r\n+                ''', (bot_id, limit))\r\n+                return [dict(row) for row in cursor.fetchall()]\r\n+        except Exception as e:\r\n+            logging.error(f\"Error obteniendo respuestas del bot: {e}\")\r\n+            return []\r\n+\r\n+    def get_active_bots(self) -> List[Dict[str, Any]]:\r\n+        \"\"\"Obtiene lista de todos los bots activos.\"\"\"\r\n+        try:\r\n+            with sqlite3.connect(self.db_path) as conn:\r\n+                conn.row_factory = sqlite3.Row\r\n+                cursor = conn.cursor()\r\n+                cursor.execute('''\r\n+                SELECT * FROM bots \r\n+                WHERE is_active = 1\r\n+                ORDER BY last_seen DESC\r\n+                ''')\r\n+                return [dict(row) for row in cursor.fetchall()]\r\n+        except Exception as e:\r\n+            logging.error(f\"Error obteniendo bots activos: {e}\")\r\n+            return []\r\n+\r\n+    def mark_bot_inactive(self, bot_id: int):\r\n+        \"\"\"Marca un bot como inactivo.\"\"\"\r\n+        try:\r\n+            with sqlite3.connect(self.db_path) as conn:\r\n+                cursor = conn.cursor()\r\n+                cursor.execute('''\r\n+                UPDATE bots \r\n+                SET is_active = 0 \r\n+                WHERE id = ?\r\n+                ''', (bot_id,))\r\n+                conn.commit()\r\n+        except Exception as e:\r\n+            logging.error(f\"Error marcando bot como inactivo: {e}\")\r\n+            raise\r\n+\r\n+    def add_pending_command(self, bot_id: int, command: str) -> int:\r\n+        \"\"\"Añade un comando pendiente para un bot.\"\"\"\r\n+        try:\r\n+            with sqlite3.connect(self.db_path) as conn:\r\n+                cursor = conn.cursor()\r\n+                cursor.execute('''\r\n+                INSERT INTO pending_commands (bot_id, command, timestamp)\r\n+                VALUES (?, ?, ?)\r\n+                ''', (bot_id, command, datetime.now()))\r\n+                conn.commit()\r\n+                return cursor.lastrowid\r\n+        except Exception as e:\r\n+            logging.error(f\"Error añadiendo comando pendiente: {e}\")\r\n+            raise\r\n+\r\n+    def get_pending_commands(self, bot_id: int) -> List[Dict[str, Any]]:\r\n+        \"\"\"Obtiene los comandos pendientes para un bot.\"\"\"\r\n+        try:\r\n+            with sqlite3.connect(self.db_path) as conn:\r\n+                conn.row_factory = sqlite3.Row\r\n+                cursor = conn.cursor()\r\n+                cursor.execute('''\r\n+                SELECT * FROM pending_commands \r\n+                WHERE bot_id = ? AND executed = 0 \r\n+                ORDER BY timestamp\r\n+                ''', (bot_id,))\r\n+                return [dict(row) for row in cursor.fetchall()]\r\n+        except Exception as e:\r\n+            logging.error(f\"Error obteniendo comandos pendientes: {e}\")\r\n+            return []\r\n+\r\n+    def mark_command_executed(self, command_id: int):\r\n+        \"\"\"Marca un comando como ejecutado.\"\"\"\r\n+        try:\r\n+            with sqlite3.connect(self.db_path) as conn:\r\n+                cursor = conn.cursor()\r\n+                cursor.execute('''\r\n+                UPDATE pending_commands \r\n+                SET executed = 1 \r\n+                WHERE id = ?\r\n+                ''', (command_id,))\r\n+                conn.commit()\r\n+        except Exception as e:\r\n+            logging.error(f\"Error marcando comando como ejecutado: {e}\")\r\n+            raise\r\n"
                },
                {
                    "date": 1740264889680,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -170,11 +170,11 @@\n                 VALUES (?, ?, ?)\r\n                 ''', (bot_id, stat_type, json.dumps(value)))\r\n                 conn.commit()\r\n         except Exception as e:\r\n-    def get_active_bots(self) -> List[Dict[str, Any]]:\r\n-        \"\"\"Obtiene lista de todos los bots activos.\"\"\"\r\n-        try:\r\n+            logging.error(f\"Error añadiendo estadística: {e}\")\r\n+            raise\r\n+\r\n             with sqlite3.connect(self.db_path) as conn:\r\n                 conn.row_factory = sqlite3.Row\r\n                 cursor = conn.cursor()\r\n                 cursor.execute('''\r\n"
                },
                {
                    "date": 1740264903142,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -170,80 +170,6 @@\n                 VALUES (?, ?, ?)\r\n                 ''', (bot_id, stat_type, json.dumps(value)))\r\n                 conn.commit()\r\n         except Exception as e:\r\n-    def get_active_bots(self) -> List[Dict[str, Any]]:\r\n-        \"\"\"Obtiene lista de todos los bots activos.\"\"\"\r\n-        try:\r\n-            with sqlite3.connect(self.db_path) as conn:\r\n-                conn.row_factory = sqlite3.Row\r\n-                cursor = conn.cursor()\r\n-                cursor.execute('''\r\n-                SELECT * FROM bots \r\n-                WHERE is_active = 1\r\n-                ORDER BY last_seen DESC\r\n-                ''')\r\n-                return [dict(row) for row in cursor.fetchall()]\r\n-        except Exception as e:\r\n-            logging.error(f\"Error obteniendo bots activos: {e}\")\r\n-            return []\r\n-\r\n-    def mark_bot_inactive(self, bot_id: int):\r\n-        \"\"\"Marca un bot como inactivo.\"\"\"\r\n-        try:\r\n-            with sqlite3.connect(self.db_path) as conn:\r\n-                cursor = conn.cursor()\r\n-                cursor.execute('''\r\n-                UPDATE bots \r\n-                SET is_active = 0 \r\n-                WHERE id = ?\r\n-                ''', (bot_id,))\r\n-                conn.commit()\r\n-        except Exception as e:\r\n-            logging.error(f\"Error marcando bot como inactivo: {e}\")\r\n+            logging.error(f\"Error añadiendo estadística: {e}\")\r\n             raise\r\n-\r\n-    def add_pending_command(self, bot_id: int, command: str) -> int:\r\n-        \"\"\"Añade un comando pendiente para un bot.\"\"\"\r\n-        try:\r\n-            with sqlite3.connect(self.db_path) as conn:\r\n-                cursor = conn.cursor()\r\n-                cursor.execute('''\r\n-                INSERT INTO pending_commands (bot_id, command, timestamp)\r\n-                VALUES (?, ?, ?)\r\n-                ''', (bot_id, command, datetime.now()))\r\n-                conn.commit()\r\n-                return cursor.lastrowid\r\n-        except Exception as e:\r\n-            logging.error(f\"Error añadiendo comando pendiente: {e}\")\r\n-            raise\r\n-\r\n-    def get_pending_commands(self, bot_id: int) -> List[Dict[str, Any]]:\r\n-        \"\"\"Obtiene los comandos pendientes para un bot.\"\"\"\r\n-        try:\r\n-            with sqlite3.connect(self.db_path) as conn:\r\n-                conn.row_factory = sqlite3.Row\r\n-                cursor = conn.cursor()\r\n-                cursor.execute('''\r\n-                SELECT * FROM pending_commands \r\n-                WHERE bot_id = ? AND executed = 0 \r\n-                ORDER BY timestamp\r\n-                ''', (bot_id,))\r\n-                return [dict(row) for row in cursor.fetchall()]\r\n-        except Exception as e:\r\n-            logging.error(f\"Error obteniendo comandos pendientes: {e}\")\r\n-            return []\r\n-\r\n-    def mark_command_executed(self, command_id: int):\r\n-        \"\"\"Marca un comando como ejecutado.\"\"\"\r\n-        try:\r\n-            with sqlite3.connect(self.db_path) as conn:\r\n-                cursor = conn.cursor()\r\n-                cursor.execute('''\r\n-                UPDATE pending_commands \r\n-                SET executed = 1 \r\n-                WHERE id = ?\r\n-                ''', (command_id,))\r\n-                conn.commit()\r\n-        except Exception as e:\r\n-            logging.error(f\"Error marcando comando como ejecutado: {e}\")\r\n-            raise\r\n"
                }
            ],
            "date": 1740264626486,
            "name": "Commit-0",
            "content": "\"\"\"\r\nMódulo de gestión de base de datos.\r\nManeja la persistencia de datos de los bots y sus respuestas.\r\n\"\"\"\r\n\r\nimport sqlite3\r\nimport logging\r\nimport os\r\nimport json\r\nfrom datetime import datetime\r\nfrom typing import Dict, List, Optional, Union, Any\r\n\r\nclass DatabaseManager:\r\n    def __init__(self, db_path: str):\r\n        \"\"\"\r\n        Inicializa el gestor de base de datos.\r\n        \r\n        Args:\r\n            db_path: Ruta al archivo de base de datos\r\n        \"\"\"\r\n        self.db_path = db_path\r\n        self._ensure_db_directory()\r\n        self._init_database()\r\n\r\n    def _ensure_db_directory(self):\r\n        \"\"\"Asegura que el directorio de la base de datos exista.\"\"\"\r\n        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)\r\n\r\n    def _init_database(self):\r\n        \"\"\"Inicializa las tablas de la base de datos.\"\"\"\r\n        try:\r\n            with sqlite3.connect(self.db_path) as conn:\r\n                cursor = conn.cursor()\r\n                \r\n                # Tabla de bots\r\n                cursor.execute('''\r\n                CREATE TABLE IF NOT EXISTS bots (\r\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n                    unique_id TEXT UNIQUE,\r\n                    ip_address TEXT,\r\n                    system_os TEXT,\r\n                    hostname TEXT,\r\n                    first_seen TIMESTAMP,\r\n                    last_seen TIMESTAMP,\r\n                    is_active BOOLEAN DEFAULT 1,\r\n                    additional_info TEXT\r\n                )''')\r\n\r\n                # Tabla de respuestas\r\n                cursor.execute('''\r\n                CREATE TABLE IF NOT EXISTS responses (\r\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n                    bot_id INTEGER,\r\n                    command TEXT,\r\n                    response TEXT,\r\n                    timestamp TIMESTAMP,\r\n                    success BOOLEAN,\r\n                    error_message TEXT,\r\n                    FOREIGN KEY (bot_id) REFERENCES bots(id)\r\n                )''')\r\n\r\n                # Tabla de comandos pendientes\r\n                cursor.execute('''\r\n                CREATE TABLE IF NOT EXISTS pending_commands (\r\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n                    bot_id INTEGER,\r\n                    command TEXT,\r\n                    timestamp TIMESTAMP,\r\n                    executed BOOLEAN DEFAULT 0,\r\n                    FOREIGN KEY (bot_id) REFERENCES bots(id)\r\n                )''')\r\n\r\n                conn.commit()\r\n        except Exception as e:\r\n            logging.error(f\"Error inicializando base de datos: {e}\")\r\n            raise\r\n\r\n    def register_bot(self, unique_id: str, ip_address: str, system_os: str, hostname: str, additional_info: Dict = None) -> int:\r\n        \"\"\"\r\n        Registra un nuevo bot o actualiza uno existente.\r\n        \r\n        Returns:\r\n            ID del bot en la base de datos\r\n        \"\"\"\r\n        try:\r\n            with sqlite3.connect(self.db_path) as conn:\r\n                cursor = conn.cursor()\r\n                now = datetime.now()\r\n\r\n                # Verificar si el bot ya existe\r\n                cursor.execute(\"SELECT id FROM bots WHERE unique_id = ?\", (unique_id,))\r\n                result = cursor.fetchone()\r\n\r\n                if result:\r\n                    # Actualizar bot existente\r\n                    bot_id = result[0]\r\n                    cursor.execute('''\r\n                    UPDATE bots \r\n                    SET ip_address = ?, system_os = ?, hostname = ?, \r\n                        last_seen = ?, is_active = 1, additional_info = ?\r\n                    WHERE id = ?\r\n                    ''', (ip_address, system_os, hostname, now, \r\n                         json.dumps(additional_info) if additional_info else None, \r\n                         bot_id))\r\n                else:\r\n                    # Insertar nuevo bot\r\n                    cursor.execute('''\r\n                    INSERT INTO bots (unique_id, ip_address, system_os, hostname, \r\n                                    first_seen, last_seen, additional_info)\r\n                    VALUES (?, ?, ?, ?, ?, ?, ?)\r\n                    ''', (unique_id, ip_address, system_os, hostname, now, now,\r\n                         json.dumps(additional_info) if additional_info else None))\r\n                    bot_id = cursor.lastrowid\r\n\r\n                conn.commit()\r\n                return bot_id\r\n\r\n        except Exception as e:\r\n            logging.error(f\"Error registrando bot: {e}\")\r\n            raise\r\n\r\n    def store_response(self, bot_id: int, command: str, response: str, success: bool = True, error_message: str = None):\r\n        \"\"\"Almacena la respuesta de un bot a un comando.\"\"\"\r\n        try:\r\n            with sqlite3.connect(self.db_path) as conn:\r\n                cursor = conn.cursor()\r\n                cursor.execute('''\r\n                INSERT INTO responses (bot_id, command, response, timestamp, success, error_message)\r\n                VALUES (?, ?, ?, ?, ?, ?)\r\n                ''', (bot_id, command, response, datetime.now(), success, error_message))\r\n                conn.commit()\r\n        except Exception as e:\r\n            logging.error(f\"Error almacenando respuesta: {e}\")\r\n            raise\r\n\r\n    def get_bot_info(self, bot_id: int) -> Optional[Dict[str, Any]]:\r\n        \"\"\"Obtiene información detallada de un bot.\"\"\"\r\n        try:\r\n            with sqlite3.connect(self.db_path) as conn:\r\n                conn.row_factory = sqlite3.Row\r\n                cursor = conn.cursor()\r\n                cursor.execute('''\r\n                SELECT * FROM bots WHERE id = ?\r\n                ''', (bot_id,))\r\n                row = cursor.fetchone()\r\n                \r\n                if row:\r\n                    bot_info = dict(row)\r\n                    if bot_info['additional_info']:\r\n                        bot_info['additional_info'] = json.loads(bot_info['additional_info'])\r\n                    return bot_info\r\n                return None\r\n        except Exception as e:\r\n            logging.error(f\"Error obteniendo información del bot: {e}\")\r\n            return None\r\n\r\n    def get_bot_responses(self, bot_id: int, limit: int = 100) -> List[Dict[str, Any]]:\r\n        \"\"\"Obtiene las últimas respuestas de un bot.\"\"\"\r\n        try:\r\n            with sqlite3.connect(self.db_path) as conn:\r\n                conn.row_factory = sqlite3.Row\r\n                cursor = conn.cursor()\r\n                cursor.execute('''\r\n                SELECT * FROM responses \r\n                WHERE bot_id = ? \r\n                ORDER BY timestamp DESC \r\n                LIMIT ?\r\n                ''', (bot_id, limit))\r\n                return [dict(row) for row in cursor.fetchall()]\r\n        except Exception as e:\r\n            logging.error(f\"Error obteniendo respuestas del bot: {e}\")\r\n            return []\r\n\r\n    def get_active_bots(self) -> List[Dict[str, Any]]:\r\n        \"\"\"Obtiene lista de todos los bots activos.\"\"\"\r\n        try:\r\n            with sqlite3.connect(self.db_path) as conn:\r\n                conn.row_factory = sqlite3.Row\r\n                cursor = conn.cursor()\r\n                cursor.execute('''\r\n                SELECT * FROM bots \r\n                WHERE is_active = 1\r\n                ORDER BY last_seen DESC\r\n                ''')\r\n                return [dict(row) for row in cursor.fetchall()]\r\n        except Exception as e:\r\n            logging.error(f\"Error obteniendo bots activos: {e}\")\r\n            return []\r\n\r\n    def mark_bot_inactive(self, bot_id: int):\r\n        \"\"\"Marca un bot como inactivo.\"\"\"\r\n        try:\r\n            with sqlite3.connect(self.db_path) as conn:\r\n                cursor = conn.cursor()\r\n                cursor.execute('''\r\n                UPDATE bots \r\n                SET is_active = 0 \r\n                WHERE id = ?\r\n                ''', (bot_id,))\r\n                conn.commit()\r\n        except Exception as e:\r\n            logging.error(f\"Error marcando bot como inactivo: {e}\")\r\n            raise\r\n\r\n    def add_pending_command(self, bot_id: int, command: str) -> int:\r\n        \"\"\"Añade un comando pendiente para un bot.\"\"\"\r\n        try:\r\n            with sqlite3.connect(self.db_path) as conn:\r\n                cursor = conn.cursor()\r\n                cursor.execute('''\r\n                INSERT INTO pending_commands (bot_id, command, timestamp)\r\n                VALUES (?, ?, ?)\r\n                ''', (bot_id, command, datetime.now()))\r\n                conn.commit()\r\n                return cursor.lastrowid\r\n        except Exception as e:\r\n            logging.error(f\"Error añadiendo comando pendiente: {e}\")\r\n            raise\r\n\r\n    def get_pending_commands(self, bot_id: int) -> List[Dict[str, Any]]:\r\n        \"\"\"Obtiene los comandos pendientes para un bot.\"\"\"\r\n        try:\r\n            with sqlite3.connect(self.db_path) as conn:\r\n                conn.row_factory = sqlite3.Row\r\n                cursor = conn.cursor()\r\n                cursor.execute('''\r\n                SELECT * FROM pending_commands \r\n                WHERE bot_id = ? AND executed = 0 \r\n                ORDER BY timestamp\r\n                ''', (bot_id,))\r\n                return [dict(row) for row in cursor.fetchall()]\r\n        except Exception as e:\r\n            logging.error(f\"Error obteniendo comandos pendientes: {e}\")\r\n            return []\r\n\r\n    def mark_command_executed(self, command_id: int):\r\n        \"\"\"Marca un comando como ejecutado.\"\"\"\r\n        try:\r\n            with sqlite3.connect(self.db_path) as conn:\r\n                cursor = conn.cursor()\r\n                cursor.execute('''\r\n                UPDATE pending_commands \r\n                SET executed = 1 \r\n                WHERE id = ?\r\n                ''', (command_id,))\r\n                conn.commit()\r\n        except Exception as e:\r\n            logging.error(f\"Error marcando comando como ejecutado: {e}\")\r\n            raise\r\n"
        }
    ]
}