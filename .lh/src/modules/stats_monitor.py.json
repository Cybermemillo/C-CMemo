{
    "sourceFile": "src/modules/stats_monitor.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1740264758264,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740264764410,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,249 @@\n+\"\"\"\r\n+Módulo de estadísticas y monitoreo.\r\n+Recopila y analiza estadísticas de los bots y el servidor.\r\n+\"\"\"\r\n+\r\n+import psutil\r\n+import time\r\n+import json\r\n+import logging\r\n+from datetime import datetime\r\n+from typing import Dict, List, Optional\r\n+from dataclasses import dataclass\r\n+import threading\r\n+\r\n+@dataclass\r\n+class BotActivity:\r\n+    bot_id: int\r\n+    command: str\r\n+    timestamp: datetime\r\n+    execution_time: float\r\n+    success: bool\r\n+    resource_usage: Dict\r\n+\r\n+class StatsMonitor:\r\n+    def __init__(self, db_manager):\r\n+        \"\"\"Inicializa el monitor de estadísticas.\"\"\"\r\n+        self.db = db_manager\r\n+        self.activities: List[BotActivity] = []\r\n+        self.is_monitoring = False\r\n+        self._monitor_thread = None\r\n+        self.server_stats = {\r\n+            \"start_time\": datetime.now(),\r\n+            \"total_commands\": 0,\r\n+            \"failed_commands\": 0,\r\n+            \"active_bots\": 0,\r\n+            \"peak_bots\": 0,\r\n+            \"data_transferred\": 0\r\n+        }\r\n+\r\n+    def start_monitoring(self):\r\n+        \"\"\"Inicia el monitoreo de estadísticas.\"\"\"\r\n+        self.is_monitoring = True\r\n+        self._monitor_thread = threading.Thread(target=self._monitor_loop, daemon=True)\r\n+        self._monitor_thread.start()\r\n+\r\n+    def stop_monitoring(self):\r\n+        \"\"\"Detiene el monitoreo.\"\"\"\r\n+        self.is_monitoring = False\r\n+        if self._monitor_thread:\r\n+            self._monitor_thread.join(timeout=1.0)\r\n+\r\n+    def _monitor_loop(self):\r\n+        \"\"\"Bucle principal de monitoreo.\"\"\"\r\n+        while self.is_monitoring:\r\n+            try:\r\n+                self._update_server_stats()\r\n+                self._check_anomalies()\r\n+                time.sleep(60)  # Actualizar cada minuto\r\n+            except Exception as e:\r\n+                logging.error(f\"Error en monitoreo: {e}\")\r\n+\r\n+    def _update_server_stats(self):\r\n+        \"\"\"Actualiza estadísticas del servidor.\"\"\"\r\n+        try:\r\n+            active_bots = len(self.db.get_active_bots())\r\n+            self.server_stats[\"active_bots\"] = active_bots\r\n+            self.server_stats[\"peak_bots\"] = max(self.server_stats[\"peak_bots\"], active_bots)\r\n+            \r\n+            # Estadísticas del sistema\r\n+            cpu_usage = psutil.cpu_percent(interval=1)\r\n+            mem_usage = psutil.virtual_memory().percent\r\n+            disk_usage = psutil.disk_usage('/').percent\r\n+            \r\n+            # Guardar en base de datos\r\n+            self.db.store_system_stats({\r\n+                \"timestamp\": datetime.now(),\r\n+                \"cpu_usage\": cpu_usage,\r\n+                \"mem_usage\": mem_usage,\r\n+                \"disk_usage\": disk_usage,\r\n+                \"active_bots\": active_bots\r\n+            })\r\n+        except Exception as e:\r\n+            logging.error(f\"Error actualizando estadísticas: {e}\")\r\n+\r\n+    def _check_anomalies(self):\r\n+        \"\"\"Detecta anomalías en el comportamiento.\"\"\"\r\n+        try:\r\n+            # Verificar uso excesivo de recursos\r\n+            if psutil.cpu_percent() > 90 or psutil.virtual_memory().percent > 90:\r\n+                self._trigger_alert(\"HIGH_RESOURCE_USAGE\")\r\n+\r\n+            # Verificar desconexiones masivas\r\n+            current_bots = len(self.db.get_active_bots())\r\n+            if current_bots < self.server_stats[\"active_bots\"] * 0.5:\r\n+                self._trigger_alert(\"MASS_DISCONNECTION\")\r\n+\r\n+            # Verificar comandos fallidos\r\n+            recent_commands = self.db.get_recent_commands(limit=100)\r\n+            failed_commands = sum(1 for cmd in recent_commands if not cmd[\"success\"])\r\n+            if failed_commands > 10:\r\n+                self._trigger_alert(\"HIGH_FAILURE_RATE\")\r\n+\r\n+        except Exception as e:\r\n+            logging.error(f\"Error verificando anomalías: {e}\")\r\n+\r\n+    def _trigger_alert(self, alert_type: str, details: Dict = None):\r\n+        \"\"\"Registra y notifica alertas.\"\"\"\r\n+        try:\r\n+            alert = {\r\n+                \"type\": alert_type,\r\n+                \"timestamp\": datetime.now(),\r\n+                \"details\": details or {},\r\n+                \"server_stats\": self.get_current_stats()\r\n+            }\r\n+            self.db.store_alert(alert)\r\n+            logging.warning(f\"Alerta: {alert_type} - {details}\")\r\n+        except Exception as e:\r\n+            logging.error(f\"Error generando alerta: {e}\")\r\n+\r\n+    def record_command(self, bot_id: int, command: str, execution_time: float, success: bool):\r\n+        \"\"\"Registra la ejecución de un comando.\"\"\"\r\n+        try:\r\n+            activity = BotActivity(\r\n+                bot_id=bot_id,\r\n+                command=command,\r\n+                timestamp=datetime.now(),\r\n+                execution_time=execution_time,\r\n+                success=success,\r\n+                resource_usage={\r\n+                    \"cpu\": psutil.cpu_percent(),\r\n+                    \"memory\": psutil.virtual_memory().percent\r\n+                }\r\n+            )\r\n+            self.activities.append(activity)\r\n+            self.server_stats[\"total_commands\"] += 1\r\n+            if not success:\r\n+                self.server_stats[\"failed_commands\"] += 1\r\n+\r\n+            # Mantener solo las últimas 1000 actividades\r\n+            if len(self.activities) > 1000:\r\n+                self.activities = self.activities[-1000:]\r\n+\r\n+        except Exception as e:\r\n+            logging.error(f\"Error registrando comando: {e}\")\r\n+\r\n+    def get_bot_stats(self, bot_id: int) -> Dict:\r\n+        \"\"\"Obtiene estadísticas de un bot específico.\"\"\"\r\n+        try:\r\n+            bot_activities = [a for a in self.activities if a.bot_id == bot_id]\r\n+            total_commands = len(bot_activities)\r\n+            if not total_commands:\r\n+                return {}\r\n+\r\n+            successful_commands = len([a for a in bot_activities if a.success])\r\n+            avg_execution_time = sum(a.execution_time for a in bot_activities) / total_commands\r\n+\r\n+            return {\r\n+                \"total_commands\": total_commands,\r\n+                \"successful_commands\": successful_commands,\r\n+                \"failed_commands\": total_commands - successful_commands,\r\n+                \"success_rate\": (successful_commands / total_commands) * 100,\r\n+                \"average_execution_time\": avg_execution_time,\r\n+                \"last_seen\": max(a.timestamp for a in bot_activities),\r\n+                \"common_commands\": self._get_common_commands(bot_activities)\r\n+            }\r\n+        except Exception as e:\r\n+            logging.error(f\"Error obteniendo estadísticas del bot: {e}\")\r\n+            return {}\r\n+\r\n+    def _get_common_commands(self, activities: List[BotActivity]) -> List[Dict]:\r\n+        \"\"\"Analiza los comandos más comunes.\"\"\"\r\n+        try:\r\n+            command_count = {}\r\n+            for activity in activities:\r\n+                command_count[activity.command] = command_count.get(activity.command, 0) + 1\r\n+\r\n+            return sorted(\r\n+                [{\"command\": cmd, \"count\": count} for cmd, count in command_count.items()],\r\n+                key=lambda x: x[\"count\"],\r\n+                reverse=True\r\n+            )[:5]  # Top 5 comandos más usados\r\n+        except Exception as e:\r\n+            logging.error(f\"Error analizando comandos comunes: {e}\")\r\n+            return []\r\n+\r\n+    def get_current_stats(self) -> Dict:\r\n+        \"\"\"Obtiene estadísticas actuales del servidor.\"\"\"\r\n+        try:\r\n+            uptime = (datetime.now() - self.server_stats[\"start_time\"]).total_seconds()\r\n+            active_bots = len(self.db.get_active_bots())\r\n+\r\n+            return {\r\n+                **self.server_stats,\r\n+                \"uptime\": uptime,\r\n+                \"active_bots\": active_bots,\r\n+                \"cpu_usage\": psutil.cpu_percent(),\r\n+                \"memory_usage\": psutil.virtual_memory().percent,\r\n+                \"disk_usage\": psutil.disk_usage('/').percent,\r\n+                \"command_success_rate\": (\r\n+                    (self.server_stats[\"total_commands\"] - self.server_stats[\"failed_commands\"]) /\r\n+                    self.server_stats[\"total_commands\"] * 100\r\n+                ) if self.server_stats[\"total_commands\"] > 0 else 0\r\n+            }\r\n+        except Exception as e:\r\n+            logging.error(f\"Error obteniendo estadísticas actuales: {e}\")\r\n+            return {}\r\n+\r\n+    def generate_report(self, report_type: str = \"full\") -> Dict:\r\n+        \"\"\"Genera un reporte detallado.\"\"\"\r\n+        try:\r\n+            if report_type == \"full\":\r\n+                return {\r\n+                    \"server_stats\": self.get_current_stats(),\r\n+                    \"bot_stats\": {\r\n+                        bot[\"id\"]: self.get_bot_stats(bot[\"id\"])\r\n+                        for bot in self.db.get_active_bots()\r\n+                    },\r\n+                    \"recent_activities\": [\r\n+                        {\r\n+                            \"bot_id\": a.bot_id,\r\n+                            \"command\": a.command,\r\n+                            \"timestamp\": a.timestamp.isoformat(),\r\n+                            \"success\": a.success,\r\n+                            \"execution_time\": a.execution_time\r\n+                        }\r\n+                        for a in sorted(\r\n+                            self.activities,\r\n+                            key=lambda x: x.timestamp,\r\n+                            reverse=True\r\n+                        )[:50]  # Últimas 50 actividades\r\n+                    ],\r\n+                    \"alerts\": self.db.get_recent_alerts(limit=10)\r\n+                }\r\n+            elif report_type == \"summary\":\r\n+                return {\r\n+                    \"total_bots\": len(self.db.get_active_bots()),\r\n+                    \"total_commands\": self.server_stats[\"total_commands\"],\r\n+                    \"success_rate\": (\r\n+                        (self.server_stats[\"total_commands\"] - self.server_stats[\"failed_commands\"]) /\r\n+                        self.server_stats[\"total_commands\"] * 100\r\n+                    ) if self.server_stats[\"total_commands\"] > 0 else 0,\r\n+                    \"uptime\": (datetime.now() - self.server_stats[\"start_time\"]).total_seconds()\r\n+                }\r\n+            else:\r\n+                raise ValueError(f\"Tipo de reporte no válido: {report_type}\")\r\n+\r\n+        except Exception as e:\r\n+            logging.error(f\"Error generando reporte: {e}\")\r\n+            return {}\r\n"
                }
            ],
            "date": 1740264758264,
            "name": "Commit-0",
            "content": "\"\"\"\r\nMódulo de estadísticas y monitoreo.\r\nRecopila y analiza estadísticas de los bots y el servidor.\r\n\"\"\"\r\n\r\nimport psutil\r\nimport time\r\nimport json\r\nimport logging\r\nfrom datetime import datetime\r\nfrom typing import Dict, List, Optional\r\nfrom dataclasses import dataclass\r\nimport threading\r\n\r\n@dataclass\r\nclass BotActivity:\r\n    bot_id: int\r\n    command: str\r\n    timestamp: datetime\r\n    execution_time: float\r\n    success: bool\r\n    resource_usage: Dict\r\n\r\nclass StatsMonitor:\r\n    def __init__(self, db_manager):\r\n        \"\"\"Inicializa el monitor de estadísticas.\"\"\"\r\n        self.db = db_manager\r\n        self.activities: List[BotActivity] = []\r\n        self.is_monitoring = False\r\n        self._monitor_thread = None\r\n        self.server_stats = {\r\n            \"start_time\": datetime.now(),\r\n            \"total_commands\": 0,\r\n            \"failed_commands\": 0,\r\n            \"active_bots\": 0,\r\n            \"peak_bots\": 0,\r\n            \"data_transferred\": 0\r\n        }\r\n\r\n    def start_monitoring(self):\r\n        \"\"\"Inicia el monitoreo de estadísticas.\"\"\"\r\n        self.is_monitoring = True\r\n        self._monitor_thread = threading.Thread(target=self._monitor_loop, daemon=True)\r\n        self._monitor_thread.start()\r\n\r\n    def stop_monitoring(self):\r\n        \"\"\"Detiene el monitoreo.\"\"\"\r\n        self.is_monitoring = False\r\n        if self._monitor_thread:\r\n            self._monitor_thread.join(timeout=1.0)\r\n\r\n    def _monitor_loop(self):\r\n        \"\"\"Bucle principal de monitoreo.\"\"\"\r\n        while self.is_monitoring:\r\n            try:\r\n                self._update_server_stats()\r\n                self._check_anomalies()\r\n                time.sleep(60)  # Actualizar cada minuto\r\n            except Exception as e:\r\n                logging.error(f\"Error en monitoreo: {e}\")\r\n\r\n    def _update_server_stats(self):\r\n        \"\"\"Actualiza estadísticas del servidor.\"\"\"\r\n        try:\r\n            active_bots = len(self.db.get_active_bots())\r\n            self.server_stats[\"active_bots\"] = active_bots\r\n            self.server_stats[\"peak_bots\"] = max(self.server_stats[\"peak_bots\"], active_bots)\r\n            \r\n            # Estadísticas del sistema\r\n            cpu_usage = psutil.cpu_percent(interval=1)\r\n            mem_usage = psutil.virtual_memory().percent\r\n            disk_usage = psutil.disk_usage('/').percent\r\n            \r\n            # Guardar en base de datos\r\n            self.db.store_system_stats({\r\n                \"timestamp\": datetime.now(),\r\n                \"cpu_usage\": cpu_usage,\r\n                \"mem_usage\": mem_usage,\r\n                \"disk_usage\": disk_usage,\r\n                \"active_bots\": active_bots\r\n            })\r\n        except Exception as e:\r\n            logging.error(f\"Error actualizando estadísticas: {e}\")\r\n\r\n    def _check_anomalies(self):\r\n        \"\"\"Detecta anomalías en el comportamiento.\"\"\"\r\n        try:\r\n            # Verificar uso excesivo de recursos\r\n            if psutil.cpu_percent() > 90 or psutil.virtual_memory().percent > 90:\r\n                self._trigger_alert(\"HIGH_RESOURCE_USAGE\")\r\n\r\n            # Verificar desconexiones masivas\r\n            current_bots = len(self.db.get_active_bots())\r\n            if current_bots < self.server_stats[\"active_bots\"] * 0.5:\r\n                self._trigger_alert(\"MASS_DISCONNECTION\")\r\n\r\n            # Verificar comandos fallidos\r\n            recent_commands = self.db.get_recent_commands(limit=100)\r\n            failed_commands = sum(1 for cmd in recent_commands if not cmd[\"success\"])\r\n            if failed_commands > 10:\r\n                self._trigger_alert(\"HIGH_FAILURE_RATE\")\r\n\r\n        except Exception as e:\r\n            logging.error(f\"Error verificando anomalías: {e}\")\r\n\r\n    def _trigger_alert(self, alert_type: str, details: Dict = None):\r\n        \"\"\"Registra y notifica alertas.\"\"\"\r\n        try:\r\n            alert = {\r\n                \"type\": alert_type,\r\n                \"timestamp\": datetime.now(),\r\n                \"details\": details or {},\r\n                \"server_stats\": self.get_current_stats()\r\n            }\r\n            self.db.store_alert(alert)\r\n            logging.warning(f\"Alerta: {alert_type} - {details}\")\r\n        except Exception as e:\r\n            logging.error(f\"Error generando alerta: {e}\")\r\n\r\n    def record_command(self, bot_id: int, command: str, execution_time: float, success: bool):\r\n        \"\"\"Registra la ejecución de un comando.\"\"\"\r\n        try:\r\n            activity = BotActivity(\r\n                bot_id=bot_id,\r\n                command=command,\r\n                timestamp=datetime.now(),\r\n                execution_time=execution_time,\r\n                success=success,\r\n                resource_usage={\r\n                    \"cpu\": psutil.cpu_percent(),\r\n                    \"memory\": psutil.virtual_memory().percent\r\n                }\r\n            )\r\n            self.activities.append(activity)\r\n            self.server_stats[\"total_commands\"] += 1\r\n            if not success:\r\n                self.server_stats[\"failed_commands\"] += 1\r\n\r\n            # Mantener solo las últimas 1000 actividades\r\n            if len(self.activities) > 1000:\r\n                self.activities = self.activities[-1000:]\r\n\r\n        except Exception as e:\r\n            logging.error(f\"Error registrando comando: {e}\")\r\n\r\n    def get_bot_stats(self, bot_id: int) -> Dict:\r\n        \"\"\"Obtiene estadísticas de un bot específico.\"\"\"\r\n        try:\r\n            bot_activities = [a for a in self.activities if a.bot_id == bot_id]\r\n            total_commands = len(bot_activities)\r\n            if not total_commands:\r\n                return {}\r\n\r\n            successful_commands = len([a for a in bot_activities if a.success])\r\n            avg_execution_time = sum(a.execution_time for a in bot_activities) / total_commands\r\n\r\n            return {\r\n                \"total_commands\": total_commands,\r\n                \"successful_commands\": successful_commands,\r\n                \"failed_commands\": total_commands - successful_commands,\r\n                \"success_rate\": (successful_commands / total_commands) * 100,\r\n                \"average_execution_time\": avg_execution_time,\r\n                \"last_seen\": max(a.timestamp for a in bot_activities),\r\n                \"common_commands\": self._get_common_commands(bot_activities)\r\n            }\r\n        except Exception as e:\r\n            logging.error(f\"Error obteniendo estadísticas del bot: {e}\")\r\n            return {}\r\n\r\n    def _get_common_commands(self, activities: List[BotActivity]) -> List[Dict]:\r\n        \"\"\"Analiza los comandos más comunes.\"\"\"\r\n        try:\r\n            command_count = {}\r\n            for activity in activities:\r\n                command_count[activity.command] = command_count.get(activity.command, 0) + 1\r\n\r\n            return sorted(\r\n                [{\"command\": cmd, \"count\": count} for cmd, count in command_count.items()],\r\n                key=lambda x: x[\"count\"],\r\n                reverse=True\r\n            )[:5]  # Top 5 comandos más usados\r\n        except Exception as e:\r\n            logging.error(f\"Error analizando comandos comunes: {e}\")\r\n            return []\r\n\r\n    def get_current_stats(self) -> Dict:\r\n        \"\"\"Obtiene estadísticas actuales del servidor.\"\"\"\r\n        try:\r\n            uptime = (datetime.now() - self.server_stats[\"start_time\"]).total_seconds()\r\n            active_bots = len(self.db.get_active_bots())\r\n\r\n            return {\r\n                **self.server_stats,\r\n                \"uptime\": uptime,\r\n                \"active_bots\": active_bots,\r\n                \"cpu_usage\": psutil.cpu_percent(),\r\n                \"memory_usage\": psutil.virtual_memory().percent,\r\n                \"disk_usage\": psutil.disk_usage('/').percent,\r\n                \"command_success_rate\": (\r\n                    (self.server_stats[\"total_commands\"] - self.server_stats[\"failed_commands\"]) /\r\n                    self.server_stats[\"total_commands\"] * 100\r\n                ) if self.server_stats[\"total_commands\"] > 0 else 0\r\n            }\r\n        except Exception as e:\r\n            logging.error(f\"Error obteniendo estadísticas actuales: {e}\")\r\n            return {}\r\n\r\n    def generate_report(self, report_type: str = \"full\") -> Dict:\r\n        \"\"\"Genera un reporte detallado.\"\"\"\r\n        try:\r\n            if report_type == \"full\":\r\n                return {\r\n                    \"server_stats\": self.get_current_stats(),\r\n                    \"bot_stats\": {\r\n                        bot[\"id\"]: self.get_bot_stats(bot[\"id\"])\r\n                        for bot in self.db.get_active_bots()\r\n                    },\r\n                    \"recent_activities\": [\r\n                        {\r\n                            \"bot_id\": a.bot_id,\r\n                            \"command\": a.command,\r\n                            \"timestamp\": a.timestamp.isoformat(),\r\n                            \"success\": a.success,\r\n                            \"execution_time\": a.execution_time\r\n                        }\r\n                        for a in sorted(\r\n                            self.activities,\r\n                            key=lambda x: x.timestamp,\r\n                            reverse=True\r\n                        )[:50]  # Últimas 50 actividades\r\n                    ],\r\n                    \"alerts\": self.db.get_recent_alerts(limit=10)\r\n                }\r\n            elif report_type == \"summary\":\r\n                return {\r\n                    \"total_bots\": len(self.db.get_active_bots()),\r\n                    \"total_commands\": self.server_stats[\"total_commands\"],\r\n                    \"success_rate\": (\r\n                        (self.server_stats[\"total_commands\"] - self.server_stats[\"failed_commands\"]) /\r\n                        self.server_stats[\"total_commands\"] * 100\r\n                    ) if self.server_stats[\"total_commands\"] > 0 else 0,\r\n                    \"uptime\": (datetime.now() - self.server_stats[\"start_time\"]).total_seconds()\r\n                }\r\n            else:\r\n                raise ValueError(f\"Tipo de reporte no válido: {report_type}\")\r\n\r\n        except Exception as e:\r\n            logging.error(f\"Error generando reporte: {e}\")\r\n            return {}\r\n"
        }
    ]
}