{
    "sourceFile": "src/modules/process_management.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1740262971119,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740263001124,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,320 @@\n+\"\"\"\r\n+Módulo de gestión de procesos.\r\n+Proporciona funcionalidades para listar, monitorear y controlar procesos del sistema.\r\n+\"\"\"\r\n+\r\n+import psutil\r\n+import logging\r\n+import time\r\n+import platform\r\n+import os\r\n+import signal\r\n+from typing import List, Dict, Optional, Union\r\n+from datetime import datetime\r\n+import threading\r\n+\r\n+class ProcessMonitor:\r\n+    def __init__(self):\r\n+        \"\"\"Inicializa el monitor de procesos.\"\"\"\r\n+        self.monitoring = False\r\n+        self.monitored_processes = set()\r\n+        self.monitor_thread = None\r\n+        self.callback = None\r\n+        self.suspicious_patterns = [\r\n+            \"netcat\", \"nc.exe\", \"mimikatz\", \"psexec\",\r\n+            \"powersploit\", \"metasploit\", \"wireshark\",\r\n+            \"tcpdump\", \"nmap\", \"john\", \"hashcat\"\r\n+        ]\r\n+\r\n+    def list_processes(self) -> List[Dict[str, Union[int, str, float]]]:\r\n+        \"\"\"\r\n+        Lista todos los procesos en ejecución con información detallada.\r\n+        \r\n+        Returns:\r\n+            Lista de diccionarios con información de cada proceso\r\n+        \"\"\"\r\n+        try:\r\n+            processes = []\r\n+            for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', \r\n+                                          'memory_percent', 'username', 'status']):\r\n+                try:\r\n+                    info = proc.info\r\n+                    info['created_time'] = datetime.fromtimestamp(\r\n+                        proc.create_time()\r\n+                    ).strftime('%Y-%m-%d %H:%M:%S')\r\n+                    info['command_line'] = \" \".join(proc.cmdline()) if proc.cmdline() else \"\"\r\n+                    info['suspicious'] = any(pattern in info['name'].lower() \r\n+                                          for pattern in self.suspicious_patterns)\r\n+                    processes.append(info)\r\n+                except (psutil.NoSuchProcess, psutil.AccessDenied):\r\n+                    continue\r\n+            return processes\r\n+        except Exception as e:\r\n+            logging.error(f\"Error listando procesos: {e}\")\r\n+            return []\r\n+\r\n+    def get_process_info(self, pid: int) -> Optional[Dict[str, Union[int, str, float]]]:\r\n+        \"\"\"\r\n+        Obtiene información detallada de un proceso específico.\r\n+        \r\n+        Args:\r\n+            pid: ID del proceso\r\n+            \r\n+        Returns:\r\n+            Diccionario con información detallada del proceso\r\n+        \"\"\"\r\n+        try:\r\n+            proc = psutil.Process(pid)\r\n+            info = {\r\n+                'pid': proc.pid,\r\n+                'name': proc.name(),\r\n+                'status': proc.status(),\r\n+                'cpu_percent': proc.cpu_percent(),\r\n+                'memory_percent': proc.memory_percent(),\r\n+                'username': proc.username(),\r\n+                'exe': proc.exe(),\r\n+                'cwd': proc.cwd(),\r\n+                'command_line': \" \".join(proc.cmdline()),\r\n+                'connections': [conn._asdict() for conn in proc.connections()],\r\n+                'open_files': [file.path for file in proc.open_files()],\r\n+                'threads': proc.num_threads(),\r\n+                'parent': proc.parent().pid if proc.parent() else None,\r\n+                'children': [child.pid for child in proc.children()],\r\n+                'created_time': datetime.fromtimestamp(proc.create_time()).strftime('%Y-%m-%d %H:%M:%S'),\r\n+                'cpu_affinity': proc.cpu_affinity(),\r\n+                'memory_maps': [map._asdict() for map in proc.memory_maps()],\r\n+                'is_running': proc.is_running()\r\n+            }\r\n+            return info\r\n+        except psutil.NoSuchProcess:\r\n+            logging.warning(f\"Proceso {pid} no encontrado\")\r\n+            return None\r\n+        except Exception as e:\r\n+            logging.error(f\"Error obteniendo información del proceso {pid}: {e}\")\r\n+            return None\r\n+\r\n+    def kill_process(self, pid: int, force: bool = False) -> bool:\r\n+        \"\"\"\r\n+        Mata un proceso por su PID.\r\n+        \r\n+        Args:\r\n+            pid: ID del proceso a matar\r\n+            force: Si True, usa SIGKILL en lugar de SIGTERM\r\n+            \r\n+        Returns:\r\n+            bool indicando si se mató el proceso exitosamente\r\n+        \"\"\"\r\n+        try:\r\n+            proc = psutil.Process(pid)\r\n+            if force:\r\n+                proc.kill()  # SIGKILL\r\n+            else:\r\n+                proc.terminate()  # SIGTERM\r\n+            proc.wait(timeout=3)\r\n+            return True\r\n+        except psutil.NoSuchProcess:\r\n+            logging.warning(f\"Proceso {pid} no encontrado\")\r\n+            return False\r\n+        except Exception as e:\r\n+            logging.error(f\"Error matando proceso {pid}: {e}\")\r\n+            return False\r\n+\r\n+    def kill_process_by_name(self, name: str, force: bool = False) -> List[int]:\r\n+        \"\"\"\r\n+        Mata todos los procesos que coincidan con el nombre dado.\r\n+        \r\n+        Args:\r\n+            name: Nombre del proceso a matar\r\n+            force: Si True, usa SIGKILL en lugar de SIGTERM\r\n+            \r\n+        Returns:\r\n+            Lista de PIDs de los procesos terminados\r\n+        \"\"\"\r\n+        killed_pids = []\r\n+        for proc in psutil.process_iter(['pid', 'name']):\r\n+            try:\r\n+                if proc.info['name'].lower() == name.lower():\r\n+                    if self.kill_process(proc.info['pid'], force):\r\n+                        killed_pids.append(proc.info['pid'])\r\n+            except (psutil.NoSuchProcess, psutil.AccessDenied):\r\n+                continue\r\n+        return killed_pids\r\n+\r\n+    def set_process_priority(self, pid: int, priority: int) -> bool:\r\n+        \"\"\"\r\n+        Cambia la prioridad de un proceso.\r\n+        \r\n+        Args:\r\n+            pid: ID del proceso\r\n+            priority: Nueva prioridad (de -20 a 19 en Unix, 0-5 en Windows)\r\n+            \r\n+        Returns:\r\n+            bool indicando si se cambió la prioridad exitosamente\r\n+        \"\"\"\r\n+        try:\r\n+            proc = psutil.Process(pid)\r\n+            if platform.system() == 'Windows':\r\n+                proc.nice(priority)\r\n+            else:\r\n+                os.setpriority(os.PRIO_PROCESS, pid, priority)\r\n+            return True\r\n+        except Exception as e:\r\n+            logging.error(f\"Error cambiando prioridad del proceso {pid}: {e}\")\r\n+            return False\r\n+\r\n+    def start_monitoring(self, callback=None, interval: float = 1.0):\r\n+        \"\"\"\r\n+        Inicia el monitoreo de procesos en tiempo real.\r\n+        \r\n+        Args:\r\n+            callback: Función a llamar cuando hay cambios en los procesos\r\n+            interval: Intervalo de monitoreo en segundos\r\n+        \"\"\"\r\n+        if self.monitoring:\r\n+            return\r\n+\r\n+        self.monitoring = True\r\n+        self.callback = callback\r\n+\r\n+        def monitor_loop():\r\n+            previous_processes = set(p.pid for p in psutil.process_iter())\r\n+            \r\n+            while self.monitoring:\r\n+                try:\r\n+                    current_processes = set(p.pid for p in psutil.process_iter())\r\n+                    \r\n+                    # Detectar nuevos procesos\r\n+                    new_processes = current_processes - previous_processes\r\n+                    for pid in new_processes:\r\n+                        try:\r\n+                            proc = psutil.Process(pid)\r\n+                            if self.callback:\r\n+                                self.callback(\"new\", {\r\n+                                    'pid': pid,\r\n+                                    'name': proc.name(),\r\n+                                    'cmdline': \" \".join(proc.cmdline()),\r\n+                                    'username': proc.username(),\r\n+                                    'created': datetime.fromtimestamp(proc.create_time())\r\n+                                })\r\n+                        except psutil.NoSuchProcess:\r\n+                            continue\r\n+                    \r\n+                    # Detectar procesos terminados\r\n+                    terminated_processes = previous_processes - current_processes\r\n+                    for pid in terminated_processes:\r\n+                        if self.callback:\r\n+                            self.callback(\"terminated\", {'pid': pid})\r\n+                    \r\n+                    previous_processes = current_processes\r\n+                    time.sleep(interval)\r\n+                    \r\n+                except Exception as e:\r\n+                    logging.error(f\"Error en monitoreo de procesos: {e}\")\r\n+                    time.sleep(interval)\r\n+\r\n+        self.monitor_thread = threading.Thread(target=monitor_loop, daemon=True)\r\n+        self.monitor_thread.start()\r\n+\r\n+    def stop_monitoring(self):\r\n+        \"\"\"Detiene el monitoreo de procesos.\"\"\"\r\n+        self.monitoring = False\r\n+        if self.monitor_thread:\r\n+            self.monitor_thread.join(timeout=1.0)\r\n+\r\n+    def find_suspicious_processes(self) -> List[Dict[str, Union[int, str]]]:\r\n+        \"\"\"\r\n+        Busca procesos potencialmente sospechosos.\r\n+        \r\n+        Returns:\r\n+            Lista de procesos sospechosos con su información\r\n+        \"\"\"\r\n+        suspicious = []\r\n+        for proc in psutil.process_iter(['pid', 'name', 'cmdline', 'username']):\r\n+            try:\r\n+                info = proc.info\r\n+                # Verificar patrones sospechosos\r\n+                if any(pattern in info['name'].lower() for pattern in self.suspicious_patterns):\r\n+                    suspicious.append({\r\n+                        'pid': info['pid'],\r\n+                        'name': info['name'],\r\n+                        'cmdline': \" \".join(info['cmdline']) if info['cmdline'] else \"\",\r\n+                        'username': info['username'],\r\n+                        'reason': 'suspicious_name'\r\n+                    })\r\n+                # Verificar uso alto de CPU\r\n+                elif proc.cpu_percent(interval=0.1) > 90:\r\n+                    suspicious.append({\r\n+                        'pid': info['pid'],\r\n+                        'name': info['name'],\r\n+                        'cpu_percent': proc.cpu_percent(),\r\n+                        'reason': 'high_cpu'\r\n+                    })\r\n+                # Verificar conexiones de red sospechosas\r\n+                elif proc.connections():\r\n+                    for conn in proc.connections():\r\n+                        if conn.status == 'LISTEN' and conn.laddr.port < 1024:\r\n+                            suspicious.append({\r\n+                                'pid': info['pid'],\r\n+                                'name': info['name'],\r\n+                                'port': conn.laddr.port,\r\n+                                'reason': 'suspicious_port'\r\n+                            })\r\n+            except (psutil.NoSuchProcess, psutil.AccessDenied):\r\n+                continue\r\n+        return suspicious\r\n+\r\n+    def get_process_tree(self, pid: int = None) -> Dict:\r\n+        \"\"\"\r\n+        Obtiene el árbol de procesos desde un PID dado.\r\n+        Si no se proporciona PID, devuelve el árbol completo.\r\n+        \r\n+        Args:\r\n+            pid: ID del proceso raíz (opcional)\r\n+            \r\n+        Returns:\r\n+            Diccionario representando el árbol de procesos\r\n+        \"\"\"\r\n+        def get_children(parent_pid):\r\n+            children = []\r\n+            try:\r\n+                parent = psutil.Process(parent_pid)\r\n+                for child in parent.children(recursive=False):\r\n+                    try:\r\n+                        children.append({\r\n+                            'pid': child.pid,\r\n+                            'name': child.name(),\r\n+                            'status': child.status(),\r\n+                            'children': get_children(child.pid)\r\n+                        })\r\n+                    except psutil.NoSuchProcess:\r\n+                        continue\r\n+            except psutil.NoSuchProcess:\r\n+                return children\r\n+            return children\r\n+\r\n+        if pid:\r\n+            try:\r\n+                proc = psutil.Process(pid)\r\n+                return {\r\n+                    'pid': proc.pid,\r\n+                    'name': proc.name(),\r\n+                    'status': proc.status(),\r\n+                    'children': get_children(pid)\r\n+                }\r\n+            except psutil.NoSuchProcess:\r\n+                return {}\r\n+        else:\r\n+            # Obtener procesos raíz (ppid = 1 en Unix, típicamente)\r\n+            root_processes = []\r\n+            for proc in psutil.process_iter(['pid', 'ppid', 'name', 'status']):\r\n+                try:\r\n+                    if proc.ppid() <= 1:\r\n+                        root_processes.append({\r\n+                            'pid': proc.pid,\r\n+                            'name': proc.name(),\r\n+                            'status': proc.status(),\r\n+                            'children': get_children(proc.pid)\r\n+                        })\r\n+                except (psutil.NoSuchProcess, psutil.AccessDenied):\r\n+                    continue\r\n+            return {'processes': root_processes}\r\n"
                },
                {
                    "date": 1740266625120,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -317,324 +317,4 @@\n                         })\r\n                 except (psutil.NoSuchProcess, psutil.AccessDenied):\r\n                     continue\r\n             return {'processes': root_processes}\r\n-\"\"\"\r\n-Módulo de gestión de procesos.\r\n-Proporciona funcionalidades para listar, monitorear y controlar procesos del sistema.\r\n-\"\"\"\r\n-\r\n-import psutil\r\n-import logging\r\n-import time\r\n-import platform\r\n-import os\r\n-import signal\r\n-from typing import List, Dict, Optional, Union\r\n-from datetime import datetime\r\n-import threading\r\n-\r\n-class ProcessMonitor:\r\n-    def __init__(self):\r\n-        \"\"\"Inicializa el monitor de procesos.\"\"\"\r\n-        self.monitoring = False\r\n-        self.monitored_processes = set()\r\n-        self.monitor_thread = None\r\n-        self.callback = None\r\n-        self.suspicious_patterns = [\r\n-            \"netcat\", \"nc.exe\", \"mimikatz\", \"psexec\",\r\n-            \"powersploit\", \"metasploit\", \"wireshark\",\r\n-            \"tcpdump\", \"nmap\", \"john\", \"hashcat\"\r\n-        ]\r\n-\r\n-    def list_processes(self) -> List[Dict[str, Union[int, str, float]]]:\r\n-        \"\"\"\r\n-        Lista todos los procesos en ejecución con información detallada.\r\n-        \r\n-        Returns:\r\n-            Lista de diccionarios con información de cada proceso\r\n-        \"\"\"\r\n-        try:\r\n-            processes = []\r\n-            for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', \r\n-                                          'memory_percent', 'username', 'status']):\r\n-                try:\r\n-                    info = proc.info\r\n-                    info['created_time'] = datetime.fromtimestamp(\r\n-                        proc.create_time()\r\n-                    ).strftime('%Y-%m-%d %H:%M:%S')\r\n-                    info['command_line'] = \" \".join(proc.cmdline()) if proc.cmdline() else \"\"\r\n-                    info['suspicious'] = any(pattern in info['name'].lower() \r\n-                                          for pattern in self.suspicious_patterns)\r\n-                    processes.append(info)\r\n-                except (psutil.NoSuchProcess, psutil.AccessDenied):\r\n-                    continue\r\n-            return processes\r\n-        except Exception as e:\r\n-            logging.error(f\"Error listando procesos: {e}\")\r\n-            return []\r\n-\r\n-    def get_process_info(self, pid: int) -> Optional[Dict[str, Union[int, str, float]]]:\r\n-        \"\"\"\r\n-        Obtiene información detallada de un proceso específico.\r\n-        \r\n-        Args:\r\n-            pid: ID del proceso\r\n-            \r\n-        Returns:\r\n-            Diccionario con información detallada del proceso\r\n-        \"\"\"\r\n-        try:\r\n-            proc = psutil.Process(pid)\r\n-            info = {\r\n-                'pid': proc.pid,\r\n-                'name': proc.name(),\r\n-                'status': proc.status(),\r\n-                'cpu_percent': proc.cpu_percent(),\r\n-                'memory_percent': proc.memory_percent(),\r\n-                'username': proc.username(),\r\n-                'exe': proc.exe(),\r\n-                'cwd': proc.cwd(),\r\n-                'command_line': \" \".join(proc.cmdline()),\r\n-                'connections': [conn._asdict() for conn in proc.connections()],\r\n-                'open_files': [file.path for file in proc.open_files()],\r\n-                'threads': proc.num_threads(),\r\n-                'parent': proc.parent().pid if proc.parent() else None,\r\n-                'children': [child.pid for child in proc.children()],\r\n-                'created_time': datetime.fromtimestamp(proc.create_time()).strftime('%Y-%m-%d %H:%M:%S'),\r\n-                'cpu_affinity': proc.cpu_affinity(),\r\n-                'memory_maps': [map._asdict() for map in proc.memory_maps()],\r\n-                'is_running': proc.is_running()\r\n-            }\r\n-            return info\r\n-        except psutil.NoSuchProcess:\r\n-            logging.warning(f\"Proceso {pid} no encontrado\")\r\n-            return None\r\n-        except Exception as e:\r\n-            logging.error(f\"Error obteniendo información del proceso {pid}: {e}\")\r\n-            return None\r\n-\r\n-    def kill_process(self, pid: int, force: bool = False) -> bool:\r\n-        \"\"\"\r\n-        Mata un proceso por su PID.\r\n-        \r\n-        Args:\r\n-            pid: ID del proceso a matar\r\n-            force: Si True, usa SIGKILL en lugar de SIGTERM\r\n-            \r\n-        Returns:\r\n-            bool indicando si se mató el proceso exitosamente\r\n-        \"\"\"\r\n-        try:\r\n-            proc = psutil.Process(pid)\r\n-            if force:\r\n-                proc.kill()  # SIGKILL\r\n-            else:\r\n-                proc.terminate()  # SIGTERM\r\n-            proc.wait(timeout=3)\r\n-            return True\r\n-        except psutil.NoSuchProcess:\r\n-            logging.warning(f\"Proceso {pid} no encontrado\")\r\n-            return False\r\n-        except Exception as e:\r\n-            logging.error(f\"Error matando proceso {pid}: {e}\")\r\n-            return False\r\n-\r\n-    def kill_process_by_name(self, name: str, force: bool = False) -> List[int]:\r\n-        \"\"\"\r\n-        Mata todos los procesos que coincidan con el nombre dado.\r\n-        \r\n-        Args:\r\n-            name: Nombre del proceso a matar\r\n-            force: Si True, usa SIGKILL en lugar de SIGTERM\r\n-            \r\n-        Returns:\r\n-            Lista de PIDs de los procesos terminados\r\n-        \"\"\"\r\n-        killed_pids = []\r\n-        for proc in psutil.process_iter(['pid', 'name']):\r\n-            try:\r\n-                if proc.info['name'].lower() == name.lower():\r\n-                    if self.kill_process(proc.info['pid'], force):\r\n-                        killed_pids.append(proc.info['pid'])\r\n-            except (psutil.NoSuchProcess, psutil.AccessDenied):\r\n-                continue\r\n-        return killed_pids\r\n-\r\n-    def set_process_priority(self, pid: int, priority: int) -> bool:\r\n-        \"\"\"\r\n-        Cambia la prioridad de un proceso.\r\n-        \r\n-        Args:\r\n-            pid: ID del proceso\r\n-            priority: Nueva prioridad (de -20 a 19 en Unix, 0-5 en Windows)\r\n-            \r\n-        Returns:\r\n-            bool indicando si se cambió la prioridad exitosamente\r\n-        \"\"\"\r\n-        try:\r\n-            proc = psutil.Process(pid)\r\n-            if platform.system() == 'Windows':\r\n-                proc.nice(priority)\r\n-            else:\r\n-                os.setpriority(os.PRIO_PROCESS, pid, priority)\r\n-            return True\r\n-        except Exception as e:\r\n-            logging.error(f\"Error cambiando prioridad del proceso {pid}: {e}\")\r\n-            return False\r\n-\r\n-    def start_monitoring(self, callback=None, interval: float = 1.0):\r\n-        \"\"\"\r\n-        Inicia el monitoreo de procesos en tiempo real.\r\n-        \r\n-        Args:\r\n-            callback: Función a llamar cuando hay cambios en los procesos\r\n-            interval: Intervalo de monitoreo en segundos\r\n-        \"\"\"\r\n-        if self.monitoring:\r\n-            return\r\n-\r\n-        self.monitoring = True\r\n-        self.callback = callback\r\n-\r\n-        def monitor_loop():\r\n-            previous_processes = set(p.pid for p in psutil.process_iter())\r\n-            \r\n-            while self.monitoring:\r\n-                try:\r\n-                    current_processes = set(p.pid for p in psutil.process_iter())\r\n-                    \r\n-                    # Detectar nuevos procesos\r\n-                    new_processes = current_processes - previous_processes\r\n-                    for pid in new_processes:\r\n-                        try:\r\n-                            proc = psutil.Process(pid)\r\n-                            if self.callback:\r\n-                                self.callback(\"new\", {\r\n-                                    'pid': pid,\r\n-                                    'name': proc.name(),\r\n-                                    'cmdline': \" \".join(proc.cmdline()),\r\n-                                    'username': proc.username(),\r\n-                                    'created': datetime.fromtimestamp(proc.create_time())\r\n-                                })\r\n-                        except psutil.NoSuchProcess:\r\n-                            continue\r\n-                    \r\n-                    # Detectar procesos terminados\r\n-                    terminated_processes = previous_processes - current_processes\r\n-                    for pid in terminated_processes:\r\n-                        if self.callback:\r\n-                            self.callback(\"terminated\", {'pid': pid})\r\n-                    \r\n-                    previous_processes = current_processes\r\n-                    time.sleep(interval)\r\n-                    \r\n-                except Exception as e:\r\n-                    logging.error(f\"Error en monitoreo de procesos: {e}\")\r\n-                    time.sleep(interval)\r\n-\r\n-        self.monitor_thread = threading.Thread(target=monitor_loop, daemon=True)\r\n-        self.monitor_thread.start()\r\n-\r\n-    def stop_monitoring(self):\r\n-        \"\"\"Detiene el monitoreo de procesos.\"\"\"\r\n-        self.monitoring = False\r\n-        if self.monitor_thread:\r\n-            self.monitor_thread.join(timeout=1.0)\r\n-\r\n-    def find_suspicious_processes(self) -> List[Dict[str, Union[int, str]]]:\r\n-        \"\"\"\r\n-        Busca procesos potencialmente sospechosos.\r\n-        \r\n-        Returns:\r\n-            Lista de procesos sospechosos con su información\r\n-        \"\"\"\r\n-        suspicious = []\r\n-        for proc in psutil.process_iter(['pid', 'name', 'cmdline', 'username']):\r\n-            try:\r\n-                info = proc.info\r\n-                # Verificar patrones sospechosos\r\n-                if any(pattern in info['name'].lower() for pattern in self.suspicious_patterns):\r\n-                    suspicious.append({\r\n-                        'pid': info['pid'],\r\n-                        'name': info['name'],\r\n-                        'cmdline': \" \".join(info['cmdline']) if info['cmdline'] else \"\",\r\n-                        'username': info['username'],\r\n-                        'reason': 'suspicious_name'\r\n-                    })\r\n-                # Verificar uso alto de CPU\r\n-                elif proc.cpu_percent(interval=0.1) > 90:\r\n-                    suspicious.append({\r\n-                        'pid': info['pid'],\r\n-                        'name': info['name'],\r\n-                        'cpu_percent': proc.cpu_percent(),\r\n-                        'reason': 'high_cpu'\r\n-                    })\r\n-                # Verificar conexiones de red sospechosas\r\n-                elif proc.connections():\r\n-                    for conn in proc.connections():\r\n-                        if conn.status == 'LISTEN' and conn.laddr.port < 1024:\r\n-                            suspicious.append({\r\n-                                'pid': info['pid'],\r\n-                                'name': info['name'],\r\n-                                'port': conn.laddr.port,\r\n-                                'reason': 'suspicious_port'\r\n-                            })\r\n-            except (psutil.NoSuchProcess, psutil.AccessDenied):\r\n-                continue\r\n-        return suspicious\r\n-\r\n-    def get_process_tree(self, pid: int = None) -> Dict:\r\n-        \"\"\"\r\n-        Obtiene el árbol de procesos desde un PID dado.\r\n-        Si no se proporciona PID, devuelve el árbol completo.\r\n-        \r\n-        Args:\r\n-            pid: ID del proceso raíz (opcional)\r\n-            \r\n-        Returns:\r\n-            Diccionario representando el árbol de procesos\r\n-        \"\"\"\r\n-        def get_children(parent_pid):\r\n-            children = []\r\n-            try:\r\n-                parent = psutil.Process(parent_pid)\r\n-                for child in parent.children(recursive=False):\r\n-                    try:\r\n-                        children.append({\r\n-                            'pid': child.pid,\r\n-                            'name': child.name(),\r\n-                            'status': child.status(),\r\n-                            'children': get_children(child.pid)\r\n-                        })\r\n-                    except psutil.NoSuchProcess:\r\n-                        continue\r\n-            except psutil.NoSuchProcess:\r\n-                return children\r\n-            return children\r\n-\r\n-        if pid:\r\n-            try:\r\n-                proc = psutil.Process(pid)\r\n-                return {\r\n-                    'pid': proc.pid,\r\n-                    'name': proc.name(),\r\n-                    'status': proc.status(),\r\n-                    'children': get_children(pid)\r\n-                }\r\n-            except psutil.NoSuchProcess:\r\n-                return {}\r\n-        else:\r\n-            # Obtener procesos raíz (ppid = 1 en Unix, típicamente)\r\n-            root_processes = []\r\n-            for proc in psutil.process_iter(['pid', 'ppid', 'name', 'status']):\r\n-                try:\r\n-                    if proc.ppid() <= 1:\r\n-                        root_processes.append({\r\n-                            'pid': proc.pid,\r\n-                            'name': proc.name(),\r\n-                            'status': proc.status(),\r\n-                            'children': get_children(proc.pid)\r\n-                        })\r\n-                except (psutil.NoSuchProcess, psutil.AccessDenied):\r\n-                    continue\r\n-            return {'processes': root_processes}\r\n"
                }
            ],
            "date": 1740262971119,
            "name": "Commit-0",
            "content": "\"\"\"\r\nMódulo de gestión de procesos.\r\nProporciona funcionalidades para listar, monitorear y controlar procesos del sistema.\r\n\"\"\"\r\n\r\nimport psutil\r\nimport logging\r\nimport time\r\nimport platform\r\nimport os\r\nimport signal\r\nfrom typing import List, Dict, Optional, Union\r\nfrom datetime import datetime\r\nimport threading\r\n\r\nclass ProcessMonitor:\r\n    def __init__(self):\r\n        \"\"\"Inicializa el monitor de procesos.\"\"\"\r\n        self.monitoring = False\r\n        self.monitored_processes = set()\r\n        self.monitor_thread = None\r\n        self.callback = None\r\n        self.suspicious_patterns = [\r\n            \"netcat\", \"nc.exe\", \"mimikatz\", \"psexec\",\r\n            \"powersploit\", \"metasploit\", \"wireshark\",\r\n            \"tcpdump\", \"nmap\", \"john\", \"hashcat\"\r\n        ]\r\n\r\n    def list_processes(self) -> List[Dict[str, Union[int, str, float]]]:\r\n        \"\"\"\r\n        Lista todos los procesos en ejecución con información detallada.\r\n        \r\n        Returns:\r\n            Lista de diccionarios con información de cada proceso\r\n        \"\"\"\r\n        try:\r\n            processes = []\r\n            for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', \r\n                                          'memory_percent', 'username', 'status']):\r\n                try:\r\n                    info = proc.info\r\n                    info['created_time'] = datetime.fromtimestamp(\r\n                        proc.create_time()\r\n                    ).strftime('%Y-%m-%d %H:%M:%S')\r\n                    info['command_line'] = \" \".join(proc.cmdline()) if proc.cmdline() else \"\"\r\n                    info['suspicious'] = any(pattern in info['name'].lower() \r\n                                          for pattern in self.suspicious_patterns)\r\n                    processes.append(info)\r\n                except (psutil.NoSuchProcess, psutil.AccessDenied):\r\n                    continue\r\n            return processes\r\n        except Exception as e:\r\n            logging.error(f\"Error listando procesos: {e}\")\r\n            return []\r\n\r\n    def get_process_info(self, pid: int) -> Optional[Dict[str, Union[int, str, float]]]:\r\n        \"\"\"\r\n        Obtiene información detallada de un proceso específico.\r\n        \r\n        Args:\r\n            pid: ID del proceso\r\n            \r\n        Returns:\r\n            Diccionario con información detallada del proceso\r\n        \"\"\"\r\n        try:\r\n            proc = psutil.Process(pid)\r\n            info = {\r\n                'pid': proc.pid,\r\n                'name': proc.name(),\r\n                'status': proc.status(),\r\n                'cpu_percent': proc.cpu_percent(),\r\n                'memory_percent': proc.memory_percent(),\r\n                'username': proc.username(),\r\n                'exe': proc.exe(),\r\n                'cwd': proc.cwd(),\r\n                'command_line': \" \".join(proc.cmdline()),\r\n                'connections': [conn._asdict() for conn in proc.connections()],\r\n                'open_files': [file.path for file in proc.open_files()],\r\n                'threads': proc.num_threads(),\r\n                'parent': proc.parent().pid if proc.parent() else None,\r\n                'children': [child.pid for child in proc.children()],\r\n                'created_time': datetime.fromtimestamp(proc.create_time()).strftime('%Y-%m-%d %H:%M:%S'),\r\n                'cpu_affinity': proc.cpu_affinity(),\r\n                'memory_maps': [map._asdict() for map in proc.memory_maps()],\r\n                'is_running': proc.is_running()\r\n            }\r\n            return info\r\n        except psutil.NoSuchProcess:\r\n            logging.warning(f\"Proceso {pid} no encontrado\")\r\n            return None\r\n        except Exception as e:\r\n            logging.error(f\"Error obteniendo información del proceso {pid}: {e}\")\r\n            return None\r\n\r\n    def kill_process(self, pid: int, force: bool = False) -> bool:\r\n        \"\"\"\r\n        Mata un proceso por su PID.\r\n        \r\n        Args:\r\n            pid: ID del proceso a matar\r\n            force: Si True, usa SIGKILL en lugar de SIGTERM\r\n            \r\n        Returns:\r\n            bool indicando si se mató el proceso exitosamente\r\n        \"\"\"\r\n        try:\r\n            proc = psutil.Process(pid)\r\n            if force:\r\n                proc.kill()  # SIGKILL\r\n            else:\r\n                proc.terminate()  # SIGTERM\r\n            proc.wait(timeout=3)\r\n            return True\r\n        except psutil.NoSuchProcess:\r\n            logging.warning(f\"Proceso {pid} no encontrado\")\r\n            return False\r\n        except Exception as e:\r\n            logging.error(f\"Error matando proceso {pid}: {e}\")\r\n            return False\r\n\r\n    def kill_process_by_name(self, name: str, force: bool = False) -> List[int]:\r\n        \"\"\"\r\n        Mata todos los procesos que coincidan con el nombre dado.\r\n        \r\n        Args:\r\n            name: Nombre del proceso a matar\r\n            force: Si True, usa SIGKILL en lugar de SIGTERM\r\n            \r\n        Returns:\r\n            Lista de PIDs de los procesos terminados\r\n        \"\"\"\r\n        killed_pids = []\r\n        for proc in psutil.process_iter(['pid', 'name']):\r\n            try:\r\n                if proc.info['name'].lower() == name.lower():\r\n                    if self.kill_process(proc.info['pid'], force):\r\n                        killed_pids.append(proc.info['pid'])\r\n            except (psutil.NoSuchProcess, psutil.AccessDenied):\r\n                continue\r\n        return killed_pids\r\n\r\n    def set_process_priority(self, pid: int, priority: int) -> bool:\r\n        \"\"\"\r\n        Cambia la prioridad de un proceso.\r\n        \r\n        Args:\r\n            pid: ID del proceso\r\n            priority: Nueva prioridad (de -20 a 19 en Unix, 0-5 en Windows)\r\n            \r\n        Returns:\r\n            bool indicando si se cambió la prioridad exitosamente\r\n        \"\"\"\r\n        try:\r\n            proc = psutil.Process(pid)\r\n            if platform.system() == 'Windows':\r\n                proc.nice(priority)\r\n            else:\r\n                os.setpriority(os.PRIO_PROCESS, pid, priority)\r\n            return True\r\n        except Exception as e:\r\n            logging.error(f\"Error cambiando prioridad del proceso {pid}: {e}\")\r\n            return False\r\n\r\n    def start_monitoring(self, callback=None, interval: float = 1.0):\r\n        \"\"\"\r\n        Inicia el monitoreo de procesos en tiempo real.\r\n        \r\n        Args:\r\n            callback: Función a llamar cuando hay cambios en los procesos\r\n            interval: Intervalo de monitoreo en segundos\r\n        \"\"\"\r\n        if self.monitoring:\r\n            return\r\n\r\n        self.monitoring = True\r\n        self.callback = callback\r\n\r\n        def monitor_loop():\r\n            previous_processes = set(p.pid for p in psutil.process_iter())\r\n            \r\n            while self.monitoring:\r\n                try:\r\n                    current_processes = set(p.pid for p in psutil.process_iter())\r\n                    \r\n                    # Detectar nuevos procesos\r\n                    new_processes = current_processes - previous_processes\r\n                    for pid in new_processes:\r\n                        try:\r\n                            proc = psutil.Process(pid)\r\n                            if self.callback:\r\n                                self.callback(\"new\", {\r\n                                    'pid': pid,\r\n                                    'name': proc.name(),\r\n                                    'cmdline': \" \".join(proc.cmdline()),\r\n                                    'username': proc.username(),\r\n                                    'created': datetime.fromtimestamp(proc.create_time())\r\n                                })\r\n                        except psutil.NoSuchProcess:\r\n                            continue\r\n                    \r\n                    # Detectar procesos terminados\r\n                    terminated_processes = previous_processes - current_processes\r\n                    for pid in terminated_processes:\r\n                        if self.callback:\r\n                            self.callback(\"terminated\", {'pid': pid})\r\n                    \r\n                    previous_processes = current_processes\r\n                    time.sleep(interval)\r\n                    \r\n                except Exception as e:\r\n                    logging.error(f\"Error en monitoreo de procesos: {e}\")\r\n                    time.sleep(interval)\r\n\r\n        self.monitor_thread = threading.Thread(target=monitor_loop, daemon=True)\r\n        self.monitor_thread.start()\r\n\r\n    def stop_monitoring(self):\r\n        \"\"\"Detiene el monitoreo de procesos.\"\"\"\r\n        self.monitoring = False\r\n        if self.monitor_thread:\r\n            self.monitor_thread.join(timeout=1.0)\r\n\r\n    def find_suspicious_processes(self) -> List[Dict[str, Union[int, str]]]:\r\n        \"\"\"\r\n        Busca procesos potencialmente sospechosos.\r\n        \r\n        Returns:\r\n            Lista de procesos sospechosos con su información\r\n        \"\"\"\r\n        suspicious = []\r\n        for proc in psutil.process_iter(['pid', 'name', 'cmdline', 'username']):\r\n            try:\r\n                info = proc.info\r\n                # Verificar patrones sospechosos\r\n                if any(pattern in info['name'].lower() for pattern in self.suspicious_patterns):\r\n                    suspicious.append({\r\n                        'pid': info['pid'],\r\n                        'name': info['name'],\r\n                        'cmdline': \" \".join(info['cmdline']) if info['cmdline'] else \"\",\r\n                        'username': info['username'],\r\n                        'reason': 'suspicious_name'\r\n                    })\r\n                # Verificar uso alto de CPU\r\n                elif proc.cpu_percent(interval=0.1) > 90:\r\n                    suspicious.append({\r\n                        'pid': info['pid'],\r\n                        'name': info['name'],\r\n                        'cpu_percent': proc.cpu_percent(),\r\n                        'reason': 'high_cpu'\r\n                    })\r\n                # Verificar conexiones de red sospechosas\r\n                elif proc.connections():\r\n                    for conn in proc.connections():\r\n                        if conn.status == 'LISTEN' and conn.laddr.port < 1024:\r\n                            suspicious.append({\r\n                                'pid': info['pid'],\r\n                                'name': info['name'],\r\n                                'port': conn.laddr.port,\r\n                                'reason': 'suspicious_port'\r\n                            })\r\n            except (psutil.NoSuchProcess, psutil.AccessDenied):\r\n                continue\r\n        return suspicious\r\n\r\n    def get_process_tree(self, pid: int = None) -> Dict:\r\n        \"\"\"\r\n        Obtiene el árbol de procesos desde un PID dado.\r\n        Si no se proporciona PID, devuelve el árbol completo.\r\n        \r\n        Args:\r\n            pid: ID del proceso raíz (opcional)\r\n            \r\n        Returns:\r\n            Diccionario representando el árbol de procesos\r\n        \"\"\"\r\n        def get_children(parent_pid):\r\n            children = []\r\n            try:\r\n                parent = psutil.Process(parent_pid)\r\n                for child in parent.children(recursive=False):\r\n                    try:\r\n                        children.append({\r\n                            'pid': child.pid,\r\n                            'name': child.name(),\r\n                            'status': child.status(),\r\n                            'children': get_children(child.pid)\r\n                        })\r\n                    except psutil.NoSuchProcess:\r\n                        continue\r\n            except psutil.NoSuchProcess:\r\n                return children\r\n            return children\r\n\r\n        if pid:\r\n            try:\r\n                proc = psutil.Process(pid)\r\n                return {\r\n                    'pid': proc.pid,\r\n                    'name': proc.name(),\r\n                    'status': proc.status(),\r\n                    'children': get_children(pid)\r\n                }\r\n            except psutil.NoSuchProcess:\r\n                return {}\r\n        else:\r\n            # Obtener procesos raíz (ppid = 1 en Unix, típicamente)\r\n            root_processes = []\r\n            for proc in psutil.process_iter(['pid', 'ppid', 'name', 'status']):\r\n                try:\r\n                    if proc.ppid() <= 1:\r\n                        root_processes.append({\r\n                            'pid': proc.pid,\r\n                            'name': proc.name(),\r\n                            'status': proc.status(),\r\n                            'children': get_children(proc.pid)\r\n                        })\r\n                except (psutil.NoSuchProcess, psutil.AccessDenied):\r\n                    continue\r\n            return {'processes': root_processes}\r\n"
        }
    ]
}